var searchIndex = {};
searchIndex["nrf52dk"] = {"doc":"Tock kernel for the Nordic Semiconductor nRF52 development kit (DK), a.k.a. the PCA10040. It is based on nRF52838 SoC (Cortex M4 core with a BLE transceiver) with many exported I/O and peripherals.","items":[[3,"Platform","nrf52dk","",null,null],[12,"console","","",0,null],[12,"button","","",0,null],[12,"gpio","","",0,null],[12,"led","","",0,null],[12,"timer","","",0,null],[5,"reset_handler","","",null,{"inputs":[],"output":null}],[0,"io","","",null,null],[3,"Writer","nrf52dk::io","",null,null],[12,"initialized","","",1,null],[5,"panic_fmt","","",null,null],[7,"WRITER","","",null,null],[11,"write_str","","",1,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"result"}}],[7,"APP_MEMORY","nrf52dk","",null,null],[7,"PROCESSES","","",null,null],[17,"LED1_PIN","","",null,null],[17,"LED2_PIN","","",null,null],[17,"LED3_PIN","","",null,null],[17,"LED4_PIN","","",null,null],[17,"BUTTON1_PIN","","",null,null],[17,"BUTTON2_PIN","","",null,null],[17,"BUTTON3_PIN","","",null,null],[17,"BUTTON4_PIN","","",null,null],[17,"BUTTON_RST_PIN","","",null,null],[17,"FAULT_RESPONSE","","",null,null],[17,"NUM_PROCS","","",null,null],[11,"with_driver","","",0,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"f"}],"output":{"name":"r"}}],[14,"print","","",null,null],[14,"println","","",null,null]],"paths":[[3,"Platform"],[3,"Writer"]]};
searchIndex["nrf52"] = {"doc":"","items":[[5,"init","nrf52","",null,null],[0,"peripheral_interrupts","","",null,null],[4,"NvicIdx","nrf52::peripheral_interrupts","",null,null],[13,"POWER_CLOCK","","",0,null],[13,"RADIO","","",0,null],[13,"UART0","","",0,null],[13,"SPI0_TWI0","","",0,null],[13,"SPI1_TWI1","","",0,null],[13,"NFCT","","",0,null],[13,"GPIOTE","","",0,null],[13,"ADC","","",0,null],[13,"TIMER0","","",0,null],[13,"TIMER1","","",0,null],[13,"TIMER2","","",0,null],[13,"RTC0","","",0,null],[13,"TEMP","","",0,null],[13,"RNG","","",0,null],[13,"ECB","","",0,null],[13,"CCM_AAR","","",0,null],[13,"WDT","","",0,null],[13,"RTC1","","",0,null],[13,"QDEC","","",0,null],[13,"LPCOMP","","",0,null],[13,"SWI0","","",0,null],[13,"SWI1","","",0,null],[13,"SWI2","","",0,null],[13,"SWI3","","",0,null],[13,"SWI4","","",0,null],[13,"SWI5","","",0,null],[13,"TIMER3","","",0,null],[13,"TIMER4","","",0,null],[13,"PWM0","","",0,null],[13,"PDM","","",0,null],[13,"MWU","","",0,null],[13,"PWM1","","",0,null],[13,"PWM2","","",0,null],[13,"SPIM2_SPIS2_SPI2","","",0,null],[13,"RTC2","","",0,null],[13,"I2S","","",0,null],[13,"FPU","","",0,null],[11,"clone","","",0,{"inputs":[{"name":"self"}],"output":{"name":"nvicidx"}}],[0,"peripheral_registers","nrf52","",null,null],[3,"RTC1","nrf52::peripheral_registers","",null,null],[12,"tasks_start","","",1,null],[12,"tasks_stop","","",1,null],[12,"tasks_clear","","",1,null],[12,"tasks_trigovrflw","","",1,null],[12,"_reserved1","","",1,null],[12,"events_tick","","",1,null],[12,"events_ovrflw","","",1,null],[12,"_reserved2","","",1,null],[12,"events_compare","","",1,null],[12,"_reserved3","","",1,null],[12,"intenset","","",1,null],[12,"intenclr","","",1,null],[12,"_reserved4","","",1,null],[12,"evten","","",1,null],[12,"evtenset","","",1,null],[12,"evtenclr","","",1,null],[12,"_reserved5","","",1,null],[12,"counter","","",1,null],[12,"prescaler","","",1,null],[12,"_reserved6","","",1,null],[12,"cc","","",1,null],[3,"GPIO","","",null,null],[12,"_reserved1","","",2,null],[12,"out","","",2,null],[12,"outset","","",2,null],[12,"outclr","","",2,null],[12,"in_","","",2,null],[12,"dir","","",2,null],[12,"dirset","","",2,null],[12,"dirclr","","",2,null],[12,"_reserved2","","",2,null],[12,"pin_cnf","","",2,null],[3,"UART","","",null,null],[12,"task_startrx","","",3,null],[12,"task_stoprx","","",3,null],[12,"task_starttx","","",3,null],[12,"task_stoptx","","",3,null],[12,"_reserved1","","",3,null],[12,"task_flush_rx","","",3,null],[12,"_reserved2","","",3,null],[12,"event_cts","","",3,null],[12,"event_ncts","","",3,null],[12,"_reserved3","","",3,null],[12,"event_endrx","","",3,null],[12,"_reserved4","","",3,null],[12,"event_endtx","","",3,null],[12,"event_error","","",3,null],[12,"_reserved6","","",3,null],[12,"event_rxto","","",3,null],[12,"_reserved7","","",3,null],[12,"event_rxstarted","","",3,null],[12,"event_txstarted","","",3,null],[12,"_reserved8","","",3,null],[12,"event_txstopped","","",3,null],[12,"_reserved9","","",3,null],[12,"shorts","","",3,null],[12,"_reserved10","","",3,null],[12,"intenset","","",3,null],[12,"intenclr","","",3,null],[12,"_reserved11","","",3,null],[12,"errorsrc","","",3,null],[12,"_reserved12","","",3,null],[12,"enable","","",3,null],[12,"_reserved13","","",3,null],[12,"pselrts","","",3,null],[12,"pseltxd","","",3,null],[12,"pselcts","","",3,null],[12,"pselrxd","","",3,null],[12,"_reserved14","","",3,null],[12,"baudrate","","",3,null],[12,"_reserved15","","",3,null],[12,"rxd_ptr","","",3,null],[12,"rxd_maxcnt","","",3,null],[12,"rxd_amount","","",3,null],[12,"_reserved16","","",3,null],[12,"txd_ptr","","",3,null],[12,"txd_maxcnt","","",3,null],[12,"txd_amount","","",3,null],[12,"_reserved17","","",3,null],[12,"config","","",3,null],[3,"TIMER","","",null,null],[12,"task_start","","",4,null],[12,"task_stop","","",4,null],[12,"task_count","","",4,null],[12,"task_clear","","",4,null],[12,"task_shutdown","","",4,null],[12,"_reserved0","","",4,null],[12,"task_capture","","",4,null],[12,"_reserved1","","",4,null],[12,"event_compare","","",4,null],[12,"_reserved2","","",4,null],[12,"shorts","","",4,null],[12,"_reserved3","","",4,null],[12,"intenset","","",4,null],[12,"intenclr","","",4,null],[12,"_reserved4","","",4,null],[12,"mode","","",4,null],[12,"bitmode","","",4,null],[12,"_reserved5","","",4,null],[12,"prescaler","","",4,null],[12,"_reserved6","","",4,null],[12,"cc","","",4,null],[3,"UICR","","",null,null],[12,"pselreset0","","",5,null],[12,"pselreset1","","",5,null],[12,"approtect","","",5,null],[12,"nfcpins","","",5,null],[3,"NVMC","","",null,null],[12,"ready","","",6,null],[12,"_reserved1","","",6,null],[12,"config","","",6,null],[12,"erasepage","","",6,null],[12,"erasepcr0","","",6,null],[12,"eraseuicr","","",6,null],[12,"_reserved2","","",6,null],[12,"icachecnf","","",6,null],[12,"_reserved3","","",6,null],[12,"ihit","","",6,null],[12,"imiss","","",6,null],[17,"RTC1_BASE","","",null,null],[17,"GPIO_BASE","","",null,null],[17,"UART_BASE","","",null,null],[17,"TIMER_SIZE","","",null,null],[17,"TIMER_BASE","","",null,null],[17,"UICR_BASE","","",null,null],[17,"NVMC_BASE","","",null,null],[0,"nvic","nrf52","",null,null],[3,"NVIC","nrf52::nvic","",null,null],[12,"iser","","",7,null],[12,"_reserved1","","",7,null],[12,"icer","","",7,null],[12,"_reserved2","","",7,null],[12,"ispr","","",7,null],[12,"_reserved3","","",7,null],[12,"icpr","","",7,null],[5,"nvic","","",null,{"inputs":[],"output":{"name":"nvic"}}],[5,"enable","","",null,{"inputs":[{"name":"nvicidx"}],"output":null}],[5,"disable","","",null,{"inputs":[{"name":"nvicidx"}],"output":null}],[5,"clear_pending","","",null,{"inputs":[{"name":"nvicidx"}],"output":null}],[17,"NVIC_BASE","","",null,null],[0,"chip","nrf52","",null,null],[3,"NRF52","nrf52::chip","",null,null],[12,"0","","",8,null],[7,"IQ_BUF","","",null,null],[7,"INTERRUPT_QUEUE","","",null,null],[17,"IQ_SIZE","","",null,null],[11,"new","","",8,{"inputs":[],"output":{"name":"nrf52"}}],[11,"mpu","","",8,null],[11,"systick","","",8,null],[11,"service_pending_interrupts","","",8,{"inputs":[{"name":"self"}],"output":null}],[11,"has_pending_interrupts","","",8,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[0,"clock","nrf52","The clock peripheral of the nRF51 series (chapter 13 of the nRF51 reference manual v3.0), which manages the low frequency and high frequency clocks. The low frequency clock drives the real time clock (RTC), while the high frequency clocks drive the timer system.",null,null],[3,"Registers","nrf52::clock","",null,null],[12,"tasks_hfclkstart","","",9,null],[12,"tasks_hfclkstop","","",9,null],[12,"tasks_lfclkstart","","",9,null],[12,"tasks_lfclkstop","","",9,null],[12,"tasks_cal","","",9,null],[12,"tasks_cstart","","",9,null],[12,"tasks_cstop","","",9,null],[12,"_reserved1","","",9,null],[12,"events_hfclkstarted","","",9,null],[12,"events_lfclkstarted","","",9,null],[12,"done","","",9,null],[12,"ctto","","",9,null],[12,"_reserved2","","",9,null],[12,"intenset","","",9,null],[12,"intenclr","","",9,null],[12,"_reserved3","","",9,null],[12,"hfclkrun","","",9,null],[12,"hfclkstat","","",9,null],[12,"_reserved4","","",9,null],[12,"lfclkrun","","",9,null],[12,"lfclkstat","","",9,null],[12,"lfclksrccopy","","",9,null],[12,"_reserved5","","",9,null],[12,"lfclksrc","","",9,null],[12,"_reserved6","","",9,null],[12,"ctiv","","",9,null],[12,"_reserved7","","",9,null],[12,"xtalfreq","","",9,null],[3,"Clock","","",null,null],[12,"client","","",10,null],[4,"InterruptField","","",null,null],[13,"HFCLKSTARTED","","",11,null],[13,"LFCLKSTARTED","","",11,null],[13,"DONE","","",11,null],[13,"CTTO","","",11,null],[4,"ClockTaskTriggered","","",null,null],[13,"NO","","",12,null],[13,"YES","","",12,null],[4,"ClockRunning","","",null,null],[13,"NORUN","","",13,null],[13,"RUN","","",13,null],[4,"LowClockSource","","",null,null],[13,"RC","","",14,null],[13,"XTAL","","",14,null],[13,"SYNTH","","",14,null],[13,"MASK","","",14,null],[4,"HighClockSource","","",null,null],[13,"RC","","",15,null],[13,"XTAL","","",15,null],[4,"XtalFreq","","",null,null],[13,"F16MHz","","",16,null],[13,"F32MHz","","",16,null],[5,"CLK","","",null,{"inputs":[],"output":{"name":"registers"}}],[7,"CLOCK","","",null,null],[17,"CLOCK_BASE","","",null,null],[8,"ClockClient","","",null,null],[10,"event","","All clock interrupts are control signals, e.g., when a clock has started etc. We don't actually handle any of them for now, but keep this trait in place for if we do need to in the future.",17,{"inputs":[{"name":"self"}],"output":null}],[11,"set_client","","",10,{"inputs":[{"name":"self"},{"name":"clockclient"}],"output":null}],[11,"interrupt_enable","","",10,{"inputs":[{"name":"self"},{"name":"interruptfield"}],"output":null}],[11,"interrupt_disable","","",10,{"inputs":[{"name":"self"},{"name":"interruptfield"}],"output":null}],[11,"high_start","","",10,{"inputs":[{"name":"self"}],"output":null}],[11,"high_stop","","",10,{"inputs":[{"name":"self"}],"output":null}],[11,"high_started","","",10,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"high_source","","",10,{"inputs":[{"name":"self"}],"output":{"name":"highclocksource"}}],[11,"high_freq","","",10,{"inputs":[{"name":"self"}],"output":{"name":"xtalfreq"}}],[11,"high_set_freq","","",10,{"inputs":[{"name":"self"},{"name":"xtalfreq"}],"output":null}],[11,"high_running","","",10,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"low_start","","",10,{"inputs":[{"name":"self"}],"output":null}],[11,"low_stop","","",10,{"inputs":[{"name":"self"}],"output":null}],[11,"low_started","","",10,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"low_source","","",10,{"inputs":[{"name":"self"}],"output":{"name":"lowclocksource"}}],[11,"low_running","","",10,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"low_set_source","","",10,{"inputs":[{"name":"self"},{"name":"lowclocksource"}],"output":null}],[0,"gpio","nrf52","FIXME: CHECK FOR nRF52-DK",null,null],[3,"GpioteRegisters","nrf52::gpio","The nRF51822 doesn't automatically provide GPIO interrupts. Instead, to receive interrupts from a GPIO line, you must allocate a GPIOTE (GPIO Task and Event) channel, and bind the channel to the desired pin. There are 4 channels. This means that requesting an interrupt can fail, if there are already 4 allocated.",null,null],[12,"out0","","",18,null],[12,"out1","","",18,null],[12,"out2","","",18,null],[12,"out3","","",18,null],[12,"_reserved0","","",18,null],[12,"in0","","",18,null],[12,"in1","","",18,null],[12,"in2","","",18,null],[12,"in3","","",18,null],[12,"_reserved1","","",18,null],[12,"port","","",18,null],[12,"_reserved2","","",18,null],[12,"inten","","",18,null],[12,"intenset","","",18,null],[12,"intenclr","","",18,null],[12,"_reserved3","","",18,null],[12,"config0","","",18,null],[12,"config1","","",18,null],[12,"config2","","",18,null],[12,"config3","","",18,null],[3,"GPIOPin","","",null,null],[12,"pin","","",19,null],[12,"client_data","","",19,null],[12,"client","","",19,null],[3,"Port","","",null,null],[12,"pins","","",20,null],[5,"GPIO","","",null,{"inputs":[],"output":{"name":"gpio"}}],[5,"GPIOTE","","",null,{"inputs":[],"output":{"name":"gpioteregisters"}}],[5,"allocate_channel","","Allocate a GPIOTE channel",null,{"inputs":[],"output":{"name":"i8"}}],[5,"find_channel","","Return which channel is allocated to a pin, or -1 if none.",null,{"inputs":[{"name":"u8"}],"output":{"name":"i8"}}],[5,"GPIOTE_Handler","","",null,{"inputs":[],"output":null}],[7,"PORT","","",null,null],[17,"GPIOTE_BASE","","",null,null],[11,"new","","",19,{"inputs":[{"name":"u8"}],"output":{"name":"gpiopin"}}],[11,"set_client","","",19,{"inputs":[{"name":"self"},{"name":"c"}],"output":null}],[11,"set_input_mode","","",19,{"inputs":[{"name":"self"},{"name":"inputmode"}],"output":null}],[11,"make_output","","",19,{"inputs":[{"name":"self"}],"output":null}],[11,"make_input","","",19,{"inputs":[{"name":"self"}],"output":null}],[11,"disable","","",19,{"inputs":[{"name":"self"}],"output":null}],[11,"set","","",19,{"inputs":[{"name":"self"}],"output":null}],[11,"clear","","",19,{"inputs":[{"name":"self"}],"output":null}],[11,"toggle","","",19,{"inputs":[{"name":"self"}],"output":null}],[11,"read","","",19,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"enable_interrupt","","",19,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"interruptmode"}],"output":null}],[11,"disable_interrupt","","",19,{"inputs":[{"name":"self"}],"output":null}],[11,"handle_interrupt","","",19,{"inputs":[{"name":"self"}],"output":null}],[11,"index","","",20,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"gpiopin"}}],[11,"index_mut","","",20,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"gpiopin"}}],[11,"handle_interrupt","","GPIOTE interrupt: check each of 4 GPIOTE channels, if any has fired then trigger its corresponding pin's interrupt handler.",20,{"inputs":[{"name":"self"}],"output":null}],[0,"timer","nrf52","nRF52 Timer Completly copy-pasted from the implementation of nRF51 but the registers have been moved to peripheral_registers.rs However, nRF52 comes with two additional timers that are not supported at the moment",null,null],[3,"Timer","nrf52::timer","",null,null],[12,"which","","",21,null],[12,"nvic","","",21,null],[12,"client","","",21,null],[3,"TimerAlarm","","",null,null],[12,"which","","",22,null],[12,"nvic","","",22,null],[12,"client","","",22,null],[4,"Location","","",null,null],[13,"TIMER0","","",23,null],[13,"TIMER1","","",23,null],[13,"TIMER2","","",23,null],[5,"TIMER","","",null,{"inputs":[{"name":"location"}],"output":{"name":"timer"}}],[5,"TIMER0_Handler","","",null,{"inputs":[],"output":null}],[5,"TIMER1_Handler","","",null,{"inputs":[],"output":null}],[5,"TIMER2_Handler","","",null,{"inputs":[],"output":null}],[7,"TIMER0","","",null,null],[7,"ALARM1","","",null,null],[7,"TIMER2","","",null,null],[17,"ALARM_CAPTURE","","",null,null],[17,"ALARM_COMPARE","","",null,null],[17,"ALARM_INTERRUPT_BIT","","",null,null],[8,"CompareClient","","",null,null],[10,"compare","","Passes a bitmask of which of the 4 compares/captures fired (0x0-0xf).",24,{"inputs":[{"name":"self"},{"name":"u8"}],"output":null}],[11,"clone","","",23,{"inputs":[{"name":"self"}],"output":{"name":"location"}}],[11,"timer","","",21,{"inputs":[{"name":"self"}],"output":{"name":"timer"}}],[11,"new","","",21,{"inputs":[{"name":"location"},{"name":"nvicidx"}],"output":{"name":"timer"}}],[11,"set_client","","",21,{"inputs":[{"name":"self"},{"name":"compareclient"}],"output":null}],[11,"start","","",21,{"inputs":[{"name":"self"}],"output":null}],[11,"stop","","",21,{"inputs":[{"name":"self"}],"output":null}],[11,"shutdown","","",21,{"inputs":[{"name":"self"}],"output":null}],[11,"clear","","",21,{"inputs":[{"name":"self"}],"output":null}],[11,"capture","","Capture the current timer value into the CC register specified by which, and return the value.",21,{"inputs":[{"name":"self"},{"name":"u8"}],"output":{"name":"u32"}}],[11,"capture_to","","Capture the current value to the CC register specified by which and do not return the value.",21,{"inputs":[{"name":"self"},{"name":"u8"}],"output":null}],[11,"get_shortcuts","","Shortcuts can automatically stop or clear the timer on a particular compare event; refer to section 18.3 of the nRF reference manual for details. Implementation currently provides shortcuts as the raw bitmask.",21,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"set_shortcuts","","",21,{"inputs":[{"name":"self"},{"name":"u32"}],"output":null}],[11,"get_cc0","","",21,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"set_cc0","","",21,{"inputs":[{"name":"self"},{"name":"u32"}],"output":null}],[11,"get_cc1","","",21,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"set_cc1","","",21,{"inputs":[{"name":"self"},{"name":"u32"}],"output":null}],[11,"get_cc2","","",21,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"set_cc2","","",21,{"inputs":[{"name":"self"},{"name":"u32"}],"output":null}],[11,"get_cc3","","",21,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"set_cc3","","",21,{"inputs":[{"name":"self"},{"name":"u32"}],"output":null}],[11,"enable_interrupts","","",21,{"inputs":[{"name":"self"},{"name":"u32"}],"output":null}],[11,"disable_interrupts","","",21,{"inputs":[{"name":"self"},{"name":"u32"}],"output":null}],[11,"enable_nvic","","",21,{"inputs":[{"name":"self"}],"output":null}],[11,"disable_nvic","","",21,{"inputs":[{"name":"self"}],"output":null}],[11,"set_prescaler","","",21,{"inputs":[{"name":"self"},{"name":"u8"}],"output":null}],[11,"get_prescaler","","",21,{"inputs":[{"name":"self"}],"output":{"name":"u8"}}],[11,"handle_interrupt","","When an interrupt occurs, check if any of the 4 compares have created an event, and if so, add it to the bitmask of triggered events that is passed to the client.",21,{"inputs":[{"name":"self"}],"output":null}],[11,"timer","","",22,{"inputs":[{"name":"self"}],"output":{"name":"timer"}}],[11,"new","","",22,{"inputs":[{"name":"location"},{"name":"nvicidx"}],"output":{"name":"timeralarm"}}],[11,"clear","","",22,{"inputs":[{"name":"self"}],"output":null}],[11,"clear_alarm","","",22,{"inputs":[{"name":"self"}],"output":null}],[11,"set_client","","",22,{"inputs":[{"name":"self"},{"name":"client"}],"output":null}],[11,"start","","",22,{"inputs":[{"name":"self"}],"output":null}],[11,"stop","","",22,{"inputs":[{"name":"self"}],"output":null}],[11,"handle_interrupt","","",22,{"inputs":[{"name":"self"}],"output":null}],[11,"enable_interrupts","","",22,{"inputs":[{"name":"self"}],"output":null}],[11,"disable_interrupts","","",22,{"inputs":[{"name":"self"}],"output":null}],[11,"interrupts_enabled","","",22,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"enable_nvic","","",22,{"inputs":[{"name":"self"}],"output":null}],[11,"disable_nvic","","",22,{"inputs":[{"name":"self"}],"output":null}],[11,"value","","",22,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"disable","","",22,{"inputs":[{"name":"self"}],"output":null}],[11,"is_armed","","",22,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"now","","",22,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"set_alarm","","",22,{"inputs":[{"name":"self"},{"name":"u32"}],"output":null}],[11,"get_alarm","","",22,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[0,"rtc","nrf52","",null,null],[3,"Rtc","nrf52::rtc","",null,null],[12,"callback","","",25,null],[5,"rtc1","","",null,{"inputs":[],"output":{"name":"rtc1"}}],[5,"RTC1_Handler","","",null,{"inputs":[],"output":null}],[7,"RTC","","",null,null],[17,"COMPARE0_EVENT","","",null,null],[11,"configure","","",25,{"inputs":[{"name":"self"},{"name":"client"}],"output":null}],[11,"start","","",25,{"inputs":[{"name":"self"}],"output":null}],[11,"disable_interrupts","","",25,{"inputs":[{"name":"self"}],"output":null}],[11,"enable_interrupts","","",25,{"inputs":[{"name":"self"}],"output":null}],[11,"stop","","",25,{"inputs":[{"name":"self"}],"output":null}],[11,"is_running","","",25,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"handle_interrupt","","",25,{"inputs":[{"name":"self"}],"output":null}],[11,"set_client","","",25,{"inputs":[{"name":"self"},{"name":"client"}],"output":null}],[11,"disable","","",25,{"inputs":[{"name":"self"}],"output":null}],[11,"is_armed","","",25,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"now","","",25,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"set_alarm","","",25,{"inputs":[{"name":"self"},{"name":"u32"}],"output":null}],[11,"get_alarm","","",25,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[0,"uart","nrf52","Author: Niklas Adolfsson niklasadolfsson1@gmail.com Date: July 8, 2017",null,null],[3,"UART","nrf52::uart","",null,null],[12,"regs","","",26,null],[12,"client","","",26,null],[12,"buffer","","",26,null],[12,"remaining_bytes","","",26,null],[12,"offset","","",26,null],[3,"UARTParams","","",null,null],[12,"baud_rate","","",27,null],[5,"UART0_Handler","","",null,{"inputs":[],"output":null}],[7,"BUF","","",null,null],[7,"UART0","","",null,null],[17,"BUF_SIZE","","",null,null],[11,"clone","","",27,{"inputs":[{"name":"self"}],"output":{"name":"uartparams"}}],[11,"new","","",26,{"inputs":[],"output":{"name":"uart"}}],[11,"configure","","",26,{"inputs":[{"name":"self"},{"name":"pinmux"},{"name":"pinmux"},{"name":"pinmux"},{"name":"pinmux"}],"output":null}],[11,"set_baud_rate","","",26,{"inputs":[{"name":"self"},{"name":"u32"}],"output":null}],[11,"enable","","",26,{"inputs":[{"name":"self"}],"output":null}],[11,"enable_nvic","","",26,{"inputs":[{"name":"self"}],"output":null}],[11,"disable_nvic","","",26,{"inputs":[{"name":"self"}],"output":null}],[11,"enable_rx_interrupts","","",26,{"inputs":[{"name":"self"}],"output":null}],[11,"enable_tx_interrupts","","",26,{"inputs":[{"name":"self"}],"output":null}],[11,"disable_rx_interrupts","","",26,{"inputs":[{"name":"self"}],"output":null}],[11,"disable_tx_interrupts","","",26,{"inputs":[{"name":"self"}],"output":null}],[11,"handle_interrupt","","",26,{"inputs":[{"name":"self"}],"output":null}],[11,"send_byte","","",26,{"inputs":[{"name":"self"},{"name":"u8"}],"output":null}],[11,"tx_ready","","",26,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"rx_ready","","",26,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"set_dma_pointer_to_buffer","","",26,{"inputs":[{"name":"self"}],"output":null}],[11,"copy_data_to_uart_buffer","","",26,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[11,"set_client","","",26,{"inputs":[{"name":"self"},{"name":"client"}],"output":null}],[11,"init","","",26,{"inputs":[{"name":"self"},{"name":"uartparams"}],"output":null}],[11,"transmit","","",26,null],[11,"receive","","",26,null],[0,"nvmc","nrf52","",null,null],[3,"NVMC","nrf52::nvmc","",null,null],[12,"regs","","",28,null],[11,"new","","",28,{"inputs":[],"output":{"name":"nvmc"}}],[11,"configure_writeable","","",28,{"inputs":[{"name":"self"}],"output":null}],[11,"is_ready","","",28,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[0,"uicr","nrf52","",null,null],[3,"UICR","nrf52::uicr","",null,null],[12,"regs","","",29,null],[11,"new","","",29,{"inputs":[],"output":{"name":"uicr"}}],[11,"set_psel0_reset_pin","","",29,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[11,"set_psel1_reset_pin","","",29,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[0,"pinmux","nrf52","An abstraction over the NRF51 pin multiplexer",null,null],[3,"Pinmux","nrf52::pinmux","An opaque wrapper around a configurable pin.",null,null],[12,"0","","",30,null],[7,"USED_PINS","","",null,null],[11,"clone","","",30,{"inputs":[{"name":"self"}],"output":{"name":"pinmux"}}],[11,"new","","Creates a new `Pinmux` wrapping the numbered pin.",30,{"inputs":[{"name":"u32"}],"output":{"name":"pinmux"}}]],"paths":[[4,"NvicIdx"],[3,"RTC1"],[3,"GPIO"],[3,"UART"],[3,"TIMER"],[3,"UICR"],[3,"NVMC"],[3,"NVIC"],[3,"NRF52"],[3,"Registers"],[3,"Clock"],[4,"InterruptField"],[4,"ClockTaskTriggered"],[4,"ClockRunning"],[4,"LowClockSource"],[4,"HighClockSource"],[4,"XtalFreq"],[8,"ClockClient"],[3,"GpioteRegisters"],[3,"GPIOPin"],[3,"Port"],[3,"Timer"],[3,"TimerAlarm"],[4,"Location"],[8,"CompareClient"],[3,"Rtc"],[3,"UART"],[3,"UARTParams"],[3,"NVMC"],[3,"UICR"],[3,"Pinmux"]]};
searchIndex["nrf51dk"] = {"doc":"Tock kernel for the Nordic Semiconductor nRF51 development kit (DK), a.k.a. the PCA10028. This is an nRF51422 SoC (a Cortex M0 core with a BLE transciver) with many exported pins, LEDs, and buttons. Currently the kernel provides application timers, and GPIO. It will provide a console once the UART is fully implemented and debugged. The application GPIO pins are:","items":[[3,"Platform","nrf51dk","",null,null],[12,"gpio","","",0,null],[12,"timer","","",0,null],[12,"console","","",0,null],[12,"led","","",0,null],[12,"button","","",0,null],[12,"temp","","",0,null],[12,"rng","","",0,null],[12,"aes","","",0,null],[12,"ble_radio","","",0,null],[5,"reset_handler","","",null,{"inputs":[],"output":null}],[0,"io","","",null,null],[3,"Writer","nrf51dk::io","",null,null],[12,"initialized","","",1,null],[5,"rust_begin_unwind","","",null,null],[7,"WRITER","","",null,null],[11,"write_str","","",1,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"result"}}],[7,"APP_MEMORY","nrf51dk","",null,null],[7,"PROCESSES","","",null,null],[17,"LED1_PIN","","",null,null],[17,"LED2_PIN","","",null,null],[17,"LED3_PIN","","",null,null],[17,"LED4_PIN","","",null,null],[17,"BUTTON1_PIN","","",null,null],[17,"BUTTON2_PIN","","",null,null],[17,"BUTTON3_PIN","","",null,null],[17,"BUTTON4_PIN","","",null,null],[17,"FAULT_RESPONSE","","",null,null],[17,"NUM_PROCS","","",null,null],[11,"with_driver","","",0,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"f"}],"output":{"name":"r"}}],[14,"print","","",null,null],[14,"println","","",null,null]],"paths":[[3,"Platform"],[3,"Writer"]]};
searchIndex["nrf51"] = {"doc":"","items":[[5,"init","nrf51","",null,null],[0,"peripheral_registers","","",null,null],[3,"RTC1","nrf51::peripheral_registers","",null,null],[12,"tasks_start","","",0,null],[12,"tasks_stop","","",0,null],[12,"tasks_clear","","",0,null],[12,"tasks_trigovrflw","","",0,null],[12,"_reserved1","","",0,null],[12,"events_tick","","",0,null],[12,"events_ovrflw","","",0,null],[12,"_reserved2","","",0,null],[12,"events_compare","","",0,null],[12,"_reserved3","","",0,null],[12,"intenset","","",0,null],[12,"intenclr","","",0,null],[12,"_reserved4","","",0,null],[12,"evten","","",0,null],[12,"evtenset","","",0,null],[12,"evtenclr","","",0,null],[12,"_reserved5","","",0,null],[12,"counter","","",0,null],[12,"prescaler","","",0,null],[12,"_reserved6","","",0,null],[12,"cc","","",0,null],[12,"_reserved7","","",0,null],[12,"power","","",0,null],[3,"GPIO","","",null,null],[12,"_reserved1","","",1,null],[12,"out","","",1,null],[12,"outset","","",1,null],[12,"outclr","","",1,null],[12,"in_","","",1,null],[12,"dir","","",1,null],[12,"dirset","","",1,null],[12,"dirclr","","",1,null],[12,"_reserved2","","",1,null],[12,"pin_cnf","","",1,null],[3,"TEMP_REGS","","",null,null],[12,"START","","",2,null],[12,"STOP","","",2,null],[12,"_reserved1","","",2,null],[12,"DATARDY","","",2,null],[12,"_reserved2","","",2,null],[12,"INTEN","","",2,null],[12,"INTENSET","","",2,null],[12,"INTENCLR","","",2,null],[12,"_reserved3","","",2,null],[12,"TEMP","","",2,null],[3,"RNG_REGS","","",null,null],[12,"START","","",3,null],[12,"STOP","","",3,null],[12,"_reserved1","","",3,null],[12,"VALRDY","","",3,null],[12,"_reserved2","","",3,null],[12,"SHORTS","","",3,null],[12,"_reserved3","","",3,null],[12,"INTEN","","",3,null],[12,"INTENSET","","",3,null],[12,"INTENCLR","","",3,null],[12,"_reserved4","","",3,null],[12,"CONFIG","","",3,null],[12,"VALUE","","",3,null],[3,"AESECB_REGS","","",null,null],[12,"STARTECB","","",4,null],[12,"STOPECB","","",4,null],[12,"_reserved1","","",4,null],[12,"ENDECB","","",4,null],[12,"ERRORECB","","",4,null],[12,"_reserved2","","",4,null],[12,"INTENSET","","",4,null],[12,"INTENCLR","","",4,null],[12,"_reserved3","","",4,null],[12,"ECBDATAPTR","","",4,null],[3,"RADIO_REGS","","",null,null],[12,"TXEN","","",5,null],[12,"RXEN","","",5,null],[12,"START","","",5,null],[12,"STOP","","",5,null],[12,"DISABLE","","",5,null],[12,"RSSISTART","","",5,null],[12,"RSSISTOP","","",5,null],[12,"BCSTART","","",5,null],[12,"BCSTOP","","",5,null],[12,"_reserved1","","",5,null],[12,"READY","","",5,null],[12,"ADDRESS","","",5,null],[12,"PAYLOAD","","",5,null],[12,"END","","",5,null],[12,"DISABLED","","",5,null],[12,"DEVMATCH","","",5,null],[12,"DEVMISS","","",5,null],[12,"RSSIEND","","",5,null],[12,"_reserved2","","",5,null],[12,"BCMATCH","","",5,null],[12,"_reserved3","","",5,null],[12,"SHORTS","","",5,null],[12,"_reserved4","","",5,null],[12,"INTENSET","","",5,null],[12,"INTENCLR","","",5,null],[12,"_reserved5","","",5,null],[12,"CRCSTATUS","","",5,null],[12,"_reserved6","","",5,null],[12,"RXMATCH","","",5,null],[12,"RXCRC","","",5,null],[12,"DAI","","",5,null],[12,"_reserved7","","",5,null],[12,"PACKETPTR","","",5,null],[12,"FREQEUNCY","","",5,null],[12,"TXPOWER","","",5,null],[12,"MODE","","",5,null],[12,"PCNF0","","",5,null],[12,"PCNF1","","",5,null],[12,"BASE0","","",5,null],[12,"BASE1","","",5,null],[12,"PREFIX0","","",5,null],[12,"PREFIX1","","",5,null],[12,"TXADDRESS","","",5,null],[12,"RXADDRESSES","","",5,null],[12,"CRCCNF","","",5,null],[12,"CRCPOLY","","",5,null],[12,"CRCINIT","","",5,null],[12,"TEST","","",5,null],[12,"TIFS","","",5,null],[12,"RSSISAMPLE","","",5,null],[12,"_reserved8","","",5,null],[12,"STATE","","",5,null],[12,"DATAWHITEIV","","",5,null],[12,"_reserved9","","",5,null],[12,"BCC","","",5,null],[12,"_reserved10","","",5,null],[12,"DAB0","","",5,null],[12,"DAB1","","",5,null],[12,"DAB2","","",5,null],[12,"DAB3","","",5,null],[12,"DAB4","","",5,null],[12,"DAB5","","",5,null],[12,"DAB6","","",5,null],[12,"DAB7","","",5,null],[12,"DAP0","","",5,null],[12,"DAP1","","",5,null],[12,"DAP2","","",5,null],[12,"DAP3","","",5,null],[12,"DAP4","","",5,null],[12,"DAP5","","",5,null],[12,"DAP6","","",5,null],[12,"DAP7","","",5,null],[12,"DACNF","","",5,null],[12,"_reserved11","","",5,null],[12,"OVERRIDE0","","",5,null],[12,"OVERRIDE1","","",5,null],[12,"OVERRIDE2","","",5,null],[12,"OVERRIDE3","","",5,null],[12,"OVERRIDE4","","",5,null],[12,"_reserved12","","",5,null],[12,"POWER","","",5,null],[17,"RTC1_BASE","","",null,null],[17,"GPIO_BASE","","",null,null],[17,"TEMP_BASE","","",null,null],[17,"RNG_BASE","","",null,null],[17,"AESECB_BASE","","",null,null],[17,"RADIO_BASE","","",null,null],[0,"peripheral_interrupts","nrf51","",null,null],[4,"NvicIdx","nrf51::peripheral_interrupts","",null,null],[13,"POWER_CLOCK","","",6,null],[13,"RADIO","","",6,null],[13,"UART0","","",6,null],[13,"SPI0_TWI0","","",6,null],[13,"SPI1_TWI1","","",6,null],[13,"GPIOTE","","",6,null],[13,"ADC","","",6,null],[13,"TIMER0","","",6,null],[13,"TIMER1","","",6,null],[13,"TIMER2","","",6,null],[13,"RTC0","","",6,null],[13,"TEMP","","",6,null],[13,"RNG","","",6,null],[13,"ECB","","",6,null],[13,"CCM_AAR","","",6,null],[13,"WDT","","",6,null],[13,"RTC1","","",6,null],[13,"QDEC","","",6,null],[13,"LPCOMP","","",6,null],[13,"SWI0","","",6,null],[13,"SWI1","","",6,null],[13,"SWI2","","",6,null],[13,"SWI3","","",6,null],[13,"SWI4","","",6,null],[13,"SWI5","","",6,null],[11,"clone","","",6,{"inputs":[{"name":"self"}],"output":{"name":"nvicidx"}}],[0,"nvic","nrf51","",null,null],[3,"NVIC","nrf51::nvic","",null,null],[12,"iser","","",7,null],[12,"_reserved1","","",7,null],[12,"icer","","",7,null],[12,"_reserved2","","",7,null],[12,"ispr","","",7,null],[12,"_reserved3","","",7,null],[12,"icpr","","",7,null],[5,"nvic","","",null,{"inputs":[],"output":{"name":"nvic"}}],[5,"enable","","",null,{"inputs":[{"name":"nvicidx"}],"output":null}],[5,"disable","","",null,{"inputs":[{"name":"nvicidx"}],"output":null}],[5,"clear_pending","","",null,{"inputs":[{"name":"nvicidx"}],"output":null}],[17,"NVIC_BASE","","",null,null],[0,"aes","nrf51","AES128-CTR Driver",null,null],[3,"AesECB","nrf51::aes","",null,null],[12,"regs","","",8,null],[12,"client","","",8,null],[12,"ctr","","",8,null],[12,"input","","",8,null],[12,"keystream","","",8,null],[12,"remaining","","",8,null],[12,"len","","",8,null],[12,"offset","","",8,null],[5,"ECB_Handler","","",null,{"inputs":[],"output":null}],[7,"ECB_DATA","","",null,null],[7,"INIT_CTR","","",null,null],[7,"AESECB","","",null,null],[11,"new","","",8,{"inputs":[],"output":{"name":"aesecb"}}],[11,"ecb_init","","",8,{"inputs":[{"name":"self"}],"output":null}],[11,"update_ctr","","",8,{"inputs":[{"name":"self"}],"output":null}],[11,"crypt","","",8,{"inputs":[{"name":"self"}],"output":null}],[11,"handle_interrupt","","",8,{"inputs":[{"name":"self"}],"output":null}],[11,"enable_interrupts","","",8,{"inputs":[{"name":"self"}],"output":null}],[11,"disable_interrupts","","",8,{"inputs":[{"name":"self"}],"output":null}],[11,"enable_nvic","","",8,{"inputs":[{"name":"self"}],"output":null}],[11,"disable_nvic","","",8,{"inputs":[{"name":"self"}],"output":null}],[11,"set_initial_ctr","","",8,null],[11,"set_client","","",8,{"inputs":[{"name":"self"},{"name":"client"}],"output":null}],[11,"init","","",8,{"inputs":[{"name":"self"}],"output":null}],[11,"set_key","","",8,null],[11,"aes128_crypt_ctr","","",8,null],[0,"chip","nrf51","",null,null],[3,"NRF51","nrf51::chip","",null,null],[12,"0","","",9,null],[7,"IQ_BUF","","",null,null],[7,"INTERRUPT_QUEUE","","",null,null],[17,"IQ_SIZE","","",null,null],[11,"new","","",9,{"inputs":[],"output":{"name":"nrf51"}}],[11,"mpu","","",9,null],[11,"systick","","",9,null],[11,"service_pending_interrupts","","",9,{"inputs":[{"name":"self"}],"output":null}],[11,"has_pending_interrupts","","",9,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[0,"gpio","nrf51","GPIO and GPIOTE (task and events) for the nRF51 series.",null,null],[3,"GpioteRegisters","nrf51::gpio","The nRF51822 doesn't automatically provide GPIO interrupts. Instead, to receive interrupts from a GPIO line, you must allocate a GPIOTE (GPIO Task and Event) channel, and bind the channel to the desired pin. There are 4 channels. This means that requesting an interrupt can fail, if there are already 4 allocated.",null,null],[12,"out0","","",10,null],[12,"out1","","",10,null],[12,"out2","","",10,null],[12,"out3","","",10,null],[12,"_reserved0","","",10,null],[12,"in0","","",10,null],[12,"in1","","",10,null],[12,"in2","","",10,null],[12,"in3","","",10,null],[12,"_reserved1","","",10,null],[12,"port","","",10,null],[12,"_reserved2","","",10,null],[12,"inten","","",10,null],[12,"intenset","","",10,null],[12,"intenclr","","",10,null],[12,"_reserved3","","",10,null],[12,"config0","","",10,null],[12,"config1","","",10,null],[12,"config2","","",10,null],[12,"config3","","",10,null],[3,"GPIOPin","","",null,null],[12,"pin","","",11,null],[12,"client_data","","",11,null],[12,"client","","",11,null],[3,"Port","","",null,null],[12,"pins","","",12,null],[5,"GPIO","","",null,{"inputs":[],"output":{"name":"gpio"}}],[5,"GPIOTE","","",null,{"inputs":[],"output":{"name":"gpioteregisters"}}],[5,"allocate_channel","","Allocate a GPIOTE channel",null,{"inputs":[],"output":{"name":"i8"}}],[5,"find_channel","","Return which channel is allocated to a pin, or -1 if none.",null,{"inputs":[{"name":"u8"}],"output":{"name":"i8"}}],[5,"GPIOTE_Handler","","",null,{"inputs":[],"output":null}],[7,"PORT","","",null,null],[17,"GPIOTE_BASE","","",null,null],[11,"new","","",11,{"inputs":[{"name":"u8"}],"output":{"name":"gpiopin"}}],[11,"set_client","","",11,{"inputs":[{"name":"self"},{"name":"c"}],"output":null}],[11,"set_input_mode","","",11,{"inputs":[{"name":"self"},{"name":"inputmode"}],"output":null}],[11,"make_output","","",11,{"inputs":[{"name":"self"}],"output":null}],[11,"make_input","","",11,{"inputs":[{"name":"self"}],"output":null}],[11,"disable","","",11,{"inputs":[{"name":"self"}],"output":null}],[11,"set","","",11,{"inputs":[{"name":"self"}],"output":null}],[11,"clear","","",11,{"inputs":[{"name":"self"}],"output":null}],[11,"toggle","","",11,{"inputs":[{"name":"self"}],"output":null}],[11,"read","","",11,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"enable_interrupt","","",11,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"interruptmode"}],"output":null}],[11,"disable_interrupt","","",11,{"inputs":[{"name":"self"}],"output":null}],[11,"handle_interrupt","","",11,{"inputs":[{"name":"self"}],"output":null}],[11,"index","","",12,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"gpiopin"}}],[11,"index_mut","","",12,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"gpiopin"}}],[11,"handle_interrupt","","GPIOTE interrupt: check each of 4 GPIOTE channels, if any has fired then trigger its corresponding pin's interrupt handler.",12,{"inputs":[{"name":"self"}],"output":null}],[0,"rtc","nrf51","",null,null],[3,"Rtc","nrf51::rtc","",null,null],[12,"callback","","",13,null],[5,"rtc1","","",null,{"inputs":[],"output":{"name":"rtc1"}}],[5,"RTC1_Handler","","",null,{"inputs":[],"output":null}],[7,"RTC","","",null,null],[17,"COMPARE0_EVENT","","",null,null],[11,"configure","","",13,{"inputs":[{"name":"self"},{"name":"client"}],"output":null}],[11,"start","","",13,{"inputs":[{"name":"self"}],"output":null}],[11,"disable_interrupts","","",13,{"inputs":[{"name":"self"}],"output":null}],[11,"enable_interrupts","","",13,{"inputs":[{"name":"self"}],"output":null}],[11,"stop","","",13,{"inputs":[{"name":"self"}],"output":null}],[11,"is_running","","",13,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"handle_interrupt","","",13,{"inputs":[{"name":"self"}],"output":null}],[11,"set_client","","",13,{"inputs":[{"name":"self"},{"name":"client"}],"output":null}],[11,"disable","","",13,{"inputs":[{"name":"self"}],"output":null}],[11,"is_armed","","",13,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"now","","",13,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"set_alarm","","",13,{"inputs":[{"name":"self"},{"name":"u32"}],"output":null}],[11,"get_alarm","","",13,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[0,"timer","nrf51","The nRF51822 timer system operates off of the high frequency clock (HFCLK) and provides three timers from the clock. Timer0 is tied to the radio through some hard-coded peripheral linkages (e.g., there are dedicated PPI connections between Timer0's compare events and radio tasks, its capture tasks and radio events).",null,null],[3,"Registers","nrf51::timer","",null,null],[12,"task_start","","",14,null],[12,"task_stop","","",14,null],[12,"task_count","","",14,null],[12,"task_clear","","",14,null],[12,"task_shutdown","","",14,null],[12,"_reserved0","","",14,null],[12,"task_capture","","",14,null],[12,"_reserved1","","",14,null],[12,"event_compare","","",14,null],[12,"_reserved2","","",14,null],[12,"shorts","","",14,null],[12,"_reserved3","","",14,null],[12,"intenset","","",14,null],[12,"intenclr","","",14,null],[12,"_reserved4","","",14,null],[12,"mode","","",14,null],[12,"bitmode","","",14,null],[12,"_reserved5","","",14,null],[12,"prescaler","","",14,null],[12,"_reserved6","","",14,null],[12,"cc","","",14,null],[3,"Timer","","",null,null],[12,"which","","",15,null],[12,"nvic","","",15,null],[12,"client","","",15,null],[3,"TimerAlarm","","",null,null],[12,"which","","",16,null],[12,"nvic","","",16,null],[12,"client","","",16,null],[4,"Location","","",null,null],[13,"TIMER0","","",17,null],[13,"TIMER1","","",17,null],[13,"TIMER2","","",17,null],[5,"TIMER","","",null,{"inputs":[{"name":"location"}],"output":{"name":"registers"}}],[5,"TIMER0_Handler","","",null,{"inputs":[],"output":null}],[5,"TIMER1_Handler","","",null,{"inputs":[],"output":null}],[5,"TIMER2_Handler","","",null,{"inputs":[],"output":null}],[7,"TIMER0","","",null,null],[7,"ALARM1","","",null,null],[7,"TIMER2","","",null,null],[17,"SIZE","","",null,null],[17,"TIMER_BASE","","",null,null],[17,"ALARM_CAPTURE","","",null,null],[17,"ALARM_COMPARE","","",null,null],[17,"ALARM_INTERRUPT_BIT","","",null,null],[8,"CompareClient","","",null,null],[10,"compare","","Passes a bitmask of which of the 4 compares/captures fired (0x0-0xf).",18,{"inputs":[{"name":"self"},{"name":"u8"}],"output":null}],[11,"clone","","",17,{"inputs":[{"name":"self"}],"output":{"name":"location"}}],[11,"timer","","",15,{"inputs":[{"name":"self"}],"output":{"name":"registers"}}],[11,"new","","",15,{"inputs":[{"name":"location"},{"name":"nvicidx"}],"output":{"name":"timer"}}],[11,"set_client","","",15,{"inputs":[{"name":"self"},{"name":"compareclient"}],"output":null}],[11,"start","","",15,{"inputs":[{"name":"self"}],"output":null}],[11,"stop","","",15,{"inputs":[{"name":"self"}],"output":null}],[11,"shutdown","","",15,{"inputs":[{"name":"self"}],"output":null}],[11,"clear","","",15,{"inputs":[{"name":"self"}],"output":null}],[11,"capture","","Capture the current timer value into the CC register specified by which, and return the value.",15,{"inputs":[{"name":"self"},{"name":"u8"}],"output":{"name":"u32"}}],[11,"capture_to","","Capture the current value to the CC register specified by which and do not return the value.",15,{"inputs":[{"name":"self"},{"name":"u8"}],"output":null}],[11,"get_shortcuts","","Shortcuts can automatically stop or clear the timer on a particular compare event; refer to section 18.3 of the nRF reference manual for details. Implementation currently provides shortcuts as the raw bitmask.",15,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"set_shortcuts","","",15,{"inputs":[{"name":"self"},{"name":"u32"}],"output":null}],[11,"get_cc0","","",15,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"set_cc0","","",15,{"inputs":[{"name":"self"},{"name":"u32"}],"output":null}],[11,"get_cc1","","",15,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"set_cc1","","",15,{"inputs":[{"name":"self"},{"name":"u32"}],"output":null}],[11,"get_cc2","","",15,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"set_cc2","","",15,{"inputs":[{"name":"self"},{"name":"u32"}],"output":null}],[11,"get_cc3","","",15,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"set_cc3","","",15,{"inputs":[{"name":"self"},{"name":"u32"}],"output":null}],[11,"enable_interrupts","","",15,{"inputs":[{"name":"self"},{"name":"u32"}],"output":null}],[11,"disable_interrupts","","",15,{"inputs":[{"name":"self"},{"name":"u32"}],"output":null}],[11,"enable_nvic","","",15,{"inputs":[{"name":"self"}],"output":null}],[11,"disable_nvic","","",15,{"inputs":[{"name":"self"}],"output":null}],[11,"set_prescaler","","",15,{"inputs":[{"name":"self"},{"name":"u8"}],"output":null}],[11,"get_prescaler","","",15,{"inputs":[{"name":"self"}],"output":{"name":"u8"}}],[11,"handle_interrupt","","When an interrupt occurs, check if any of the 4 compares have created an event, and if so, add it to the bitmask of triggered events that is passed to the client.",15,{"inputs":[{"name":"self"}],"output":null}],[11,"timer","","",16,{"inputs":[{"name":"self"}],"output":{"name":"registers"}}],[11,"new","","",16,{"inputs":[{"name":"location"},{"name":"nvicidx"}],"output":{"name":"timeralarm"}}],[11,"clear","","",16,{"inputs":[{"name":"self"}],"output":null}],[11,"clear_alarm","","",16,{"inputs":[{"name":"self"}],"output":null}],[11,"set_client","","",16,{"inputs":[{"name":"self"},{"name":"client"}],"output":null}],[11,"start","","",16,{"inputs":[{"name":"self"}],"output":null}],[11,"stop","","",16,{"inputs":[{"name":"self"}],"output":null}],[11,"handle_interrupt","","",16,{"inputs":[{"name":"self"}],"output":null}],[11,"enable_interrupts","","",16,{"inputs":[{"name":"self"}],"output":null}],[11,"disable_interrupts","","",16,{"inputs":[{"name":"self"}],"output":null}],[11,"interrupts_enabled","","",16,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"enable_nvic","","",16,{"inputs":[{"name":"self"}],"output":null}],[11,"disable_nvic","","",16,{"inputs":[{"name":"self"}],"output":null}],[11,"value","","",16,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"disable","","",16,{"inputs":[{"name":"self"}],"output":null}],[11,"is_armed","","",16,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"now","","",16,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"set_alarm","","",16,{"inputs":[{"name":"self"},{"name":"u32"}],"output":null}],[11,"get_alarm","","",16,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[0,"clock","nrf51","The clock peripheral of the nRF51 series (chapter 13 of the nRF51 reference manual v3.0), which manages the low frequency and high frequency clocks. The low frequency clock drives the real time clock (RTC), while the high frequency clocks drive the timer system.",null,null],[3,"Registers","nrf51::clock","",null,null],[12,"tasks_hfclkstart","","",19,null],[12,"tasks_hfclkstop","","",19,null],[12,"tasks_lfclkstart","","",19,null],[12,"tasks_lfclkstop","","",19,null],[12,"tasks_cal","","",19,null],[12,"tasks_cstart","","",19,null],[12,"tasks_cstop","","",19,null],[12,"_reserved1","","",19,null],[12,"events_hfclkstarted","","",19,null],[12,"events_lfclkstarted","","",19,null],[12,"done","","",19,null],[12,"ctto","","",19,null],[12,"_reserved2","","",19,null],[12,"intenset","","",19,null],[12,"intenclr","","",19,null],[12,"_reserved3","","",19,null],[12,"hfclkrun","","",19,null],[12,"hfclkstat","","",19,null],[12,"_reserved4","","",19,null],[12,"lfclkrun","","",19,null],[12,"lfclkstat","","",19,null],[12,"lfclksrccopy","","",19,null],[12,"_reserved5","","",19,null],[12,"lfclksrc","","",19,null],[12,"_reserved6","","",19,null],[12,"ctiv","","",19,null],[12,"_reserved7","","",19,null],[12,"xtalfreq","","",19,null],[3,"Clock","","",null,null],[12,"client","","",20,null],[4,"InterruptField","","",null,null],[13,"HFCLKSTARTED","","",21,null],[13,"LFCLKSTARTED","","",21,null],[13,"DONE","","",21,null],[13,"CTTO","","",21,null],[4,"ClockTaskTriggered","","",null,null],[13,"NO","","",22,null],[13,"YES","","",22,null],[4,"ClockRunning","","",null,null],[13,"NORUN","","",23,null],[13,"RUN","","",23,null],[4,"LowClockSource","","",null,null],[13,"RC","","",24,null],[13,"XTAL","","",24,null],[13,"SYNTH","","",24,null],[13,"MASK","","",24,null],[4,"HighClockSource","","",null,null],[13,"RC","","",25,null],[13,"XTAL","","",25,null],[4,"XtalFreq","","",null,null],[13,"F16MHz","","",26,null],[13,"F32MHz","","",26,null],[5,"CLK","","",null,{"inputs":[],"output":{"name":"registers"}}],[7,"CLOCK","","",null,null],[17,"CLOCK_BASE","","",null,null],[8,"ClockClient","","",null,null],[10,"event","","All clock interrupts are control signals, e.g., when a clock has started etc. We don't actually handle any of them for now, but keep this trait in place for if we do need to in the future.",27,{"inputs":[{"name":"self"}],"output":null}],[11,"set_client","","",20,{"inputs":[{"name":"self"},{"name":"clockclient"}],"output":null}],[11,"interrupt_enable","","",20,{"inputs":[{"name":"self"},{"name":"interruptfield"}],"output":null}],[11,"interrupt_disable","","",20,{"inputs":[{"name":"self"},{"name":"interruptfield"}],"output":null}],[11,"high_start","","",20,{"inputs":[{"name":"self"}],"output":null}],[11,"high_stop","","",20,{"inputs":[{"name":"self"}],"output":null}],[11,"high_started","","",20,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"high_source","","",20,{"inputs":[{"name":"self"}],"output":{"name":"highclocksource"}}],[11,"high_freq","","",20,{"inputs":[{"name":"self"}],"output":{"name":"xtalfreq"}}],[11,"high_set_freq","","",20,{"inputs":[{"name":"self"},{"name":"xtalfreq"}],"output":null}],[11,"high_running","","",20,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"low_start","","",20,{"inputs":[{"name":"self"}],"output":null}],[11,"low_stop","","",20,{"inputs":[{"name":"self"}],"output":null}],[11,"low_started","","",20,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"low_source","","",20,{"inputs":[{"name":"self"}],"output":{"name":"lowclocksource"}}],[11,"low_running","","",20,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"low_set_source","","",20,{"inputs":[{"name":"self"},{"name":"lowclocksource"}],"output":null}],[0,"uart","nrf51","",null,null],[3,"Registers","nrf51::uart","",null,null],[12,"task_startrx","","",28,null],[12,"task_stoprx","","",28,null],[12,"task_starttx","","",28,null],[12,"task_stoptx","","",28,null],[12,"_reserved1","","",28,null],[12,"task_suspend","","",28,null],[12,"_reserved2","","",28,null],[12,"event_cts","","",28,null],[12,"event_ncts","","",28,null],[12,"event_rxdrdy","","",28,null],[12,"_reserved3","","",28,null],[12,"event_txdrdy","","",28,null],[12,"_reserved4","","",28,null],[12,"event_error","","",28,null],[12,"_reserved5","","",28,null],[12,"event_rxto","","",28,null],[12,"_reserved6","","",28,null],[12,"shorts","","",28,null],[12,"_reserved7","","",28,null],[12,"intenset","","",28,null],[12,"intenclr","","",28,null],[12,"_reserved8","","",28,null],[12,"errorsrc","","",28,null],[12,"_reserved9","","",28,null],[12,"enable","","",28,null],[12,"_reserved10","","",28,null],[12,"pselrts","","",28,null],[12,"pseltxd","","",28,null],[12,"pselcts","","",28,null],[12,"pselrxd","","",28,null],[12,"rxd","","",28,null],[12,"txd","","",28,null],[12,"_reserved11","","",28,null],[12,"baudrate","","",28,null],[12,"_reserved12","","",28,null],[12,"config","","",28,null],[12,"_reserved13","","",28,null],[12,"power","","",28,null],[3,"UART","","",null,null],[12,"regs","","",29,null],[12,"client","","",29,null],[12,"buffer","","",29,null],[12,"len","","",29,null],[12,"index","","",29,null],[3,"UARTParams","","",null,null],[12,"baud_rate","","",30,null],[5,"UART0_Handler","","",null,{"inputs":[],"output":null}],[7,"UART0","","",null,null],[17,"UART_BASE","","",null,null],[11,"clone","","",30,{"inputs":[{"name":"self"}],"output":{"name":"uartparams"}}],[11,"new","","",29,{"inputs":[],"output":{"name":"uart"}}],[11,"configure","","",29,{"inputs":[{"name":"self"},{"name":"pinmux"},{"name":"pinmux"},{"name":"pinmux"},{"name":"pinmux"}],"output":null}],[11,"set_baud_rate","","",29,{"inputs":[{"name":"self"},{"name":"u32"}],"output":null}],[11,"enable","","",29,{"inputs":[{"name":"self"}],"output":null}],[11,"enable_nvic","","",29,{"inputs":[{"name":"self"}],"output":null}],[11,"disable_nvic","","",29,{"inputs":[{"name":"self"}],"output":null}],[11,"enable_rx_interrupts","","",29,{"inputs":[{"name":"self"}],"output":null}],[11,"enable_tx_interrupts","","",29,{"inputs":[{"name":"self"}],"output":null}],[11,"disable_rx_interrupts","","",29,{"inputs":[{"name":"self"}],"output":null}],[11,"disable_tx_interrupts","","",29,{"inputs":[{"name":"self"}],"output":null}],[11,"handle_interrupt","","",29,{"inputs":[{"name":"self"}],"output":null}],[11,"send_byte","","",29,{"inputs":[{"name":"self"},{"name":"u8"}],"output":null}],[11,"tx_ready","","",29,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"rx_ready","","",29,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"set_client","","",29,{"inputs":[{"name":"self"},{"name":"client"}],"output":null}],[11,"init","","",29,{"inputs":[{"name":"self"},{"name":"uartparams"}],"output":null}],[11,"transmit","","",29,null],[11,"receive","","",29,null],[0,"pinmux","nrf51","An abstraction over the NRF51 pin multiplexer",null,null],[3,"Pinmux","nrf51::pinmux","An opaque wrapper around a configurable pin.",null,null],[12,"0","","",31,null],[7,"USED_PINS","","",null,null],[11,"clone","","",31,{"inputs":[{"name":"self"}],"output":{"name":"pinmux"}}],[11,"new","","Creates a new `Pinmux` wrapping the numbered pin.",31,{"inputs":[{"name":"u32"}],"output":{"name":"pinmux"}}],[0,"temperature","nrf51","Temperature Sensor Driver for nrf51dk",null,null],[3,"Temperature","nrf51::temperature","",null,null],[12,"regs","","",32,null],[12,"client","","",32,null],[5,"TEMP_Handler","","",null,{"inputs":[],"output":null}],[7,"TEMP","","",null,null],[11,"new","","",32,{"inputs":[],"output":{"name":"temperature"}}],[11,"measure","","",32,{"inputs":[{"name":"self"}],"output":null}],[11,"handle_interrupt","","",32,{"inputs":[{"name":"self"}],"output":null}],[11,"enable_interrupts","","",32,{"inputs":[{"name":"self"}],"output":null}],[11,"disable_interrupts","","",32,{"inputs":[{"name":"self"}],"output":null}],[11,"enable_nvic","","",32,{"inputs":[{"name":"self"}],"output":null}],[11,"disable_nvic","","",32,{"inputs":[{"name":"self"}],"output":null}],[11,"set_client","","",32,{"inputs":[{"name":"self"},{"name":"c"}],"output":null}],[11,"take_measurement","","",32,{"inputs":[{"name":"self"}],"output":null}],[0,"trng","nrf51","TRNG driver for nrf51dk",null,null],[3,"Trng","nrf51::trng","",null,null],[12,"regs","","",33,null],[12,"client","","",33,null],[12,"done","","",33,null],[12,"randomness","","",33,null],[3,"TrngIter","","",null,null],[12,"0","","",34,null],[5,"RNG_Handler","","",null,{"inputs":[],"output":null}],[7,"TRNG","","",null,null],[11,"new","","",33,{"inputs":[],"output":{"name":"trng"}}],[11,"handle_interrupt","","",33,{"inputs":[{"name":"self"}],"output":null}],[11,"set_client","","",33,{"inputs":[{"name":"self"},{"name":"client"}],"output":null}],[11,"enable_interrupts","","",33,{"inputs":[{"name":"self"}],"output":null}],[11,"disable_interrupts","","",33,{"inputs":[{"name":"self"}],"output":null}],[11,"enable_nvic","","",33,{"inputs":[{"name":"self"}],"output":null}],[11,"disable_nvic","","",33,{"inputs":[{"name":"self"}],"output":null}],[11,"start_rng","","",33,{"inputs":[{"name":"self"}],"output":null}],[11,"next","","",34,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"get","","",33,{"inputs":[{"name":"self"}],"output":null}],[0,"radio","nrf51","Radio/BLE Driver for nrf51dk",null,null],[3,"Radio","nrf51::radio","",null,null],[12,"regs","","",35,null],[12,"txpower","","",35,null],[12,"client","","",35,null],[12,"freq","","",35,null],[5,"RADIO_Handler","","",null,{"inputs":[],"output":null}],[7,"PAYLOAD","","",null,null],[7,"RADIO","","",null,null],[17,"PACKET0_S1_SIZE","","",null,null],[17,"PACKET0_S0_SIZE","","",null,null],[17,"RADIO_PCNF0_S0LEN_POS","","",null,null],[17,"RADIO_PCNF0_S1LEN_POS","","",null,null],[17,"RADIO_PCNF0_LFLEN_POS","","",null,null],[17,"RADIO_PCNF1_WHITEEN_DISABLED","","",null,null],[17,"RADIO_PCNF1_WHITEEN_ENABLED","","",null,null],[17,"RADIO_PCNF1_WHITEEN_POS","","",null,null],[17,"RADIO_PCNF1_BALEN_POS","","",null,null],[17,"RADIO_PCNF1_STATLEN_POS","","",null,null],[17,"RADIO_PCNF1_MAXLEN_POS","","",null,null],[17,"RADIO_PCNF1_ENDIAN_POS","","",null,null],[17,"RADIO_PCNF1_ENDIAN_BIG","","",null,null],[17,"PACKET_LENGTH_FIELD_SIZE","","",null,null],[17,"PACKET_PAYLOAD_MAXSIZE","","",null,null],[17,"PACKET_BASE_ADDRESS_LENGTH","","",null,null],[17,"PACKET_STATIC_LENGTH","","",null,null],[17,"NRF_LFLEN_LEN_1BYTE","","",null,null],[17,"NRF_S0_LEN_1BYTE","","",null,null],[17,"RADIO_STATE_DISABLE","","",null,null],[17,"RADIO_STATE_RXRU","","",null,null],[17,"RADIO_STATE_RXIDLE","","",null,null],[17,"RADIO_STATE_RX","","",null,null],[17,"RADIO_STATE_RXDISABLE","","",null,null],[17,"RADIO_STATE_TXRU","","",null,null],[17,"RADIO_STATE_TXIDLE","","",null,null],[17,"RADIO_STATE_TX","","",null,null],[17,"RADIO_STATE_TXDISABLE","","",null,null],[17,"PAYLOAD_HDR_PDU","","",null,null],[17,"PAYLOAD_HDR_LEN","","",null,null],[17,"PAYLOAD_ADDR_START","","",null,null],[17,"PAYLOAD_ADDR_END","","",null,null],[17,"PAYLOAD_DATA_START","","",null,null],[17,"PAYLOAD_LENGTH","","",null,null],[11,"new","","",35,{"inputs":[],"output":{"name":"radio"}}],[11,"start_adv_tx","","",35,{"inputs":[{"name":"self"}],"output":null}],[11,"start_adv_rx","","",35,{"inputs":[{"name":"self"}],"output":null}],[11,"set_crc_config","","",35,{"inputs":[{"name":"self"}],"output":null}],[11,"set_packet_config","","",35,{"inputs":[{"name":"self"},{"name":"u32"}],"output":null}],[11,"set_rx_address","","",35,{"inputs":[{"name":"self"},{"name":"u32"}],"output":null}],[11,"set_tx_address","","",35,{"inputs":[{"name":"self"},{"name":"u32"}],"output":null}],[11,"set_channel_rate","","",35,{"inputs":[{"name":"self"},{"name":"u32"}],"output":null}],[11,"set_data_white_iv","","",35,{"inputs":[{"name":"self"},{"name":"u32"}],"output":null}],[11,"set_channel_freq","","",35,{"inputs":[{"name":"self"},{"name":"u32"}],"output":null}],[11,"radio_on","","",35,{"inputs":[{"name":"self"}],"output":null}],[11,"radio_off","","",35,{"inputs":[{"name":"self"}],"output":null}],[11,"set_txpower","","",35,{"inputs":[{"name":"self"}],"output":null}],[11,"set_buffer","","",35,{"inputs":[{"name":"self"}],"output":null}],[11,"handle_interrupt","","",35,{"inputs":[{"name":"self"}],"output":null}],[11,"enable_interrupts","","",35,{"inputs":[{"name":"self"}],"output":null}],[11,"disable_interrupts","","",35,{"inputs":[{"name":"self"}],"output":null}],[11,"enable_nvic","","",35,{"inputs":[{"name":"self"}],"output":null}],[11,"disable_nvic","","",35,{"inputs":[{"name":"self"}],"output":null}],[11,"reset_payload","","",35,{"inputs":[{"name":"self"}],"output":null}],[11,"set_payload_header_pdu","","",35,{"inputs":[{"name":"self"},{"name":"u8"}],"output":null}],[11,"set_payload_header_len","","",35,{"inputs":[{"name":"self"},{"name":"u8"}],"output":null}],[11,"set_advertisement_address","","",35,null],[11,"set_adv_data","","",35,null],[11,"clear_adv_data","","",35,{"inputs":[{"name":"self"}],"output":null}],[11,"set_adv_txpower","","",35,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"returncode"}}],[11,"set_client","","",35,{"inputs":[{"name":"self"},{"name":"c"}],"output":null}],[0,"ble_advertising_driver","nrf51","BLE Capsule",null,null],[3,"App","nrf51::ble_advertising_driver","",null,null],[12,"app_write","","",36,null],[12,"app_read","","",36,null],[12,"scan_callback","","",36,null],[3,"BLE","","",null,null],[12,"radio","","",37,null],[12,"busy","","",37,null],[12,"app","","",37,null],[12,"kernel_tx","","",37,null],[12,"alarm","","",37,null],[12,"advertisement_interval","","",37,null],[12,"is_advertising","","",37,null],[12,"offset","","",37,null],[7,"BUF","","",null,null],[17,"BLE_HS_ADV_TYPE_FLAGS","","",null,null],[17,"BLE_HS_ADV_TYPE_INCOMP_UUIDS16","","",null,null],[17,"BLE_HS_ADV_TYPE_COMP_UUIDS16","","",null,null],[17,"BLE_HS_ADV_TYPE_INCOMP_UUIDS32","","",null,null],[17,"BLE_HS_ADV_TYPE_COMP_UUIDS32","","",null,null],[17,"BLE_HS_ADV_TYPE_INCOMP_UUIDS128","","",null,null],[17,"BLE_HS_ADV_TYPE_COMP_UUIDS128","","",null,null],[17,"BLE_HS_ADV_TYPE_INCOMP_NAME","","",null,null],[17,"BLE_HS_ADV_TYPE_COMP_NAME","","",null,null],[17,"BLE_HS_ADV_TYPE_TX_PWR_LVL","","",null,null],[17,"BLE_HS_ADV_TYPE_SLAVE_ITVL_RANGE","","",null,null],[17,"BLE_HS_ADV_TYPE_SOL_UUIDS16","","",null,null],[17,"BLE_HS_ADV_TYPE_SOL_UUIDS128","","",null,null],[17,"BLE_HS_ADV_TYPE_SVC_DATA_UUID16","","",null,null],[17,"BLE_HS_ADV_TYPE_PUBLIC_TGT_ADDR","","",null,null],[17,"BLE_HS_ADV_TYPE_RANDOM_TGT_ADDR","","",null,null],[17,"BLE_HS_ADV_TYPE_APPEARANCE","","",null,null],[17,"BLE_HS_ADV_TYPE_ADV_ITVL","","",null,null],[17,"BLE_HS_ADV_TYPE_SVC_DATA_UUID32","","",null,null],[17,"BLE_HS_ADV_TYPE_SVC_DATA_UUID128","","",null,null],[17,"BLE_HS_ADV_TYPE_URI","","",null,null],[17,"BLE_HS_ADV_TYPE_MFG_DATA","","",null,null],[17,"BLE_GAP_CONN_MODE_NON","","",null,null],[17,"BLE_GAP_CONN_MODE_DIR","","",null,null],[17,"BLE_GAP_CONN_MODE_UND","","",null,null],[17,"BLE_GAP_SCAN_MODE_NON","","",null,null],[17,"BLE_GAP_SCAN_MODE_DIR","","",null,null],[17,"BLE_GAP_SCAN_MODE_UND","","",null,null],[8,"RxClient","","",null,null],[10,"receive","","",38,null],[11,"default","","",36,{"inputs":[],"output":{"name":"app"}}],[11,"new","","",37,null],[11,"set_adv_data","","",37,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"returncode"}}],[11,"set_adv_addr","","",37,{"inputs":[{"name":"self"}],"output":{"name":"returncode"}}],[11,"configure_periodic_alarm","","",37,{"inputs":[{"name":"self"}],"output":null}],[11,"fired","","",37,{"inputs":[{"name":"self"}],"output":null}],[11,"receive","","",37,null],[11,"command","","",37,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"usize"},{"name":"appid"}],"output":{"name":"returncode"}}],[11,"allow","","",37,{"inputs":[{"name":"self"},{"name":"appid"},{"name":"usize"},{"name":"appslice"}],"output":{"name":"returncode"}}],[11,"subscribe","","",37,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"callback"}],"output":{"name":"returncode"}}]],"paths":[[3,"RTC1"],[3,"GPIO"],[3,"TEMP_REGS"],[3,"RNG_REGS"],[3,"AESECB_REGS"],[3,"RADIO_REGS"],[4,"NvicIdx"],[3,"NVIC"],[3,"AesECB"],[3,"NRF51"],[3,"GpioteRegisters"],[3,"GPIOPin"],[3,"Port"],[3,"Rtc"],[3,"Registers"],[3,"Timer"],[3,"TimerAlarm"],[4,"Location"],[8,"CompareClient"],[3,"Registers"],[3,"Clock"],[4,"InterruptField"],[4,"ClockTaskTriggered"],[4,"ClockRunning"],[4,"LowClockSource"],[4,"HighClockSource"],[4,"XtalFreq"],[8,"ClockClient"],[3,"Registers"],[3,"UART"],[3,"UARTParams"],[3,"Pinmux"],[3,"Temperature"],[3,"Trng"],[3,"TrngIter"],[3,"Radio"],[3,"App"],[3,"BLE"],[8,"RxClient"]]};
searchIndex["cortexm0"] = {"doc":"","items":[[5,"SVC_Handler","cortexm0","",null,{"inputs":[],"output":null}],[5,"switch_to_user","","r0 is top of user stack, r1 Process GOT",null,null]],"paths":[]};
searchIndex["imix"] = {"doc":"","items":[[3,"Imix","imix","",null,null],[12,"console","","",0,null],[12,"gpio","","",0,null],[12,"timer","","",0,null],[12,"si7021","","",0,null],[12,"isl29035","","",0,null],[12,"adc","","",0,null],[12,"led","","",0,null],[12,"button","","",0,null],[12,"spi","","",0,null],[12,"ipc","","",0,null],[12,"ninedof","","",0,null],[12,"radio","","",0,null],[12,"crc","","",0,null],[5,"set_pin_primary_functions","","",null,{"inputs":[],"output":null}],[5,"reset_handler","","",null,{"inputs":[],"output":null}],[0,"io","","",null,null],[3,"Writer","imix::io","",null,null],[12,"initialized","","",1,null],[5,"panic_fmt","","",null,null],[7,"WRITER","","",null,null],[11,"write_str","","",1,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"result"}}],[0,"i2c_dummy","imix","A dummy I2C client",null,null],[3,"ScanClient","imix::i2c_dummy","",null,null],[12,"dev_id","","",2,null],[3,"AccelClient","","",null,null],[12,"state","","",3,null],[3,"LiClient","","",null,null],[12,"state","","",4,null],[4,"AccelClientState","","",null,null],[13,"ReadingWhoami","","",5,null],[13,"Activating","","",5,null],[13,"Deactivating","","",5,null],[13,"ReadingAccelData","","",5,null],[4,"LiClientState","","",null,null],[13,"Enabling","","",6,null],[13,"ReadingLI","","",6,null],[5,"i2c_scan_slaves","","",null,{"inputs":[],"output":null}],[5,"i2c_accel_test","","",null,{"inputs":[],"output":null}],[5,"i2c_li_test","","",null,{"inputs":[],"output":null}],[7,"SCAN_CLIENT","","",null,null],[7,"ACCEL_CLIENT","","",null,null],[7,"LI_CLIENT","","",null,null],[11,"command_complete","","",2,null],[11,"clone","","",5,{"inputs":[{"name":"self"}],"output":{"name":"accelclientstate"}}],[11,"command_complete","","",3,null],[11,"clone","","",6,{"inputs":[{"name":"self"}],"output":{"name":"liclientstate"}}],[11,"command_complete","","",4,null],[0,"spi_dummy","imix","A dummy SPI client to test the SPI implementation",null,null],[3,"DummyCB","imix::spi_dummy","",null,null],[12,"val","","",7,null],[5,"spi_dummy_test","","",null,{"inputs":[],"output":null}],[7,"FLOP","","",null,null],[7,"BUF1","","",null,null],[7,"BUF2","","",null,null],[7,"A5","","",null,null],[7,"SPICB","","",null,null],[11,"read_write_done","","",7,null],[0,"power","imix","Implements a helper function for enabling/disabling power on the imix submodules.",null,null],[3,"DetachablePin","imix::power","",null,null],[12,"pin","","",8,null],[12,"function","","",8,null],[3,"Submodule","","",null,null],[12,"gate_pin","","",9,null],[12,"detachable_pins","","",9,null],[3,"SubmoduleConfig","","",null,null],[12,"rf233","","",10,null],[12,"nrf51422","","",10,null],[12,"sensors","","",10,null],[12,"trng","","",10,null],[5,"configure_submodules","","",null,{"inputs":[{"name":"submoduleconfig"}],"output":null}],[11,"detach","","",8,{"inputs":[{"name":"self"}],"output":null}],[11,"restore","","",8,{"inputs":[{"name":"self"}],"output":null}],[11,"power","","",9,{"inputs":[{"name":"self"},{"name":"bool"}],"output":null}],[7,"APP_MEMORY","imix","",null,null],[7,"PROCESSES","","",null,null],[7,"RF233_BUF","","",null,null],[7,"RF233_RX_BUF","","",null,null],[7,"RF233_REG_WRITE","","",null,null],[7,"RF233_REG_READ","","",null,null],[7,"RADIO_BUF","","",null,null],[17,"NUM_PROCS","","",null,null],[17,"FAULT_RESPONSE","","",null,null],[11,"with_driver","","",0,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"f"}],"output":{"name":"r"}}],[14,"print","","",null,null],[14,"println","","",null,null]],"paths":[[3,"Imix"],[3,"Writer"],[3,"ScanClient"],[3,"AccelClient"],[3,"LiClient"],[4,"AccelClientState"],[4,"LiClientState"],[3,"DummyCB"],[3,"DetachablePin"],[3,"Submodule"],[3,"SubmoduleConfig"]]};
searchIndex["capsules"] = {"doc":"","items":[[0,"button","capsules","Provides capsule driver for controlling buttons on a board.",null,null],[3,"Button","capsules::button","",null,null],[12,"pins","","",0,null],[12,"callback","","",0,null],[6,"SubscribeMap","","",null,null],[11,"new","","",0,null],[11,"subscribe","","Set callbacks.",0,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"callback"}],"output":{"name":"returncode"}}],[11,"command","","Configure interrupts and read state for buttons.",0,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"usize"},{"name":"appid"}],"output":{"name":"returncode"}}],[11,"fired","","",0,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[0,"console","capsules","Provides userspace with the ability to print text via a serial interface.",null,null],[3,"App","capsules::console","",null,null],[12,"write_callback","","",1,null],[12,"read_buffer","","",1,null],[12,"write_buffer","","",1,null],[12,"write_len","","",1,null],[12,"write_remaining","","",1,null],[12,"pending_write","","",1,null],[12,"read_idx","","",1,null],[3,"Console","","",null,null],[12,"uart","","",2,null],[12,"apps","","",2,null],[12,"in_progress","","",2,null],[12,"tx_buffer","","",2,null],[12,"baud_rate","","",2,null],[7,"WRITE_BUF","","",null,null],[11,"default","","",1,{"inputs":[],"output":{"name":"app"}}],[11,"new","","",2,null],[11,"initialize","","",2,{"inputs":[{"name":"self"}],"output":null}],[11,"send_new","","Internal helper function for setting up a new send transaction",2,{"inputs":[{"name":"self"},{"name":"appid"},{"name":"app"},{"name":"callback"}],"output":{"name":"returncode"}}],[11,"send_continue","","Internal helper function for continuing a previously set up transaction Returns true if this send is still active, or false if it has completed",2,{"inputs":[{"name":"self"},{"name":"appid"},{"name":"app"}],"output":{"name":"result"}}],[11,"send","","Internal helper function for sending data for an existing transaction. Cannot fail. If can't send now, it will schedule for sending later.",2,{"inputs":[{"name":"self"},{"name":"appid"},{"name":"app"},{"name":"appslice"}],"output":null}],[11,"allow","","",2,{"inputs":[{"name":"self"},{"name":"appid"},{"name":"usize"},{"name":"appslice"}],"output":{"name":"returncode"}}],[11,"subscribe","","",2,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"callback"}],"output":{"name":"returncode"}}],[11,"command","","",2,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"usize"},{"name":"appid"}],"output":{"name":"returncode"}}],[11,"transmit_complete","","",2,null],[11,"receive_complete","","",2,null],[0,"fm25cl","capsules","Driver for the FM25CL FRAM chip.",null,null],[3,"FM25CL","capsules::fm25cl","",null,null],[12,"spi","","",3,null],[12,"state","","",3,null],[12,"txbuffer","","",3,null],[12,"rxbuffer","","",3,null],[12,"client","","",3,null],[12,"client_custom","","",3,null],[12,"client_buffer","","",3,null],[12,"client_write_address","","",3,null],[12,"client_write_len","","",3,null],[4,"Opcodes","","",null,null],[13,"WriteEnable","","",4,null],[13,"WriteDisable","","",4,null],[13,"ReadStatusRegister","","",4,null],[13,"WriteStatusRegister","","",4,null],[13,"ReadMemory","","",4,null],[13,"WriteMemory","","",4,null],[4,"State","","",null,null],[13,"Idle","","",5,null],[13,"ReadStatus","","Simple read states",5,null],[13,"WriteEnable","","Write to the FRAM",5,null],[13,"WriteMemory","","",5,null],[13,"ReadMemory","","Read from the FRAM",5,null],[7,"TXBUFFER","","",null,null],[7,"RXBUFFER","","",null,null],[7,"KERNEL_TXBUFFER","","",null,null],[7,"KERNEL_RXBUFFER","","",null,null],[17,"SPI_SPEED","","",null,null],[8,"FM25CLCustom","","",null,null],[10,"read_status","","",6,{"inputs":[{"name":"self"}],"output":{"name":"returncode"}}],[8,"FM25CLClient","","",null,null],[10,"status","","",7,{"inputs":[{"name":"self"},{"name":"u8"}],"output":null}],[10,"read","","",7,null],[10,"done","","",7,null],[11,"clone","","",5,{"inputs":[{"name":"self"}],"output":{"name":"state"}}],[11,"eq","","",5,{"inputs":[{"name":"self"},{"name":"state"}],"output":{"name":"bool"}}],[11,"new","","",3,null],[11,"set_client","","",3,{"inputs":[{"name":"self"},{"name":"c"}],"output":null}],[11,"configure_spi","","Setup SPI for this chip",3,{"inputs":[{"name":"self"}],"output":null}],[11,"write","","",3,null],[11,"read","","",3,null],[11,"read_write_done","","",3,null],[11,"read_status","","",3,{"inputs":[{"name":"self"}],"output":{"name":"returncode"}}],[11,"set_client","","",3,{"inputs":[{"name":"self"},{"name":"nonvolatilestorageclient"}],"output":null}],[11,"read","","",3,null],[11,"write","","",3,null],[0,"gpio","capsules","Provides userspace applications with access to GPIO pins.",null,null],[3,"GPIO","capsules::gpio","",null,null],[12,"pins","","",8,null],[12,"callback","","",8,null],[11,"new","","",8,null],[11,"configure_input_pin","","",8,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"usize"}],"output":{"name":"returncode"}}],[11,"configure_interrupt","","",8,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"usize"}],"output":{"name":"returncode"}}],[11,"fired","","",8,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[11,"subscribe","","",8,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"callback"}],"output":{"name":"returncode"}}],[11,"command","","",8,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"usize"},{"name":"appid"}],"output":{"name":"returncode"}}],[0,"isl29035","capsules","Driver for the ISL29035 digital light sensor.",null,null],[3,"Isl29035","capsules::isl29035","",null,null],[12,"i2c","","",9,null],[12,"alarm","","",9,null],[12,"state","","",9,null],[12,"buffer","","",9,null],[12,"callback","","",9,null],[4,"State","","",null,null],[13,"Disabled","","",10,null],[13,"Enabling","","",10,null],[13,"Integrating","","",10,null],[13,"ReadingLI","","",10,null],[13,"Disabling","","",10,null],[7,"BUF","","",null,null],[11,"clone","","",10,{"inputs":[{"name":"self"}],"output":{"name":"state"}}],[11,"eq","","",10,{"inputs":[{"name":"self"},{"name":"state"}],"output":{"name":"bool"}}],[11,"ne","","",10,{"inputs":[{"name":"self"},{"name":"state"}],"output":{"name":"bool"}}],[11,"new","","",9,null],[11,"start_read_lux","","",9,{"inputs":[{"name":"self"}],"output":null}],[11,"subscribe","","",9,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"callback"}],"output":{"name":"returncode"}}],[11,"command","","",9,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"usize"},{"name":"appid"}],"output":{"name":"returncode"}}],[11,"fired","","",9,{"inputs":[{"name":"self"}],"output":null}],[11,"command_complete","","",9,null],[0,"led","capsules","Provides userspace access to LEDs on a board.",null,null],[3,"LED","capsules::led","",null,null],[12,"pins_init","","",11,null],[4,"ActivationMode","","Whether the LEDs are active high or active low on this platform.",null,null],[13,"ActiveHigh","","",12,null],[13,"ActiveLow","","",12,null],[11,"clone","","",12,{"inputs":[{"name":"self"}],"output":{"name":"activationmode"}}],[11,"new","","",11,null],[11,"command","","",11,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"usize"},{"name":"appid"}],"output":{"name":"returncode"}}],[0,"nrf51822_serialization","capsules","Provides userspace with the UART API that the nRF51822 serialization library requires.",null,null],[3,"App","capsules::nrf51822_serialization","",null,null],[12,"callback","","",13,null],[12,"tx_buffer","","",13,null],[12,"rx_buffer","","",13,null],[12,"rx_recv_so_far","","",13,null],[12,"rx_recv_total","","",13,null],[3,"Nrf51822Serialization","","",null,null],[12,"uart","","",14,null],[12,"app","","",14,null],[12,"tx_buffer","","",14,null],[12,"rx_buffer","","",14,null],[7,"WRITE_BUF","","",null,null],[7,"READ_BUF","","",null,null],[11,"default","","",13,{"inputs":[],"output":{"name":"app"}}],[11,"new","","",14,null],[11,"initialize","","",14,{"inputs":[{"name":"self"}],"output":null}],[11,"allow","","Pass application space memory to this driver.",14,{"inputs":[{"name":"self"},{"name":"appid"},{"name":"usize"},{"name":"appslice"}],"output":{"name":"returncode"}}],[11,"subscribe","","Register a callback to the Nrf51822Serialization driver.",14,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"callback"}],"output":{"name":"returncode"}}],[11,"command","","Issue a command to the Nrf51822Serialization driver.",14,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"usize"},{"name":"appid"}],"output":{"name":"returncode"}}],[11,"transmit_complete","","",14,null],[11,"receive_complete","","",14,null],[0,"timer","capsules","Provides userspace applications with a timer API.",null,null],[3,"TimerData","capsules::timer","",null,null],[12,"t0","","",15,null],[12,"expiration","","",15,null],[12,"callback","","",15,null],[3,"TimerDriver","","",null,null],[12,"alarm","","",16,null],[12,"num_armed","","",16,null],[12,"app_timer","","",16,null],[4,"Expiration","","",null,null],[13,"Disabled","","",17,null],[13,"Abs","","",17,null],[13,"Oneshot","","",17,null],[13,"Repeating","","",17,null],[11,"clone","","",17,{"inputs":[{"name":"self"}],"output":{"name":"expiration"}}],[11,"clone","","",15,{"inputs":[{"name":"self"}],"output":{"name":"timerdata"}}],[11,"default","","",15,{"inputs":[],"output":{"name":"timerdata"}}],[11,"new","","",16,{"inputs":[{"name":"a"},{"name":"container"}],"output":{"name":"timerdriver"}}],[11,"reset_active_timer","","",16,{"inputs":[{"name":"self"}],"output":null}],[11,"subscribe","","Subscribe to timer expiration",16,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"callback"}],"output":{"name":"returncode"}}],[11,"command","","Setup and read the MAX17205.",16,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"usize"},{"name":"appid"}],"output":{"name":"returncode"}}],[11,"fired","","",16,{"inputs":[{"name":"self"}],"output":null}],[0,"tmp006","capsules","Driver for the TI TMP006 infrared thermopile contactless temperature sensor.",null,null],[3,"TMP006","capsules::tmp006","",null,null],[12,"i2c","","",18,null],[12,"interrupt_pin","","",18,null],[12,"sampling_period","","",18,null],[12,"repeated_mode","","",18,null],[12,"callback","","",18,null],[12,"protocol_state","","",18,null],[12,"buffer","","",18,null],[4,"Registers","","",null,null],[13,"SensorVoltage","","",19,null],[13,"DieTemperature","","",19,null],[13,"Configuration","","",19,null],[13,"ManufacturerID","","",19,null],[13,"DeviceID","","",19,null],[4,"ProtocolState","","States of the I2C protocol with the TMP006. There are three sequences:",null,null],[13,"Idle","","",20,null],[13,"Configure","","Enable sensor by setting the configuration register.",20,null],[13,"Deconfigure","","Disable sensor by setting the configuration register. Optionally contains the most recent temperature to give back to callbacks.",20,null],[13,"SetRegSensorVoltage","","Set the active register to sensor voltage.",20,null],[13,"ReadingSensorVoltage","","Read the sensor voltage register.",20,null],[13,"SetRegDieTemperature","","Set the active register to die temperature, carrying over the sensor voltage reading.",20,null],[13,"ReadingDieTemperature","","Read the die temperature register, carrying over the sensor voltage reading.",20,null],[5,"calculate_temperature","","",null,{"inputs":[{"name":"i16"},{"name":"i16"}],"output":{"name":"f32"}}],[6,"SensorVoltage","","",null,null],[7,"BUFFER","","",null,null],[17,"MAX_SAMPLING_RATE","","",null,null],[17,"DEFAULT_SAMPLING_RATE","","",null,null],[17,"S_0","","",null,null],[17,"A_1","","",null,null],[17,"A_2","","",null,null],[17,"T_REF","","",null,null],[17,"B_0","","",null,null],[17,"B_1","","",null,null],[17,"B_2","","",null,null],[17,"C_2","","",null,null],[17,"K_TO_C","","",null,null],[17,"C_TO_K","","",null,null],[17,"NV_TO_V","","",null,null],[17,"T_DIE_CONVERT","","",null,null],[17,"V_OBJ_CONVERT","","",null,null],[11,"clone","","",20,{"inputs":[{"name":"self"}],"output":{"name":"protocolstate"}}],[11,"eq","","",20,{"inputs":[{"name":"self"},{"name":"protocolstate"}],"output":{"name":"bool"}}],[11,"ne","","",20,{"inputs":[{"name":"self"},{"name":"protocolstate"}],"output":{"name":"bool"}}],[11,"new","","The `interrupt_pin` must be pulled-up since the TMP006 is open-drain.",18,null],[11,"enable_sensor","","",18,{"inputs":[{"name":"self"},{"name":"u8"}],"output":null}],[11,"disable_sensor","","",18,{"inputs":[{"name":"self"},{"name":"option"}],"output":null}],[11,"enable_interrupts","","",18,{"inputs":[{"name":"self"}],"output":null}],[11,"disable_interrupts","","",18,{"inputs":[{"name":"self"}],"output":null}],[11,"command_complete","","",18,null],[11,"fired","","",18,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[11,"subscribe","","",18,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"callback"}],"output":{"name":"returncode"}}],[11,"command","","",18,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"usize"},{"name":"appid"}],"output":{"name":"returncode"}}],[0,"sdcard","capsules","Provides driver for accessing an SD Card and a userspace Driver.",null,null],[3,"SDCard","capsules::sdcard","SD Card capsule, capable of being built on top of by other kernel capsules",null,null],[12,"spi","","",21,null],[12,"state","","",21,null],[12,"after_state","","",21,null],[12,"alarm","","",21,null],[12,"alarm_state","","",21,null],[12,"alarm_count","","",21,null],[12,"is_initialized","","",21,null],[12,"card_type","","",21,null],[12,"detect_pin","","",21,null],[12,"txbuffer","","",21,null],[12,"rxbuffer","","",21,null],[12,"client","","",21,null],[12,"client_buffer","","",21,null],[12,"client_offset","","",21,null],[3,"SDCardDriver","","Application driver for SD Card capsule, layers on top of SD Card capsule This is used if the SDCard is going to be attached directly to userspace syscalls. SDCardDriver can be ignored if another capsule is going to build off of the SDCard instead",null,null],[12,"sdcard","","",22,null],[12,"app","","",22,null],[12,"kernel_buf","","",22,null],[3,"App","","Holds buffers and whatnot that the application has passed us.",null,null],[12,"callback","","",23,null],[12,"write_buffer","","",23,null],[12,"read_buffer","","",23,null],[4,"SDCmd","","SD card command codes",null,null],[13,"CMD0_Reset","","",24,null],[13,"CMD1_Init","","",24,null],[13,"CMD8_CheckVoltage","","",24,null],[13,"CMD9_ReadCSD","","",24,null],[13,"CMD12_StopRead","","",24,null],[13,"CMD16_SetBlockSize","","",24,null],[13,"CMD17_ReadSingle","","",24,null],[13,"CMD18_ReadMultiple","","",24,null],[13,"CMD24_WriteSingle","","",24,null],[13,"CMD25_WriteMultiple","","",24,null],[13,"CMD55_ManufSpecificCommand","","",24,null],[13,"CMD58_ReadOCR","","",24,null],[13,"ACMD41_ManufSpecificInit","","",24,null],[4,"SDResponse","","SD card response codes",null,null],[13,"R1_Status","","",25,null],[13,"R2_ExtendedStatus","","",25,null],[13,"R3_OCR","","",25,null],[13,"R7_CheckVoltage","","",25,null],[4,"SpiState","","SPI states",null,null],[13,"Idle","","",26,null],[13,"SendManufSpecificCmd","","",26,null],[12,"cmd","capsules::sdcard::SpiState","",26,null],[12,"arg","","",26,null],[13,"InitReset","capsules::sdcard","",26,null],[13,"InitCheckVersion","","",26,null],[13,"InitRepeatHCSInit","","",26,null],[13,"InitCheckCapacity","","",26,null],[13,"InitAppSpecificInit","","",26,null],[13,"InitRepeatAppSpecificInit","","",26,null],[13,"InitRepeatGenericInit","","",26,null],[13,"InitSetBlocksize","","",26,null],[13,"InitComplete","","",26,null],[13,"StartReadBlocks","","",26,null],[12,"count","capsules::sdcard::SpiState","",26,null],[13,"WaitReadBlock","capsules::sdcard","",26,null],[13,"ReadBlockComplete","","",26,null],[13,"WaitReadBlocks","","",26,null],[12,"count","capsules::sdcard::SpiState","",26,null],[13,"ReceivedBlock","capsules::sdcard","",26,null],[12,"count","capsules::sdcard::SpiState","",26,null],[13,"ReadBlocksComplete","capsules::sdcard","",26,null],[13,"StartWriteBlocks","","",26,null],[12,"count","capsules::sdcard::SpiState","",26,null],[13,"WriteBlockResponse","capsules::sdcard","",26,null],[13,"WriteBlockBusy","","",26,null],[13,"WaitWriteBlockBusy","","",26,null],[4,"AlarmState","","Alarm states",null,null],[13,"Idle","","",27,null],[13,"DetectionChange","","",27,null],[13,"RepeatHCSInit","","",27,null],[13,"RepeatAppSpecificInit","","",27,null],[13,"RepeatGenericInit","","",27,null],[13,"WaitForDataBlock","","",27,null],[13,"WaitForDataBlocks","","",27,null],[12,"count","capsules::sdcard::AlarmState","",27,null],[13,"WaitForWriteBusy","capsules::sdcard","",27,null],[4,"ErrorCode","","Error codes returned if an SD card transaction fails",null,null],[13,"CardStateChanged","","",28,null],[13,"InitializationFailure","","",28,null],[13,"ReadFailure","","",28,null],[13,"WriteFailure","","",28,null],[13,"TimeoutFailure","","",28,null],[4,"SDCardType","","SD card types, determined during initialization",null,null],[13,"Uninitialized","","",29,null],[13,"MMC","","",29,null],[13,"SDv1","","",29,null],[13,"SDv2","","",29,null],[13,"SDv2BlockAddressable","","",29,null],[7,"TXBUFFER","","Buffers used for SD card transactions, assigned in board `main.rs` files Constraints:  * RXBUFFER must be greater than or equal to TXBUFFER in length  * Both RXBUFFER and TXBUFFER must be longer  than the SD card's block size",null,null],[7,"RXBUFFER","","",null,null],[7,"KERNEL_BUFFER","","Buffer for SD card driver, assigned in board `main.rs` files",null,null],[17,"SUCCESS_STATUS","","",null,null],[17,"INITIALIZING_STATUS","","",null,null],[17,"DATA_TOKEN","","",null,null],[8,"SDCardClient","","Callback functions from SDCard",null,null],[10,"card_detection_changed","","",30,{"inputs":[{"name":"self"},{"name":"bool"}],"output":null}],[10,"init_done","","",30,{"inputs":[{"name":"self"},{"name":"u32"},{"name":"u64"}],"output":null}],[10,"read_done","","",30,null],[10,"write_done","","",30,null],[10,"error","","",30,{"inputs":[{"name":"self"},{"name":"u32"}],"output":null}],[11,"clone","","",24,{"inputs":[{"name":"self"}],"output":{"name":"sdcmd"}}],[11,"fmt","","",24,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",24,{"inputs":[{"name":"self"},{"name":"sdcmd"}],"output":{"name":"bool"}}],[11,"clone","","",25,{"inputs":[{"name":"self"}],"output":{"name":"sdresponse"}}],[11,"fmt","","",25,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",25,{"inputs":[{"name":"self"},{"name":"sdresponse"}],"output":{"name":"bool"}}],[11,"clone","","",26,{"inputs":[{"name":"self"}],"output":{"name":"spistate"}}],[11,"fmt","","",26,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",26,{"inputs":[{"name":"self"},{"name":"spistate"}],"output":{"name":"bool"}}],[11,"ne","","",26,{"inputs":[{"name":"self"},{"name":"spistate"}],"output":{"name":"bool"}}],[11,"clone","","",27,{"inputs":[{"name":"self"}],"output":{"name":"alarmstate"}}],[11,"fmt","","",27,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",27,{"inputs":[{"name":"self"},{"name":"alarmstate"}],"output":{"name":"bool"}}],[11,"ne","","",27,{"inputs":[{"name":"self"},{"name":"alarmstate"}],"output":{"name":"bool"}}],[11,"clone","","",28,{"inputs":[{"name":"self"}],"output":{"name":"errorcode"}}],[11,"fmt","","",28,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",28,{"inputs":[{"name":"self"},{"name":"errorcode"}],"output":{"name":"bool"}}],[11,"clone","","",29,{"inputs":[{"name":"self"}],"output":{"name":"sdcardtype"}}],[11,"fmt","","",29,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",29,{"inputs":[{"name":"self"},{"name":"sdcardtype"}],"output":{"name":"bool"}}],[11,"new","","Create a new SD card interface",21,null],[11,"set_spi_slow_mode","","",21,{"inputs":[{"name":"self"}],"output":null}],[11,"set_spi_fast_mode","","",21,{"inputs":[{"name":"self"}],"output":null}],[11,"send_command","","send a command over SPI and collect the response Handles encoding of command, checksum, and padding bytes. The response still needs to be parsed out of the read_buffer when complete",21,null],[11,"read_bytes","","wrapper for easy reading of bytes over SPI",21,null],[11,"write_bytes","","wrapper for easy writing of bytes over SPI",21,null],[11,"get_response","","parse response bytes from SPI read buffer Unfortunately there is a variable amount of delay in SD card responses, so these bytes must be searched for",21,null],[11,"process_spi_states","","updates SD card state on SPI transaction returns",21,null],[11,"process_alarm_states","","updates SD card state upon timer alarm fired",21,{"inputs":[{"name":"self"}],"output":null}],[11,"set_client","","",21,{"inputs":[{"name":"self"},{"name":"c"}],"output":null}],[11,"is_installed","","",21,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_initialized","","",21,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"detect_changes","","watches SD card detect pin for changes, sends callback on change",21,{"inputs":[{"name":"self"}],"output":null}],[11,"initialize","","",21,{"inputs":[{"name":"self"}],"output":{"name":"returncode"}}],[11,"read_blocks","","",21,null],[11,"write_blocks","","",21,null],[11,"read_write_done","","",21,null],[11,"fired","","",21,{"inputs":[{"name":"self"}],"output":null}],[11,"fired","","",21,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[11,"default","","",23,{"inputs":[],"output":{"name":"app"}}],[11,"new","","Create new SD card userland interface",22,null],[11,"card_detection_changed","","",22,{"inputs":[{"name":"self"},{"name":"bool"}],"output":null}],[11,"init_done","","",22,{"inputs":[{"name":"self"},{"name":"u32"},{"name":"u64"}],"output":null}],[11,"read_done","","",22,null],[11,"write_done","","",22,null],[11,"error","","",22,{"inputs":[{"name":"self"},{"name":"u32"}],"output":null}],[11,"allow","","",22,{"inputs":[{"name":"self"},{"name":"appid"},{"name":"usize"},{"name":"appslice"}],"output":{"name":"returncode"}}],[11,"subscribe","","",22,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"callback"}],"output":{"name":"returncode"}}],[11,"command","","",22,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"usize"},{"name":"appid"}],"output":{"name":"returncode"}}],[0,"si7021","capsules","Driver for the Silicon Labs SI7021 temperature/humidity sensor.",null,null],[3,"SI7021","capsules::si7021","",null,null],[12,"i2c","","",31,null],[12,"alarm","","",31,null],[12,"callback","","",31,null],[12,"state","","",31,null],[12,"buffer","","",31,null],[4,"Registers","","",null,null],[13,"MeasRelativeHumidityHoldMode","","",32,null],[13,"MeasRelativeHumidityNoHoldMode","","",32,null],[13,"MeasTemperatureHoldMode","","",32,null],[13,"MeasTemperatureNoHoldMode","","",32,null],[13,"ReadTemperaturePreviousRHMeasurement","","",32,null],[13,"Reset","","",32,null],[13,"WriteRHTUserRegister1","","",32,null],[13,"ReadRHTUserRegister1","","",32,null],[13,"WriteHeaterControlRegister","","",32,null],[13,"ReadHeaterControlRegister","","",32,null],[13,"ReadElectronicIdByteOneA","","",32,null],[13,"ReadElectronicIdByteOneB","","",32,null],[13,"ReadElectronicIdByteTwoA","","",32,null],[13,"ReadElectronicIdByteTwoB","","",32,null],[13,"ReadFirmwareVersionA","","",32,null],[13,"ReadFirmwareVersionB","","",32,null],[4,"State","","States of the I2C protocol with the LPS331AP.",null,null],[13,"Idle","","",33,null],[13,"SelectElectronicId1","","States to read the internal ID",33,null],[13,"ReadElectronicId1","","",33,null],[13,"SelectElectronicId2","","",33,null],[13,"ReadElectronicId2","","",33,null],[13,"TakeMeasurementInit","","States to take the current measurement",33,null],[13,"ReadRhMeasurement","","",33,null],[13,"ReadTempMeasurement","","",33,null],[13,"GotMeasurement","","",33,null],[7,"BUFFER","","",null,null],[11,"clone","","",33,{"inputs":[{"name":"self"}],"output":{"name":"state"}}],[11,"eq","","",33,{"inputs":[{"name":"self"},{"name":"state"}],"output":{"name":"bool"}}],[11,"new","","",31,null],[11,"read_id","","",31,{"inputs":[{"name":"self"}],"output":null}],[11,"take_measurement","","",31,{"inputs":[{"name":"self"}],"output":null}],[11,"command_complete","","",31,null],[11,"fired","","",31,{"inputs":[{"name":"self"}],"output":null}],[11,"subscribe","","",31,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"callback"}],"output":{"name":"returncode"}}],[11,"command","","",31,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"usize"},{"name":"appid"}],"output":{"name":"returncode"}}],[0,"spi","capsules","Provides userspace applications with the ability to communicate over the SPI bus.",null,null],[3,"App","capsules::spi","",null,null],[12,"callback","","",34,null],[12,"app_read","","",34,null],[12,"app_write","","",34,null],[12,"len","","",34,null],[12,"index","","",34,null],[3,"SlaveApp","","",null,null],[12,"callback","","",35,null],[12,"selected_callback","","",35,null],[12,"app_read","","",35,null],[12,"app_write","","",35,null],[12,"len","","",35,null],[12,"index","","",35,null],[3,"Spi","","",null,null],[12,"spi_master","","",36,null],[12,"busy","","",36,null],[12,"app","","",36,null],[12,"kernel_read","","",36,null],[12,"kernel_write","","",36,null],[12,"kernel_len","","",36,null],[3,"SpiSlave","","",null,null],[12,"spi_slave","","",37,null],[12,"busy","","",37,null],[12,"app","","",37,null],[12,"kernel_read","","",37,null],[12,"kernel_write","","",37,null],[12,"kernel_len","","",37,null],[11,"default","","",34,{"inputs":[],"output":{"name":"app"}}],[11,"default","","",35,{"inputs":[],"output":{"name":"slaveapp"}}],[11,"new","","",36,{"inputs":[{"name":"s"}],"output":{"name":"spi"}}],[11,"config_buffers","","",36,null],[11,"do_next_read_write","","",36,{"inputs":[{"name":"self"},{"name":"app"}],"output":null}],[11,"allow","","",36,{"inputs":[{"name":"self"},{"name":"appid"},{"name":"usize"},{"name":"appslice"}],"output":{"name":"returncode"}}],[11,"subscribe","","",36,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"callback"}],"output":{"name":"returncode"}}],[11,"command","","",36,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"usize"},{"name":"appid"}],"output":{"name":"returncode"}}],[11,"read_write_done","","",36,null],[11,"new","","",37,{"inputs":[{"name":"s"}],"output":{"name":"spislave"}}],[11,"config_buffers","","",37,null],[11,"do_next_read_write","","",37,{"inputs":[{"name":"self"},{"name":"slaveapp"}],"output":null}],[11,"allow","","Provide read/write buffers to SpiSlave",37,{"inputs":[{"name":"self"},{"name":"appid"},{"name":"usize"},{"name":"appslice"}],"output":{"name":"returncode"}}],[11,"subscribe","","Setup callbacks for SpiSlave",37,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"callback"}],"output":{"name":"returncode"}}],[11,"command","","0: check if present 1: read/write buffers   - read and write buffers optional   - fails if arg1 (bytes to write) >     write_buffer.len() 2: get chip select   - returns current selected peripheral   - in slave mode, always returns 0 3: set clock phase on current peripheral   - 0 is sample leading   - non-zero is sample trailing 4: get clock phase on current peripheral   - 0 is sample leading   - non-zero is sample trailing 5: set clock polarity on current peripheral   - 0 is idle low   - non-zero is idle high 6: get clock polarity on current peripheral   - 0 is idle low   - non-zero is idle high",37,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"usize"},{"name":"appid"}],"output":{"name":"returncode"}}],[11,"read_write_done","","",37,{"inputs":[{"name":"self"},{"name":"option"},{"name":"option"},{"name":"usize"}],"output":null}],[11,"chip_selected","","",37,{"inputs":[{"name":"self"}],"output":null}],[0,"virtual_alarm","capsules","Virtualize the Alarm interface to enable multiple users of an underlying alarm hardware peripheral.",null,null],[3,"VirtualMuxAlarm","capsules::virtual_alarm","",null,null],[12,"mux","","",38,null],[12,"when","","",38,null],[12,"armed","","",38,null],[12,"next","","",38,null],[12,"client","","",38,null],[3,"MuxAlarm","","",null,null],[12,"virtual_alarms","","",39,null],[12,"enabled","","",39,null],[12,"prev","","",39,null],[12,"alarm","","",39,null],[5,"past_from_base","","",null,{"inputs":[{"name":"u32"},{"name":"u32"},{"name":"u32"}],"output":{"name":"bool"}}],[11,"next","","",38,{"inputs":[{"name":"self"}],"output":{"name":"listlink"}}],[11,"new","","",38,{"inputs":[{"name":"muxalarm"}],"output":{"name":"virtualmuxalarm"}}],[11,"set_client","","",38,{"inputs":[{"name":"self"},{"name":"client"}],"output":null}],[11,"disable","","",38,{"inputs":[{"name":"self"}],"output":null}],[11,"is_armed","","",38,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"now","","",38,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"set_alarm","","",38,{"inputs":[{"name":"self"},{"name":"u32"}],"output":null}],[11,"get_alarm","","",38,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"fired","","",38,{"inputs":[{"name":"self"}],"output":null}],[11,"new","","",39,{"inputs":[{"name":"alrm"}],"output":{"name":"muxalarm"}}],[11,"fired","","",39,{"inputs":[{"name":"self"}],"output":null}],[0,"virtual_flash","capsules","Virtualize writing flash.",null,null],[3,"MuxFlash","capsules::virtual_flash","Handle keeping a list of active users of flash hardware and serialize their requests. After each completed request the list is checked to see if there is another flash user with an outstanding read, write, or erase request.",null,null],[12,"flash","","",40,null],[12,"users","","",40,null],[12,"inflight","","",40,null],[3,"FlashUser","","Keep state for each flash user. All uses of the virtualized flash interface need to create one of these to be a user of the flash. The `new()` function handles most of the work, a user only has to pass in a reference to the MuxFlash object.",null,null],[12,"mux","","",41,null],[12,"buffer","","",41,null],[12,"operation","","",41,null],[12,"next","","",41,null],[12,"client","","",41,null],[4,"Op","","",null,null],[13,"Idle","","",42,null],[13,"Write","","",42,null],[13,"Read","","",42,null],[13,"Erase","","",42,null],[11,"read_complete","","",40,null],[11,"write_complete","","",40,null],[11,"erase_complete","","",40,{"inputs":[{"name":"self"},{"name":"error"}],"output":null}],[11,"new","","",40,{"inputs":[{"name":"f"}],"output":{"name":"muxflash"}}],[11,"do_next_op","","Scan the list of users and find the first user that has a pending request, then issue that request to the flash hardware.",40,{"inputs":[{"name":"self"}],"output":null}],[11,"clone","","",42,{"inputs":[{"name":"self"}],"output":{"name":"op"}}],[11,"eq","","",42,{"inputs":[{"name":"self"},{"name":"op"}],"output":{"name":"bool"}}],[11,"ne","","",42,{"inputs":[{"name":"self"},{"name":"op"}],"output":{"name":"bool"}}],[11,"new","","",41,{"inputs":[{"name":"muxflash"}],"output":{"name":"flashuser"}}],[11,"set_client","","",41,{"inputs":[{"name":"self"},{"name":"c"}],"output":null}],[11,"read_complete","","",41,null],[11,"write_complete","","",41,null],[11,"erase_complete","","",41,{"inputs":[{"name":"self"},{"name":"error"}],"output":null}],[11,"next","","",41,{"inputs":[{"name":"self"}],"output":{"name":"listlink"}}],[11,"read_page","","",41,null],[11,"write_page","","",41,null],[11,"erase_page","","",41,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"returncode"}}],[0,"virtual_i2c","capsules","Virtualize an I2C master bus.",null,null],[3,"MuxI2C","capsules::virtual_i2c","",null,null],[12,"i2c","","",43,null],[12,"devices","","",43,null],[12,"enabled","","",43,null],[12,"inflight","","",43,null],[3,"I2CDevice","","",null,null],[12,"mux","","",44,null],[12,"addr","","",44,null],[12,"enabled","","",44,null],[12,"buffer","","",44,null],[12,"operation","","",44,null],[12,"next","","",44,null],[12,"client","","",44,null],[4,"Op","","",null,null],[13,"Idle","","",45,null],[13,"Write","","",45,null],[13,"Read","","",45,null],[13,"WriteRead","","",45,null],[11,"command_complete","","",43,null],[11,"new","","",43,{"inputs":[{"name":"i2cmaster"}],"output":{"name":"muxi2c"}}],[11,"enable","","",43,{"inputs":[{"name":"self"}],"output":null}],[11,"disable","","",43,{"inputs":[{"name":"self"}],"output":null}],[11,"do_next_op","","",43,{"inputs":[{"name":"self"}],"output":null}],[11,"clone","","",45,{"inputs":[{"name":"self"}],"output":{"name":"op"}}],[11,"eq","","",45,{"inputs":[{"name":"self"},{"name":"op"}],"output":{"name":"bool"}}],[11,"ne","","",45,{"inputs":[{"name":"self"},{"name":"op"}],"output":{"name":"bool"}}],[11,"new","","",44,{"inputs":[{"name":"muxi2c"},{"name":"u8"}],"output":{"name":"i2cdevice"}}],[11,"set_client","","",44,{"inputs":[{"name":"self"},{"name":"i2cclient"}],"output":null}],[11,"command_complete","","",44,null],[11,"next","","",44,{"inputs":[{"name":"self"}],"output":{"name":"listlink"}}],[11,"enable","","",44,{"inputs":[{"name":"self"}],"output":null}],[11,"disable","","",44,{"inputs":[{"name":"self"}],"output":null}],[11,"write_read","","",44,null],[11,"write","","",44,null],[11,"read","","",44,null],[0,"virtual_spi","capsules","Virtualize a SPI master bus to enable multiple users of the SPI bus.",null,null],[3,"MuxSpiMaster","capsules::virtual_spi","The Mux struct manages multiple Spi clients. Each client may have at most one outstanding Spi request.",null,null],[12,"spi","","",46,null],[12,"devices","","",46,null],[12,"inflight","","",46,null],[3,"VirtualSpiMasterDevice","","",null,null],[12,"mux","","",47,null],[12,"chip_select","","",47,null],[12,"txbuffer","","",47,null],[12,"rxbuffer","","",47,null],[12,"operation","","",47,null],[12,"next","","",47,null],[12,"client","","",47,null],[3,"VirtualSpiSlaveDevice","","",null,null],[12,"spi","","",48,null],[12,"client","","",48,null],[4,"Op","","",null,null],[13,"Idle","","",49,null],[13,"Configure","","",49,null],[13,"ReadWriteBytes","","",49,null],[13,"SetPolarity","","",49,null],[13,"SetPhase","","",49,null],[13,"SetRate","","",49,null],[11,"read_write_done","","",46,null],[11,"new","","",46,{"inputs":[{"name":"spi"}],"output":{"name":"muxspimaster"}}],[11,"do_next_op","","",46,{"inputs":[{"name":"self"}],"output":null}],[11,"clone","","",49,{"inputs":[{"name":"self"}],"output":{"name":"op"}}],[11,"eq","","",49,{"inputs":[{"name":"self"},{"name":"op"}],"output":{"name":"bool"}}],[11,"ne","","",49,{"inputs":[{"name":"self"},{"name":"op"}],"output":{"name":"bool"}}],[11,"new","","",47,null],[11,"set_client","","",47,{"inputs":[{"name":"self"},{"name":"spimasterclient"}],"output":null}],[11,"read_write_done","","",47,null],[11,"next","","",47,{"inputs":[{"name":"self"}],"output":{"name":"listlink"}}],[11,"configure","","",47,{"inputs":[{"name":"self"},{"name":"clockpolarity"},{"name":"clockphase"},{"name":"u32"}],"output":null}],[11,"read_write_bytes","","",47,null],[11,"set_polarity","","",47,{"inputs":[{"name":"self"},{"name":"clockpolarity"}],"output":null}],[11,"set_phase","","",47,{"inputs":[{"name":"self"},{"name":"clockphase"}],"output":null}],[11,"set_rate","","",47,{"inputs":[{"name":"self"},{"name":"u32"}],"output":null}],[11,"get_polarity","","",47,{"inputs":[{"name":"self"}],"output":{"name":"clockpolarity"}}],[11,"get_phase","","",47,{"inputs":[{"name":"self"}],"output":{"name":"clockphase"}}],[11,"get_rate","","",47,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"new","","",48,{"inputs":[{"name":"spi"}],"output":{"name":"virtualspislavedevice"}}],[11,"set_client","","",48,{"inputs":[{"name":"self"},{"name":"spislaveclient"}],"output":null}],[11,"read_write_done","","",48,{"inputs":[{"name":"self"},{"name":"option"},{"name":"option"},{"name":"usize"}],"output":null}],[11,"chip_selected","","",48,{"inputs":[{"name":"self"}],"output":null}],[11,"configure","","",48,{"inputs":[{"name":"self"},{"name":"clockpolarity"},{"name":"clockphase"}],"output":null}],[11,"read_write_bytes","","",48,{"inputs":[{"name":"self"},{"name":"option"},{"name":"option"},{"name":"usize"}],"output":{"name":"returncode"}}],[11,"set_polarity","","",48,{"inputs":[{"name":"self"},{"name":"clockpolarity"}],"output":null}],[11,"set_phase","","",48,{"inputs":[{"name":"self"},{"name":"clockphase"}],"output":null}],[11,"get_polarity","","",48,{"inputs":[{"name":"self"}],"output":{"name":"clockpolarity"}}],[11,"get_phase","","",48,{"inputs":[{"name":"self"}],"output":{"name":"clockphase"}}],[0,"adc","capsules","Provides userspace applications with the ability to sample analog signals.",null,null],[3,"Adc","capsules::adc","ADC application driver, used by applications to interact with ADC. Not currently virtualized, only one application can use it at a time.",null,null],[12,"adc","","",50,null],[12,"channels","","",50,null],[12,"active","","",50,null],[12,"mode","","",50,null],[12,"app","","",50,null],[12,"channel","","",50,null],[12,"callback","","",50,null],[12,"app_buf_offset","","",50,null],[12,"samples_remaining","","",50,null],[12,"samples_outstanding","","",50,null],[12,"next_samples_outstanding","","",50,null],[12,"using_app_buf1","","",50,null],[12,"adc_buf1","","",50,null],[12,"adc_buf2","","",50,null],[12,"adc_buf3","","",50,null],[3,"App","","Holds buffers that the application has passed us",null,null],[12,"app_buf1","","",51,null],[12,"app_buf2","","",51,null],[4,"AdcMode","","ADC modes, used to track internal state and to signify to applications which state a callback came from",null,null],[13,"NoMode","","",52,null],[13,"SingleSample","","",52,null],[13,"ContinuousSample","","",52,null],[13,"SingleBuffer","","",52,null],[13,"ContinuousBuffer","","",52,null],[7,"ADC_BUFFER1","","Buffers to use for DMA transfers The size is chosen somewhat arbitrarily, but has been tested. At 175000 Hz, buffers need to be swapped every 70 us and copied over before the next swap. In testing, it seems to keep up fine.",null,null],[7,"ADC_BUFFER2","","",null,null],[7,"ADC_BUFFER3","","",null,null],[11,"clone","","",52,{"inputs":[{"name":"self"}],"output":{"name":"adcmode"}}],[11,"fmt","","",52,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",52,{"inputs":[{"name":"self"},{"name":"adcmode"}],"output":{"name":"bool"}}],[11,"default","","",51,{"inputs":[],"output":{"name":"app"}}],[11,"new","","Create a new Adc application interface",50,null],[11,"initialize","","Initialize the ADC This can be called harmlessly if the ADC has already been initialized",50,{"inputs":[{"name":"self"}],"output":{"name":"returncode"}}],[11,"replace_buffer","","Store a buffer we've regained ownership of and return a handle to it The handle can have `map` called on it in order to process the data in the buffer",50,null],[11,"take_and_map_buffer","","Find a buffer to give to the ADC to store samples in",50,{"inputs":[{"name":"self"},{"name":"f"}],"output":null}],[11,"sample","","Collect a single analog sample on a channel",50,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"returncode"}}],[11,"sample_continuous","","Collected repeated single analog samples on a channel",50,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"u32"}],"output":{"name":"returncode"}}],[11,"sample_buffer","","Collect a buffer-full of analog samples Samples are collected into the first app buffer provided. The number of samples collected is equal to the size of the buffer \"allowed\"",50,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"u32"}],"output":{"name":"returncode"}}],[11,"sample_buffer_continuous","","Collect analog samples continuously Fills one \"allowed\" application buffer at a time and then swaps to filling the second buffer. Callbacks occur when the in use \"allowed\" buffer fills",50,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"u32"}],"output":{"name":"returncode"}}],[11,"stop_sampling","","Stops sampling the ADC Any active operation by the ADC is canceled. No additional callbacks will occur. Also retrieves buffers from the ADC (if any)",50,{"inputs":[{"name":"self"}],"output":{"name":"returncode"}}],[11,"sample_ready","","Single sample operation complete Collects the sample and provides a callback to the application",50,{"inputs":[{"name":"self"},{"name":"u16"}],"output":null}],[11,"samples_ready","","Internal buffer has filled from a buffered sampling operation. Copies data over to application buffer, determines if more data is needed, and performs a callback to the application if ready. If continuously sampling, also swaps application buffers and continues sampling when neccessary. If only filling a single buffer, stops sampling operation when the application buffer is full.",50,null],[11,"allow","","Provides access to a buffer from the application to store data in or read data from",50,{"inputs":[{"name":"self"},{"name":"appid"},{"name":"usize"},{"name":"appslice"}],"output":{"name":"returncode"}}],[11,"subscribe","","Provides a callback which can be used to signal the application",50,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"callback"}],"output":{"name":"returncode"}}],[11,"command","","Method for the application to command or query this driver",50,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"usize"},{"name":"appid"}],"output":{"name":"returncode"}}],[0,"dac","capsules","Provides a DAC interface for userspace.",null,null],[3,"Dac","capsules::dac","",null,null],[12,"dac","","",53,null],[11,"new","","",53,{"inputs":[{"name":"dacchannel"}],"output":{"name":"dac"}}],[11,"command","","Control the DAC.",53,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"usize"},{"name":"appid"}],"output":{"name":"returncode"}}],[0,"i2c_master_slave_driver","capsules","Provides both an I2C Master and I2C Slave interface to userspace.",null,null],[3,"App","capsules::i2c_master_slave_driver","",null,null],[12,"callback","","",54,null],[12,"master_tx_buffer","","",54,null],[12,"master_rx_buffer","","",54,null],[12,"slave_tx_buffer","","",54,null],[12,"slave_rx_buffer","","",54,null],[3,"I2CMasterSlaveDriver","","",null,null],[12,"i2c","","",55,null],[12,"listening","","",55,null],[12,"master_action","","",55,null],[12,"master_buffer","","",55,null],[12,"slave_buffer1","","",55,null],[12,"slave_buffer2","","",55,null],[12,"app","","",55,null],[4,"MasterAction","","",null,null],[13,"Read","","",56,null],[13,"Write","","",56,null],[7,"BUFFER1","","",null,null],[7,"BUFFER2","","",null,null],[7,"BUFFER3","","",null,null],[11,"default","","",54,{"inputs":[],"output":{"name":"app"}}],[11,"clone","","",56,{"inputs":[{"name":"self"}],"output":{"name":"masteraction"}}],[11,"eq","","",56,{"inputs":[{"name":"self"},{"name":"masteraction"}],"output":{"name":"bool"}}],[11,"ne","","",56,{"inputs":[{"name":"self"},{"name":"masteraction"}],"output":{"name":"bool"}}],[11,"new","","",55,null],[11,"command_complete","","",55,null],[11,"command_complete","","",55,null],[11,"read_expected","","",55,{"inputs":[{"name":"self"}],"output":null}],[11,"write_expected","","",55,{"inputs":[{"name":"self"}],"output":null}],[11,"allow","","",55,{"inputs":[{"name":"self"},{"name":"appid"},{"name":"usize"},{"name":"appslice"}],"output":{"name":"returncode"}}],[11,"subscribe","","",55,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"callback"}],"output":{"name":"returncode"}}],[11,"command","","",55,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"usize"},{"name":"appid"}],"output":{"name":"returncode"}}],[0,"lps25hb","capsules","Driver for the ST LPS25HB pressure sensor.",null,null],[3,"LPS25HB","capsules::lps25hb","",null,null],[12,"i2c","","",57,null],[12,"interrupt_pin","","",57,null],[12,"callback","","",57,null],[12,"state","","",57,null],[12,"buffer","","",57,null],[4,"Registers","","",null,null],[13,"RefPXl","","",58,null],[13,"RefPL","","",58,null],[13,"RefPH","","",58,null],[13,"WhoAmI","","",58,null],[13,"ResConf","","",58,null],[13,"CtrlReg1","","",58,null],[13,"CtrlReg2","","",58,null],[13,"CtrlReg3","","",58,null],[13,"CtrlReg4","","",58,null],[13,"IntCfgReg","","",58,null],[13,"IntSourceReg","","",58,null],[13,"StatusReg","","",58,null],[13,"PressOutXl","","",58,null],[13,"PressOutL","","",58,null],[13,"PressOutH","","",58,null],[13,"TempOutL","","",58,null],[13,"TempOutH","","",58,null],[13,"FifoCtrl","","",58,null],[13,"FifoStatus","","",58,null],[13,"ThsPL","","",58,null],[13,"ThsPH","","",58,null],[13,"RpdsL","","",58,null],[13,"RpdsH","","",58,null],[4,"State","","States of the I2C protocol with the LPS25HB.",null,null],[13,"Idle","","",59,null],[13,"SelectWhoAmI","","Read the WHO_AM_I register. This should return 0xBB.",59,null],[13,"ReadingWhoAmI","","",59,null],[13,"TakeMeasurementInit","","Process of taking a pressure measurement. Start with chip powered off",59,null],[13,"TakeMeasurementClear","","Then clear the current reading (just in case it exists) to reset the interrupt line.",59,null],[13,"TakeMeasurementConfigure","","Enable a single shot measurement with interrupt when data is ready.",59,null],[13,"ReadMeasurement","","Read the 3 pressure registers.",59,null],[13,"GotMeasurement","","Calculate pressure and call the callback with the value.",59,null],[13,"Done","","Disable I2C and release buffer",59,null],[7,"BUFFER","","",null,null],[17,"REGISTER_AUTO_INCREMENT","","Register values",null,null],[17,"CTRL_REG1_POWER_ON","","",null,null],[17,"CTRL_REG1_BLOCK_DATA_ENABLE","","",null,null],[17,"CTRL_REG2_ONE_SHOT","","",null,null],[17,"CTRL_REG4_INTERRUPT1_DATAREADY","","",null,null],[11,"clone","","",59,{"inputs":[{"name":"self"}],"output":{"name":"state"}}],[11,"eq","","",59,{"inputs":[{"name":"self"},{"name":"state"}],"output":{"name":"bool"}}],[11,"new","","",57,null],[11,"read_whoami","","",57,{"inputs":[{"name":"self"}],"output":null}],[11,"take_measurement","","",57,{"inputs":[{"name":"self"}],"output":null}],[11,"command_complete","","",57,null],[11,"fired","","",57,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[11,"subscribe","","",57,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"callback"}],"output":{"name":"returncode"}}],[11,"command","","",57,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"usize"},{"name":"appid"}],"output":{"name":"returncode"}}],[0,"tsl2561","capsules","Driver for the Taos TSL2561 light sensor.",null,null],[3,"TSL2561","capsules::tsl2561","",null,null],[12,"i2c","","",60,null],[12,"interrupt_pin","","",60,null],[12,"callback","","",60,null],[12,"state","","",60,null],[12,"buffer","","",60,null],[4,"Registers","","",null,null],[13,"Control","","",61,null],[13,"Timing","","",61,null],[13,"ThresholdLowLow","","",61,null],[13,"ThresholdLowHigh","","",61,null],[13,"ThresholdHighLow","","",61,null],[13,"ThresholdHighHigh","","",61,null],[13,"Interrupt","","",61,null],[13,"Id","","",61,null],[13,"Data0Low","","",61,null],[13,"Data0High","","",61,null],[13,"Data1Low","","",61,null],[13,"Data1High","","",61,null],[4,"State","","",null,null],[13,"Idle","","",62,null],[13,"SelectId","","Read the Id register.",62,null],[13,"ReadingId","","",62,null],[13,"TakeMeasurementTurnOn","","Process of taking a light measurement.",62,null],[13,"TakeMeasurementConfigMeasurement","","",62,null],[13,"TakeMeasurementReset1","","",62,null],[13,"TakeMeasurementReset2","","",62,null],[13,"ReadMeasurement1","","Read the ADC registers.",62,null],[13,"ReadMeasurement2","","",62,null],[13,"ReadMeasurement3","","",62,null],[13,"GotMeasurement","","Calculate light and call the callback with the value.",62,null],[13,"Done","","Disable I2C and release buffer",62,null],[7,"BUFFER","","",null,null],[17,"COMMAND_REG","","Command register defines",null,null],[17,"WORD_PROTOCOL","","",null,null],[17,"POWER_ON","","Control_Reg defines",null,null],[17,"POWER_OFF","","",null,null],[17,"INTEGRATE_TIME_101_MS","","Timing_Reg defines",null,null],[17,"LOW_GAIN_MODE","","",null,null],[17,"INTERRUPT_CONTROL_LEVEL","","",null,null],[17,"INTERRUPT_ON_ADC_DONE","","",null,null],[17,"LUX_SCALE","","",null,null],[17,"RATIO_SCALE","","",null,null],[17,"CH_SCALE","","",null,null],[17,"CHSCALE_TINT0","","",null,null],[17,"CHSCALE_TINT1","","",null,null],[17,"K1T","","",null,null],[17,"B1T","","",null,null],[17,"M1T","","",null,null],[17,"K2T","","",null,null],[17,"B2T","","",null,null],[17,"M2T","","",null,null],[17,"K3T","","",null,null],[17,"B3T","","",null,null],[17,"M3T","","",null,null],[17,"K4T","","",null,null],[17,"B4T","","",null,null],[17,"M4T","","",null,null],[17,"K5T","","",null,null],[17,"B5T","","",null,null],[17,"M5T","","",null,null],[17,"K6T","","",null,null],[17,"B6T","","",null,null],[17,"M6T","","",null,null],[17,"K7T","","",null,null],[17,"B7T","","",null,null],[17,"M7T","","",null,null],[17,"K8T","","",null,null],[17,"B8T","","",null,null],[17,"M8T","","",null,null],[11,"clone","","",62,{"inputs":[{"name":"self"}],"output":{"name":"state"}}],[11,"eq","","",62,{"inputs":[{"name":"self"},{"name":"state"}],"output":{"name":"bool"}}],[11,"new","","",60,null],[11,"read_id","","",60,{"inputs":[{"name":"self"}],"output":null}],[11,"take_measurement","","",60,{"inputs":[{"name":"self"}],"output":null}],[11,"calculate_lux","","",60,{"inputs":[{"name":"self"},{"name":"u16"},{"name":"u16"}],"output":{"name":"usize"}}],[11,"command_complete","","",60,null],[11,"fired","","",60,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[11,"subscribe","","",60,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"callback"}],"output":{"name":"returncode"}}],[11,"command","","",60,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"usize"},{"name":"appid"}],"output":{"name":"returncode"}}],[0,"fxos8700cq","capsules","Driver for the FXOS8700CQ accelerometer.",null,null],[3,"Fxos8700cq","capsules::fxos8700cq","",null,null],[12,"i2c","","",63,null],[12,"interrupt_pin1","","",63,null],[12,"state","","",63,null],[12,"buffer","","",63,null],[12,"callback","","",63,null],[4,"Registers","","",null,null],[13,"Status","","",64,null],[13,"OutXMsb","","",64,null],[13,"OutXLsb","","",64,null],[13,"OutYMsb","","",64,null],[13,"OutYLsb","","",64,null],[13,"OutZMsb","","",64,null],[13,"OutZLsb","","",64,null],[13,"FSetup","","",64,null],[13,"TrigCfg","","",64,null],[13,"Sysmod","","",64,null],[13,"IntSource","","",64,null],[13,"WhoAmI","","",64,null],[13,"XyzDataCfg","","",64,null],[13,"HpFilterCutoff","","",64,null],[13,"PlStatus","","",64,null],[13,"PlCfg","","",64,null],[13,"PlCount","","",64,null],[13,"PlBfZcomp","","",64,null],[13,"PlThsReg","","",64,null],[13,"AFfmtCfg","","",64,null],[13,"AFfmtSrc","","",64,null],[13,"AFfmtThs","","",64,null],[13,"AFfmtCount","","",64,null],[13,"TransientCfg","","",64,null],[13,"TransientSrc","","",64,null],[13,"TransientThs","","",64,null],[13,"TransientCount","","",64,null],[13,"PulseCfg","","",64,null],[13,"PulseSrc","","",64,null],[13,"PulseThsx","","",64,null],[13,"PulseThsy","","",64,null],[13,"PulseThsz","","",64,null],[13,"PulseTmlt","","",64,null],[13,"PulseLtcy","","",64,null],[13,"PulseWind","","",64,null],[13,"AslpCount","","",64,null],[13,"CtrlReg1","","",64,null],[13,"CtrlReg2","","",64,null],[13,"CtrlReg3","","",64,null],[13,"CtrlReg4","","",64,null],[13,"CtrlReg5","","",64,null],[13,"OffX","","",64,null],[13,"OffY","","",64,null],[13,"OffZ","","",64,null],[13,"MDrStatus","","",64,null],[13,"MOutXMsb","","",64,null],[13,"MOutXLsb","","",64,null],[13,"MOutYMsb","","",64,null],[13,"MOutYLsb","","",64,null],[13,"MOutZMsb","","",64,null],[13,"MOutZLsb","","",64,null],[13,"CmpXMsb","","",64,null],[13,"CmpXLsb","","",64,null],[13,"CmpYMsb","","",64,null],[13,"CmpYLsb","","",64,null],[13,"CmpZMsb","","",64,null],[13,"CmpZLsb","","",64,null],[13,"MOffXMsb","","",64,null],[13,"MOffXLsb","","",64,null],[13,"MOffYMsb","","",64,null],[13,"MOffYLsb","","",64,null],[13,"MOffZMsb","","",64,null],[13,"MOffZLsb","","",64,null],[13,"MaxXMsb","","",64,null],[13,"MaxXLsb","","",64,null],[13,"MaxYMsb","","",64,null],[13,"MaxYLsb","","",64,null],[13,"MaxZMsb","","",64,null],[13,"MaxZLsb","","",64,null],[13,"MinXMsb","","",64,null],[13,"MinXLsb","","",64,null],[13,"MinYMsb","","",64,null],[13,"MinYLsb","","",64,null],[13,"MinZMsb","","",64,null],[13,"MinZLsb","","",64,null],[13,"Temp","","",64,null],[13,"MThsCfg","","",64,null],[13,"MThsSrc","","",64,null],[13,"MThsXMsb","","",64,null],[13,"MThsXLsb","","",64,null],[13,"MThsYMsb","","",64,null],[13,"MThsYLsb","","",64,null],[13,"MThsZMsb","","",64,null],[13,"MThsZLsb","","",64,null],[13,"MThsCount","","",64,null],[13,"MCtrlReg1","","",64,null],[13,"MCtrlReg2","","",64,null],[13,"MCtrlReg3","","",64,null],[13,"MIntSrc","","",64,null],[13,"AVecmCfg","","",64,null],[13,"AVecmThsMsb","","",64,null],[13,"AVecmThsLsb","","",64,null],[13,"AVecmCnt","","",64,null],[13,"AVecmInitxMsb","","",64,null],[13,"AVecmInitxLsb","","",64,null],[13,"AVecmInityMsb","","",64,null],[13,"AVecmInityLsb","","",64,null],[13,"AVecmInitzMsb","","",64,null],[13,"AVecmInitzLsb","","",64,null],[13,"MVecmCfg","","",64,null],[13,"MVecmThsMsb","","",64,null],[13,"MVecmThsLsb","","",64,null],[13,"MVecmCnt","","",64,null],[13,"MVecmInitxMsb","","",64,null],[13,"MVecmInitxLsb","","",64,null],[13,"MVecmInityMsb","","",64,null],[13,"MVecmInityLsb","","",64,null],[13,"MVecmInitzMsb","","",64,null],[13,"MVecmInitzLsb","","",64,null],[13,"AFfmtThsXMsb","","",64,null],[13,"AFfmtThsXLsb","","",64,null],[13,"AFfmtThsYMsb","","",64,null],[13,"AFfmtThsYLsb","","",64,null],[13,"AFfmtThsZMsb","","",64,null],[13,"AFfmtThsZLsb","","",64,null],[4,"State","","",null,null],[13,"Disabled","","Sensor is in standby mode",65,null],[13,"ReadAccelSetup","","Activate the accelerometer to take a reading",65,null],[13,"ReadAccelWait","","Wait for the acceleration sample to be ready",65,null],[13,"ReadAccelWaiting","","Activate sensor to take readings",65,null],[13,"ReadAccelReading","","Reading accelerometer data",65,null],[13,"ReadAccelDeactivating","","Deactivate sensor",65,null],[13,"ReadMagStart","","Configuring reading the magnetometer",65,null],[13,"ReadMagValues","","Have the magnetometer values and sending them to application",65,null],[7,"BUF","","",null,null],[11,"clone","","",65,{"inputs":[{"name":"self"}],"output":{"name":"state"}}],[11,"eq","","",65,{"inputs":[{"name":"self"},{"name":"state"}],"output":{"name":"bool"}}],[11,"ne","","",65,{"inputs":[{"name":"self"},{"name":"state"}],"output":{"name":"bool"}}],[11,"new","","",63,null],[11,"start_read_accel","","",63,{"inputs":[{"name":"self"}],"output":null}],[11,"start_read_magnetometer","","",63,{"inputs":[{"name":"self"}],"output":null}],[11,"fired","","",63,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[11,"command_complete","","",63,null],[11,"set_client","","",63,{"inputs":[{"name":"self"},{"name":"ninedofclient"}],"output":null}],[11,"read_accelerometer","","",63,{"inputs":[{"name":"self"}],"output":{"name":"returncode"}}],[11,"read_magnetometer","","",63,{"inputs":[{"name":"self"}],"output":{"name":"returncode"}}],[0,"crc","capsules","Provides userspace access to a CRC unit.",null,null],[3,"App","capsules::crc","An opaque value maintaining state for one application's request",null,null],[12,"callback","","",66,null],[12,"buffer","","",66,null],[12,"waiting","","",66,null],[3,"Crc","","Struct that holds the state of the CRC driver and implements the `Driver` trait for use by processes through the system call interface.",null,null],[12,"crc_unit","","",67,null],[12,"apps","","",67,null],[12,"serving_app","","",67,null],[5,"alg_from_user_int","","",null,{"inputs":[{"name":"usize"}],"output":{"name":"option"}}],[11,"default","","",66,{"inputs":[],"output":{"name":"app"}}],[11,"new","","Create a `Crc` driver",67,{"inputs":[{"name":"c"},{"name":"container"}],"output":{"name":"crc"}}],[11,"serve_waiting_apps","","",67,{"inputs":[{"name":"self"}],"output":null}],[11,"allow","","The `allow` syscall for this driver supports the single `allow_num` zero, which is used to provide a buffer over which to compute a CRC computation.",67,{"inputs":[{"name":"self"},{"name":"appid"},{"name":"usize"},{"name":"appslice"}],"output":{"name":"returncode"}}],[11,"subscribe","","The `subscribe` syscall supports the single `subscribe_number` zero, which is used to provide a callback that will receive the result of a CRC computation.  The signature of the callback is",67,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"callback"}],"output":{"name":"returncode"}}],[11,"command","","The command system call for this driver return meta-data about the driver and kicks off CRC computations returned through callbacks.",67,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"usize"},{"name":"appid"}],"output":{"name":"returncode"}}],[11,"receive_result","","",67,{"inputs":[{"name":"self"},{"name":"u32"}],"output":null}],[0,"rf233","capsules","Driver for sending 802.15.4 packets with an Atmel RF233.",null,null],[3,"RF233","capsules::rf233","",null,null],[12,"spi","","",68,null],[12,"radio_on","","",68,null],[12,"transmitting","","",68,null],[12,"receiving","","",68,null],[12,"spi_busy","","",68,null],[12,"interrupt_handling","","",68,null],[12,"interrupt_pending","","",68,null],[12,"config_pending","","",68,null],[12,"reset_pin","","",68,null],[12,"sleep_pin","","",68,null],[12,"irq_pin","","",68,null],[12,"irq_ctl","","",68,null],[12,"state","","",68,null],[12,"tx_buf","","",68,null],[12,"rx_buf","","",68,null],[12,"tx_len","","",68,null],[12,"tx_client","","",68,null],[12,"rx_client","","",68,null],[12,"cfg_client","","",68,null],[12,"power_client","","",68,null],[12,"addr","","",68,null],[12,"addr_long","","",68,null],[12,"pan","","",68,null],[12,"tx_power","","",68,null],[12,"channel","","",68,null],[12,"seq","","",68,null],[12,"spi_rx","","",68,null],[12,"spi_tx","","",68,null],[12,"spi_buf","","",68,null],[4,"InternalState","","",null,null],[13,"START","","",69,null],[13,"START_PART_READ","","",69,null],[13,"START_STATUS_READ","","",69,null],[13,"START_TURNING_OFF","","",69,null],[13,"START_CTRL1_SET","","",69,null],[13,"START_CCA_SET","","",69,null],[13,"START_PWR_SET","","",69,null],[13,"START_CTRL2_SET","","",69,null],[13,"START_IRQMASK_SET","","",69,null],[13,"START_XAH1_SET","","",69,null],[13,"START_XAH0_SET","","",69,null],[13,"START_PANID0_SET","","",69,null],[13,"START_PANID1_SET","","",69,null],[13,"START_IEEE0_SET","","",69,null],[13,"START_IEEE1_SET","","",69,null],[13,"START_IEEE2_SET","","",69,null],[13,"START_IEEE3_SET","","",69,null],[13,"START_IEEE4_SET","","",69,null],[13,"START_IEEE5_SET","","",69,null],[13,"START_IEEE6_SET","","",69,null],[13,"START_IEEE7_SET","","",69,null],[13,"START_SHORT0_SET","","",69,null],[13,"START_SHORT1_SET","","",69,null],[13,"START_CSMA_SEEDED","","",69,null],[13,"START_RPC_SET","","",69,null],[13,"ON_STATUS_READ","","",69,null],[13,"ON_PLL_WAITING","","",69,null],[13,"ON_PLL_SET","","",69,null],[13,"READY","","",69,null],[13,"TX_STATUS_PRECHECK1","","",69,null],[13,"TX_WRITING_FRAME","","",69,null],[13,"TX_WRITING_FRAME_DONE","","",69,null],[13,"TX_STATUS_PRECHECK2","","",69,null],[13,"TX_PLL_START","","",69,null],[13,"TX_PLL_WAIT","","",69,null],[13,"TX_ARET_ON","","",69,null],[13,"TX_TRANSMITTING","","",69,null],[13,"TX_READ_ACK","","",69,null],[13,"TX_DONE","","",69,null],[13,"TX_RETURN_TO_RX","","",69,null],[13,"TX_PENDING","","",69,null],[13,"CONFIG_SHORT0_SET","","",69,null],[13,"CONFIG_SHORT1_SET","","",69,null],[13,"CONFIG_PAN0_SET","","",69,null],[13,"CONFIG_PAN1_SET","","",69,null],[13,"CONFIG_IEEE0_SET","","",69,null],[13,"CONFIG_IEEE1_SET","","",69,null],[13,"CONFIG_IEEE2_SET","","",69,null],[13,"CONFIG_IEEE3_SET","","",69,null],[13,"CONFIG_IEEE4_SET","","",69,null],[13,"CONFIG_IEEE5_SET","","",69,null],[13,"CONFIG_IEEE6_SET","","",69,null],[13,"CONFIG_IEEE7_SET","","",69,null],[13,"CONFIG_POWER_SET","","",69,null],[13,"CONFIG_DONE","","",69,null],[13,"RX","","",69,null],[13,"RX_START_READING","","",69,null],[13,"RX_READING_FRAME_LEN","","",69,null],[13,"RX_READING_FRAME_LEN_DONE","","",69,null],[13,"RX_READING_FRAME","","",69,null],[13,"RX_READING_FRAME_DONE","","",69,null],[13,"UNKNOWN","","",69,null],[5,"setting_to_power","","",null,{"inputs":[{"name":"u8"}],"output":{"name":"i8"}}],[5,"power_to_setting","","",null,{"inputs":[{"name":"i8"}],"output":{"name":"u8"}}],[5,"interrupt_included","","",null,{"inputs":[{"name":"u8"},{"name":"u8"}],"output":{"name":"bool"}}],[17,"INTERRUPT_ID","","",null,null],[11,"clone","","",69,{"inputs":[{"name":"self"}],"output":{"name":"internalstate"}}],[11,"eq","","",69,{"inputs":[{"name":"self"},{"name":"internalstate"}],"output":{"name":"bool"}}],[11,"read_write_done","","",68,null],[11,"fired","","",68,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[11,"new","","",68,{"inputs":[{"name":"s"},{"name":"pin"},{"name":"pin"},{"name":"pin"},{"name":"pinctl"}],"output":{"name":"rf233"}}],[11,"handle_interrupt","","",68,{"inputs":[{"name":"self"}],"output":null}],[11,"register_write","","",68,{"inputs":[{"name":"self"},{"name":"rf233register"},{"name":"u8"}],"output":{"name":"returncode"}}],[11,"register_read","","",68,{"inputs":[{"name":"self"},{"name":"rf233register"}],"output":{"name":"returncode"}}],[11,"frame_write","","",68,null],[11,"frame_read","","",68,null],[11,"state_transition_write","","",68,{"inputs":[{"name":"self"},{"name":"rf233register"},{"name":"u8"},{"name":"internalstate"}],"output":null}],[11,"state_transition_read","","",68,{"inputs":[{"name":"self"},{"name":"rf233register"},{"name":"internalstate"}],"output":null}],[11,"prepare_packet","","Generate the 802.15.4 header and set up the radio's state to be able to send the packet (store reference, etc.). buf is the full SPI buffer, not just the MAC frame",68,null],[11,"prepare_packet_long","","",68,null],[11,"initialize","","",68,null],[11,"reset","","",68,{"inputs":[{"name":"self"}],"output":{"name":"returncode"}}],[11,"start","","",68,{"inputs":[{"name":"self"}],"output":{"name":"returncode"}}],[11,"stop","","",68,{"inputs":[{"name":"self"}],"output":{"name":"returncode"}}],[11,"is_on","","",68,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"busy","","",68,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"set_config_client","","",68,{"inputs":[{"name":"self"},{"name":"configclient"}],"output":null}],[11,"set_power_client","","",68,{"inputs":[{"name":"self"},{"name":"powerclient"}],"output":null}],[11,"config_set_address","","",68,{"inputs":[{"name":"self"},{"name":"u16"}],"output":null}],[11,"config_set_address_long","","",68,null],[11,"config_set_pan","","",68,{"inputs":[{"name":"self"},{"name":"u16"}],"output":null}],[11,"config_set_tx_power","","",68,{"inputs":[{"name":"self"},{"name":"i8"}],"output":{"name":"returncode"}}],[11,"config_set_channel","","",68,{"inputs":[{"name":"self"},{"name":"u8"}],"output":{"name":"returncode"}}],[11,"config_address","","",68,{"inputs":[{"name":"self"}],"output":{"name":"u16"}}],[11,"config_address_long","","",68,null],[11,"config_pan","","The 16-bit PAN ID",68,{"inputs":[{"name":"self"}],"output":{"name":"u16"}}],[11,"config_tx_power","","The transmit power, in dBm",68,{"inputs":[{"name":"self"}],"output":{"name":"i8"}}],[11,"config_channel","","The 802.15.4 channel",68,{"inputs":[{"name":"self"}],"output":{"name":"u8"}}],[11,"config_commit","","",68,{"inputs":[{"name":"self"}],"output":{"name":"returncode"}}],[11,"payload_offset","","",68,{"inputs":[{"name":"self"},{"name":"bool"},{"name":"bool"}],"output":{"name":"u8"}}],[11,"header_size","","",68,{"inputs":[{"name":"self"},{"name":"bool"},{"name":"bool"}],"output":{"name":"u8"}}],[11,"packet_payload_offset","","",68,null],[11,"packet_header_size","","",68,null],[11,"packet_get_src","","",68,null],[11,"packet_get_dest","","",68,null],[11,"packet_has_src_long","","",68,null],[11,"packet_has_dest_long","","",68,null],[11,"packet_get_src_long","","",68,null],[11,"packet_get_dest_long","","",68,null],[11,"packet_get_length","","",68,null],[11,"packet_get_pan","","",68,null],[11,"set_transmit_client","","",68,{"inputs":[{"name":"self"},{"name":"txclient"}],"output":null}],[11,"set_receive_client","","",68,null],[11,"set_receive_buffer","","",68,null],[11,"transmit","","",68,null],[11,"transmit_long","","",68,null],[0,"rf233_const","capsules","Support for the RF233 capsule.",null,null],[4,"RF233Register","capsules::rf233_const","",null,null],[13,"MIN","","",70,null],[13,"TRX_STATUS","","",70,null],[13,"TRX_STATE","","",70,null],[13,"TRX_CTRL_0","","",70,null],[13,"TRX_CTRL_1","","",70,null],[13,"PHY_TX_PWR","","",70,null],[13,"PHY_RSSI","","",70,null],[13,"PHY_ED_LEVEL","","",70,null],[13,"PHY_CC_CCA","","",70,null],[13,"CCA_THRES","","",70,null],[13,"RX_CTRL","","",70,null],[13,"SFD_VALUE","","",70,null],[13,"TRX_CTRL_2","","",70,null],[13,"ANT_DIV","","",70,null],[13,"IRQ_MASK","","",70,null],[13,"IRQ_STATUS","","",70,null],[13,"VCTRL","","",70,null],[13,"BATMON","","",70,null],[13,"XOSC_CTRL","","",70,null],[13,"CC_CTRL_0","","",70,null],[13,"CC_CTRL_1","","",70,null],[13,"RX_SYN","","",70,null],[13,"TRX_RPC","","",70,null],[13,"XAH_CTRL_1","","",70,null],[13,"FTN_CTRL","","",70,null],[13,"XAH_CTRL_2","","",70,null],[13,"PLL_CF","","",70,null],[13,"PLL_DCU","","",70,null],[13,"PART_NUM","","",70,null],[13,"VERSION_NUM","","",70,null],[13,"MAN_ID_0","","",70,null],[13,"MAN_ID_1","","",70,null],[13,"SHORT_ADDR_0","","",70,null],[13,"SHORT_ADDR_1","","",70,null],[13,"PAN_ID_0","","",70,null],[13,"PAN_ID_1","","",70,null],[13,"IEEE_ADDR_0","","",70,null],[13,"IEEE_ADDR_1","","",70,null],[13,"IEEE_ADDR_2","","",70,null],[13,"IEEE_ADDR_3","","",70,null],[13,"IEEE_ADDR_4","","",70,null],[13,"IEEE_ADDR_5","","",70,null],[13,"IEEE_ADDR_6","","",70,null],[13,"IEEE_ADDR_7","","",70,null],[13,"XAH_CTRL_0","","",70,null],[13,"CSMA_SEED_0","","",70,null],[13,"CSMA_SEED_1","","",70,null],[13,"CSMA_BE","","",70,null],[13,"TST_CTRL_DIGI","","",70,null],[13,"PHY_TX_TIME","","",70,null],[13,"TST_AGC","","",70,null],[13,"TST_SDM","","",70,null],[13,"MAX","","",70,null],[4,"RF233BusCommand","","",null,null],[13,"REGISTER_READ","","",71,null],[13,"REGISTER_WRITE","","",71,null],[13,"FRAME_READ","","",71,null],[13,"FRAME_WRITE","","",71,null],[13,"SRAM_READ","","",71,null],[13,"SRAM_WRITE","","",71,null],[4,"ExternalState","","",null,null],[13,"ON","","",72,null],[13,"BUSY_RX","","",72,null],[13,"BUSY_TX","","",72,null],[13,"RX_ON","","",72,null],[13,"TRX_OFF","","",72,null],[13,"PLL_ON","","",72,null],[13,"SLEEP","","",72,null],[13,"PREP_DEEP_SLEEP","","",72,null],[13,"BUSY_RX_AACK","","",72,null],[13,"BUSY_TX_ARET","","",72,null],[13,"RX_AACK_ON","","",72,null],[13,"TX_ARET_ON","","",72,null],[13,"STATE_TRANSITION_IN_PROGRESS","","",72,null],[4,"RF233TrxCmd","","",null,null],[13,"TX_START","","",73,null],[13,"RX_ON","","",73,null],[13,"OFF","","",73,null],[13,"PLL_ON","","",73,null],[13,"RX_AACK_ON","","",73,null],[13,"TX_ARET_ON","","",73,null],[17,"TRX_CTRL_1_DIG34_RXTX_INDICATOR","","",null,null],[17,"TRX_CTRL_1_SPI_CMD_TRX_STATUS","","",null,null],[17,"TRX_CTRL_1_AUTO_CRC","","",null,null],[17,"PHY_TX_PWR_4","","",null,null],[17,"PHY_CC_CCA_MODE_CS_OR_ED","","",null,null],[17,"PHY_CC_CCA_MODE_ED","","",null,null],[17,"PHY_CC_CCA_MODE_CS","","",null,null],[17,"PHY_CC_CCA_MODE_CS_AND_ED","","",null,null],[17,"TRX_CTRL_2_RX_SAFE_MODE","","",null,null],[17,"TRX_CTRL_2_DATA_RATE_250","","",null,null],[17,"IRQ_TRXBUF_ACCESS_VIOLATION","","",null,null],[17,"IRQ_TRX_DONE","","",null,null],[17,"IRQ_RX_START","","",null,null],[17,"IRQ_PLL_LOCK","","",null,null],[17,"XAH_CTRL_1_AACK_PROM_MODE","","",null,null],[17,"TRX_CTRL_1","","",null,null],[17,"TRX_CTRL_2","","",null,null],[17,"PHY_CC_CCA","","",null,null],[17,"PHY_TX_PWR","","",null,null],[17,"PHY_CHANNEL","","",null,null],[17,"IRQ_MASK","","",null,null],[17,"XAH_CTRL_1","","",null,null],[17,"XAH_CTRL_0","","",null,null],[17,"TRX_RPC","","",null,null],[17,"TRX_TRAC_MASK","","",null,null],[17,"TRX_TRAC_SUCCESS_DATA_PENDING","","",null,null],[17,"PAN_ID_0","","",null,null],[17,"PAN_ID_1","","",null,null],[17,"IEEE_ADDR_0","","",null,null],[17,"IEEE_ADDR_1","","",null,null],[17,"IEEE_ADDR_2","","",null,null],[17,"IEEE_ADDR_3","","",null,null],[17,"IEEE_ADDR_4","","",null,null],[17,"IEEE_ADDR_5","","",null,null],[17,"IEEE_ADDR_6","","",null,null],[17,"IEEE_ADDR_7","","",null,null],[17,"SHORT_ADDR_0","","",null,null],[17,"SHORT_ADDR_1","","",null,null],[17,"IRQ_7_BAT_LOW","","",null,null],[17,"IRQ_6_TRX_UR","","",null,null],[17,"IRQ_5_AMI","","",null,null],[17,"IRQ_4_CCA_ED_DONE","","",null,null],[17,"IRQ_3_TRX_END","","",null,null],[17,"IRQ_2_RX_START","","",null,null],[17,"IRQ_1_PLL_UNLOCK","","",null,null],[17,"IRQ_0_PLL_LOCK","","",null,null],[11,"eq","","",70,{"inputs":[{"name":"self"},{"name":"rf233register"}],"output":{"name":"bool"}}],[11,"clone","","",70,{"inputs":[{"name":"self"}],"output":{"name":"rf233register"}}],[11,"fmt","","",70,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",71,{"inputs":[{"name":"self"},{"name":"rf233buscommand"}],"output":{"name":"bool"}}],[11,"clone","","",71,{"inputs":[{"name":"self"}],"output":{"name":"rf233buscommand"}}],[11,"fmt","","",71,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",72,{"inputs":[{"name":"self"},{"name":"externalstate"}],"output":{"name":"bool"}}],[11,"clone","","",72,{"inputs":[{"name":"self"}],"output":{"name":"externalstate"}}],[11,"fmt","","",72,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[0,"radio","capsules","Provides userspace applications with the ability to send and receive 802.15.4 packets.",null,null],[3,"App","capsules::radio","",null,null],[12,"tx_callback","","",74,null],[12,"rx_callback","","",74,null],[12,"cfg_callback","","",74,null],[12,"app_read","","",74,null],[12,"app_write","","",74,null],[3,"RadioDriver","","",null,null],[12,"radio","","",75,null],[12,"busy","","",75,null],[12,"app","","",75,null],[12,"kernel_tx","","",75,null],[11,"default","","",74,{"inputs":[],"output":{"name":"app"}}],[11,"new","","",75,{"inputs":[{"name":"r"}],"output":{"name":"radiodriver"}}],[11,"config_buffer","","",75,null],[11,"allow","","",75,{"inputs":[{"name":"self"},{"name":"appid"},{"name":"usize"},{"name":"appslice"}],"output":{"name":"returncode"}}],[11,"subscribe","","",75,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"callback"}],"output":{"name":"returncode"}}],[11,"command","","",75,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"usize"},{"name":"appid"}],"output":{"name":"returncode"}}],[11,"send_done","","",75,null],[11,"receive","","",75,null],[11,"config_done","","",75,{"inputs":[{"name":"self"},{"name":"returncode"}],"output":null}],[0,"rng","capsules","Provides a simple driver for userspace applications to request randomness.",null,null],[3,"App","capsules::rng","",null,null],[12,"callback","","",76,null],[12,"buffer","","",76,null],[12,"remaining","","",76,null],[12,"idx","","",76,null],[3,"SimpleRng","","",null,null],[12,"rng","","",77,null],[12,"apps","","",77,null],[12,"getting_randomness","","",77,null],[11,"default","","",76,{"inputs":[],"output":{"name":"app"}}],[11,"new","","",77,{"inputs":[{"name":"rng"},{"name":"container"}],"output":{"name":"simplerng"}}],[11,"randomness_available","","",77,{"inputs":[{"name":"self"},{"name":"iterator"}],"output":{"name":"continue"}}],[11,"allow","","",77,{"inputs":[{"name":"self"},{"name":"appid"},{"name":"usize"},{"name":"appslice"}],"output":{"name":"returncode"}}],[11,"subscribe","","",77,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"callback"}],"output":{"name":"returncode"}}],[11,"command","","",77,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"usize"},{"name":"appid"}],"output":{"name":"returncode"}}],[0,"temp_nrf51dk","capsules","Provides userspace with access to the NRF51DK onboard temperature sensor.",null,null],[3,"App","capsules::temp_nrf51dk","",null,null],[12,"callback","","",78,null],[12,"subscribed","","",78,null],[3,"Temperature","","",null,null],[12,"temp","","",79,null],[12,"apps","","",79,null],[12,"busy","","",79,null],[11,"default","","",78,{"inputs":[],"output":{"name":"app"}}],[11,"new","","",79,{"inputs":[{"name":"t"},{"name":"container"}],"output":{"name":"temperature"}}],[11,"measurement_done","","",79,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"returncode"}}],[11,"subscribe","","",79,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"callback"}],"output":{"name":"returncode"}}],[11,"command","","",79,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"usize"},{"name":"appid"}],"output":{"name":"returncode"}}],[0,"symmetric_encryption","capsules","Provides userspace applications with the ability to encrypt and decrypt messages.",null,null],[3,"App","capsules::symmetric_encryption","",null,null],[12,"callback","","",80,null],[12,"key_buf","","",80,null],[12,"data_buf","","",80,null],[12,"ctr_buf","","",80,null],[3,"Crypto","","",null,null],[12,"crypto","","",81,null],[12,"apps","","",81,null],[12,"kernel_key","","",81,null],[12,"kernel_data","","",81,null],[12,"kernel_ctr","","",81,null],[12,"key_configured","","",81,null],[12,"busy","","",81,null],[12,"state","","",81,null],[4,"CryptoState","","This enum shall keep track of the state of the AESDriver",null,null],[13,"IDLE","","",82,null],[13,"ENCRYPT","","",82,null],[13,"DECRYPT","","",82,null],[13,"SETKEY","","",82,null],[7,"BUF","","",null,null],[7,"KEY","","",null,null],[7,"IV","","",null,null],[11,"clone","","",82,{"inputs":[{"name":"self"}],"output":{"name":"cryptostate"}}],[11,"fmt","","",82,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",82,{"inputs":[{"name":"self"},{"name":"cryptostate"}],"output":{"name":"bool"}}],[11,"default","","",80,{"inputs":[],"output":{"name":"app"}}],[11,"new","","",81,null],[11,"aes128_crypt_ctr","","",81,{"inputs":[{"name":"self"},{"name":"cryptostate"}],"output":{"name":"returncode"}}],[11,"crypt_done","","",81,null],[11,"allow","","",81,{"inputs":[{"name":"self"},{"name":"appid"},{"name":"usize"},{"name":"appslice"}],"output":{"name":"returncode"}}],[11,"subscribe","","",81,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"callback"}],"output":{"name":"returncode"}}],[11,"command","","",81,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"usize"},{"name":"appid"}],"output":{"name":"returncode"}}],[0,"ninedof","capsules","Provides userspace with virtualized access to 9DOF sensors.",null,null],[3,"App","capsules::ninedof","",null,null],[12,"callback","","",83,null],[12,"pending_command","","",83,null],[12,"command","","",83,null],[12,"arg1","","",83,null],[3,"NineDof","","",null,null],[12,"driver","","",84,null],[12,"apps","","",84,null],[12,"current_app","","",84,null],[4,"NineDofCommand","","",null,null],[13,"Exists","","",85,null],[13,"ReadAccelerometer","","",85,null],[13,"ReadMagnetometer","","",85,null],[13,"ReadGyroscope","","",85,null],[11,"clone","","",85,{"inputs":[{"name":"self"}],"output":{"name":"ninedofcommand"}}],[11,"eq","","",85,{"inputs":[{"name":"self"},{"name":"ninedofcommand"}],"output":{"name":"bool"}}],[11,"default","","",83,{"inputs":[],"output":{"name":"app"}}],[11,"new","","",84,{"inputs":[{"name":"ninedof"},{"name":"container"}],"output":{"name":"ninedof"}}],[11,"enqueue_command","","",84,{"inputs":[{"name":"self"},{"name":"ninedofcommand"},{"name":"usize"},{"name":"appid"}],"output":{"name":"returncode"}}],[11,"call_driver","","",84,{"inputs":[{"name":"self"},{"name":"ninedofcommand"},{"name":"usize"}],"output":{"name":"returncode"}}],[11,"callback","","",84,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"usize"},{"name":"usize"}],"output":null}],[11,"subscribe","","",84,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"callback"}],"output":{"name":"returncode"}}],[11,"command","","",84,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"usize"},{"name":"appid"}],"output":{"name":"returncode"}}],[0,"ltc294x","capsules","Driver for the LTC294X line of coulomb counters.",null,null],[3,"LTC294X","capsules::ltc294x","Implementation of a driver for the LTC294X coulomb counters.",null,null],[12,"i2c","","",86,null],[12,"interrupt_pin","","",86,null],[12,"model","","",86,null],[12,"state","","",86,null],[12,"buffer","","",86,null],[12,"client","","",86,null],[3,"LTC294XDriver","","Default implementation of the LTC2941 driver that provides a Driver interface for providing access to applications.",null,null],[12,"ltc294x","","",87,null],[12,"callback","","",87,null],[4,"Registers","","",null,null],[13,"Status","","",88,null],[13,"Control","","",88,null],[13,"AccumulatedChargeMSB","","",88,null],[13,"AccumulatedChargeLSB","","",88,null],[13,"ChargeThresholdHighMSB","","",88,null],[13,"ChargeThresholdHighLSB","","",88,null],[13,"ChargeThresholdLowMSB","","",88,null],[13,"ChargeThresholdLowLSB","","",88,null],[13,"VoltageMSB","","",88,null],[13,"VoltageLSB","","",88,null],[13,"CurrentMSB","","",88,null],[13,"CurrentLSB","","",88,null],[4,"State","","",null,null],[13,"Idle","","",89,null],[13,"ReadStatus","","Simple read states",89,null],[13,"ReadCharge","","",89,null],[13,"ReadVoltage","","",89,null],[13,"ReadCurrent","","",89,null],[13,"ReadShutdown","","",89,null],[13,"Done","","",89,null],[4,"ChipModel","","Which version of the chip we are actually using.",null,null],[13,"LTC2941","","",90,null],[13,"LTC2942","","",90,null],[13,"LTC2943","","",90,null],[4,"InterruptPinConf","","Settings for which interrupt we want.",null,null],[13,"Disabled","","",91,null],[13,"ChargeCompleteMode","","",91,null],[13,"AlertMode","","",91,null],[4,"VBatAlert","","Threshold options for battery alerts.",null,null],[13,"Off","","",92,null],[13,"Threshold2V8","","",92,null],[13,"Threshold2V9","","",92,null],[13,"Threshold3V0","","",92,null],[7,"BUFFER","","",null,null],[8,"LTC294XClient","","Supported events for the LTC294X.",null,null],[10,"interrupt","","",93,{"inputs":[{"name":"self"}],"output":null}],[10,"status","","",93,{"inputs":[{"name":"self"},{"name":"bool"},{"name":"bool"},{"name":"bool"},{"name":"bool"},{"name":"bool"}],"output":null}],[10,"charge","","",93,{"inputs":[{"name":"self"},{"name":"u16"}],"output":null}],[10,"voltage","","",93,{"inputs":[{"name":"self"},{"name":"u16"}],"output":null}],[10,"current","","",93,{"inputs":[{"name":"self"},{"name":"u16"}],"output":null}],[10,"done","","",93,{"inputs":[{"name":"self"}],"output":null}],[11,"clone","","",89,{"inputs":[{"name":"self"}],"output":{"name":"state"}}],[11,"eq","","",89,{"inputs":[{"name":"self"},{"name":"state"}],"output":{"name":"bool"}}],[11,"clone","","",90,{"inputs":[{"name":"self"}],"output":{"name":"chipmodel"}}],[11,"new","","",86,null],[11,"set_client","","",86,{"inputs":[{"name":"self"},{"name":"c"}],"output":null}],[11,"read_status","","",86,{"inputs":[{"name":"self"}],"output":{"name":"returncode"}}],[11,"configure","","",86,{"inputs":[{"name":"self"},{"name":"interruptpinconf"},{"name":"u8"},{"name":"vbatalert"}],"output":{"name":"returncode"}}],[11,"reset_charge","","Set the accumulated charge to 0",86,{"inputs":[{"name":"self"}],"output":{"name":"returncode"}}],[11,"set_high_threshold","","",86,{"inputs":[{"name":"self"},{"name":"u16"}],"output":{"name":"returncode"}}],[11,"set_low_threshold","","",86,{"inputs":[{"name":"self"},{"name":"u16"}],"output":{"name":"returncode"}}],[11,"get_charge","","Get the cumulative charge as measured by the LTC2941.",86,{"inputs":[{"name":"self"}],"output":{"name":"returncode"}}],[11,"get_voltage","","Get the voltage at sense+",86,{"inputs":[{"name":"self"}],"output":{"name":"returncode"}}],[11,"get_current","","Get the current sensed by the resistor",86,{"inputs":[{"name":"self"}],"output":{"name":"returncode"}}],[11,"shutdown","","Put the LTC294X in a low power state.",86,{"inputs":[{"name":"self"}],"output":{"name":"returncode"}}],[11,"set_model","","Set the LTC294X model actually on the board.",86,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"returncode"}}],[11,"command_complete","","",86,null],[11,"fired","","",86,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[11,"new","","",87,{"inputs":[{"name":"ltc294x"}],"output":{"name":"ltc294xdriver"}}],[11,"interrupt","","",87,{"inputs":[{"name":"self"}],"output":null}],[11,"status","","",87,{"inputs":[{"name":"self"},{"name":"bool"},{"name":"bool"},{"name":"bool"},{"name":"bool"},{"name":"bool"}],"output":null}],[11,"charge","","",87,{"inputs":[{"name":"self"},{"name":"u16"}],"output":null}],[11,"done","","",87,{"inputs":[{"name":"self"}],"output":null}],[11,"voltage","","",87,{"inputs":[{"name":"self"},{"name":"u16"}],"output":null}],[11,"current","","",87,{"inputs":[{"name":"self"},{"name":"u16"}],"output":null}],[11,"subscribe","","Setup callbacks.",87,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"callback"}],"output":{"name":"returncode"}}],[11,"command","","Request operations for the LTC294X chip.",87,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"usize"},{"name":"appid"}],"output":{"name":"returncode"}}],[0,"mcp23008","capsules","Driver for the Microchip MCP23008 I2C GPIO extender.",null,null],[3,"MCP23008","capsules::mcp23008","",null,null],[12,"i2c","","",94,null],[12,"state","","",94,null],[12,"buffer","","",94,null],[12,"interrupt_pin","","",94,null],[12,"interrupt_settings","","",94,null],[12,"identifier","","",94,null],[12,"client","","",94,null],[4,"Registers","","",null,null],[13,"IoDir","","",95,null],[13,"IPol","","",95,null],[13,"GpIntEn","","",95,null],[13,"DefVal","","",95,null],[13,"IntCon","","",95,null],[13,"IoCon","","",95,null],[13,"GpPu","","",95,null],[13,"IntF","","",95,null],[13,"IntCap","","",95,null],[13,"Gpio","","",95,null],[13,"OLat","","",95,null],[4,"State","","States of the I2C protocol with the MCP23008.",null,null],[13,"Idle","","",96,null],[13,"SelectIoDir","","",96,null],[13,"ReadIoDir","","",96,null],[13,"SelectGpPu","","",96,null],[13,"ReadGpPu","","",96,null],[13,"SetGpPu","","",96,null],[13,"SelectGpio","","",96,null],[13,"ReadGpio","","",96,null],[13,"SelectGpioToggle","","",96,null],[13,"ReadGpioToggle","","",96,null],[13,"SelectGpioRead","","",96,null],[13,"ReadGpioRead","","",96,null],[13,"EnableInterruptSettings","","",96,null],[13,"ReadInterruptSetup","","",96,null],[13,"ReadInterruptValues","","",96,null],[13,"Done","","Disable I2C and release buffer",96,null],[4,"Direction","","",null,null],[13,"Input","","",97,null],[13,"Output","","",97,null],[4,"PinState","","",null,null],[13,"High","","",98,null],[13,"Low","","",98,null],[7,"BUFFER","","",null,null],[11,"fmt","","",95,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",96,{"inputs":[{"name":"self"}],"output":{"name":"state"}}],[11,"fmt","","",96,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",96,{"inputs":[{"name":"self"},{"name":"state"}],"output":{"name":"bool"}}],[11,"ne","","",96,{"inputs":[{"name":"self"},{"name":"state"}],"output":{"name":"bool"}}],[11,"clone","","",97,{"inputs":[{"name":"self"}],"output":{"name":"direction"}}],[11,"fmt","","",97,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",97,{"inputs":[{"name":"self"},{"name":"direction"}],"output":{"name":"bool"}}],[11,"clone","","",98,{"inputs":[{"name":"self"}],"output":{"name":"pinstate"}}],[11,"fmt","","",98,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",98,{"inputs":[{"name":"self"},{"name":"pinstate"}],"output":{"name":"bool"}}],[11,"new","","",94,null],[11,"set_client","","Set the client of this MCP23008 when commands finish or interrupts occur. The `identifier` is simply passed back with the callback so that the upper layer can keep track of which device triggered.",94,{"inputs":[{"name":"self"},{"name":"c"}],"output":null}],[11,"enable_host_interrupt","","",94,{"inputs":[{"name":"self"}],"output":{"name":"returncode"}}],[11,"set_direction","","",94,{"inputs":[{"name":"self"},{"name":"u8"},{"name":"direction"}],"output":{"name":"returncode"}}],[11,"configure_pullup","","Set the pull-up on the pin also configure it to be an input.",94,{"inputs":[{"name":"self"},{"name":"u8"},{"name":"bool"}],"output":{"name":"returncode"}}],[11,"set_pin","","",94,{"inputs":[{"name":"self"},{"name":"u8"},{"name":"pinstate"}],"output":{"name":"returncode"}}],[11,"toggle_pin","","",94,{"inputs":[{"name":"self"},{"name":"u8"}],"output":{"name":"returncode"}}],[11,"read_pin","","",94,{"inputs":[{"name":"self"},{"name":"u8"}],"output":{"name":"returncode"}}],[11,"enable_interrupt_pin","","",94,{"inputs":[{"name":"self"},{"name":"u8"},{"name":"interruptmode"}],"output":{"name":"returncode"}}],[11,"disable_interrupt_pin","","",94,{"inputs":[{"name":"self"},{"name":"u8"}],"output":{"name":"returncode"}}],[11,"save_pin_interrupt_state","","Helper function for keeping track of which interrupts are currently enabled.",94,{"inputs":[{"name":"self"},{"name":"u8"},{"name":"bool"},{"name":"interruptmode"}],"output":null}],[11,"remove_pin_interrupt_state","","",94,{"inputs":[{"name":"self"},{"name":"u8"}],"output":null}],[11,"get_pin_interrupt_enabled_state","","Create an 8 bit bitmask of which interrupts are enabled.",94,{"inputs":[{"name":"self"}],"output":{"name":"u8"}}],[11,"check_pin_interrupt_enabled","","",94,{"inputs":[{"name":"self"},{"name":"u8"}],"output":{"name":"bool"}}],[11,"get_pin_interrupt_direction","","",94,{"inputs":[{"name":"self"},{"name":"u8"}],"output":{"name":"interruptmode"}}],[11,"command_complete","","",94,null],[11,"fired","","",94,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[11,"disable","","",94,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"returncode"}}],[11,"make_output","","",94,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"returncode"}}],[11,"make_input","","",94,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"inputmode"}],"output":{"name":"returncode"}}],[11,"read","","",94,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"returncode"}}],[11,"toggle","","",94,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"returncode"}}],[11,"set","","",94,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"returncode"}}],[11,"clear","","",94,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"returncode"}}],[11,"enable_interrupt","","",94,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"interruptmode"},{"name":"usize"}],"output":{"name":"returncode"}}],[11,"disable_interrupt","","",94,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"returncode"}}],[0,"gpio_async","capsules","Provides userspace applications with a driver interface to asynchronous GPIO pins.",null,null],[3,"GPIOAsync","capsules::gpio_async","",null,null],[12,"ports","","",99,null],[12,"callback","","",99,null],[12,"interrupt_callback","","",99,null],[11,"new","","",99,null],[11,"configure_input_pin","","",99,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"usize"},{"name":"usize"}],"output":{"name":"returncode"}}],[11,"configure_interrupt","","",99,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"usize"},{"name":"usize"}],"output":{"name":"returncode"}}],[11,"fired","","",99,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"usize"}],"output":null}],[11,"done","","",99,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[11,"subscribe","","Setup callbacks for gpio_async events.",99,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"callback"}],"output":{"name":"returncode"}}],[11,"command","","Configure and read GPIO pins.",99,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"usize"},{"name":"appid"}],"output":{"name":"returncode"}}],[0,"max17205","capsules","Driver for the Maxim MAX17205 fuel gauge.",null,null],[3,"MAX17205","capsules::max17205","",null,null],[12,"i2c0","","",100,null],[12,"state","","",100,null],[12,"soc","","",100,null],[12,"soc_mah","","",100,null],[12,"voltage","","",100,null],[12,"buffer","","",100,null],[12,"client","","",100,null],[3,"MAX17205Driver","","Default implementation of the MAX17205 driver that provides a `Driver` interface for providing access to applications.",null,null],[12,"max17205","","",101,null],[12,"callback","","",101,null],[4,"Registers","","",null,null],[13,"Status","","",102,null],[13,"RepCap","","",102,null],[13,"RepSOC","","",102,null],[13,"FullCapRep","","",102,null],[13,"NPackCfg","","",102,null],[13,"NRSense","","",102,null],[13,"Batt","","",102,null],[13,"Current","","",102,null],[13,"Coulomb","","",102,null],[4,"State","","",null,null],[13,"Idle","","",103,null],[13,"SetupReadCoulomb","","Simple read states",103,null],[13,"ReadCoulomb","","",103,null],[13,"SetupReadStatus","","",103,null],[13,"ReadStatus","","",103,null],[13,"SetupReadSOC","","",103,null],[13,"ReadSOC","","",103,null],[13,"SetupReadCap","","",103,null],[13,"ReadCap","","",103,null],[13,"SetupReadVolt","","",103,null],[13,"ReadVolt","","",103,null],[13,"SetupReadCurrent","","",103,null],[13,"ReadCurrent","","",103,null],[7,"BUFFER","","",null,null],[8,"MAX17205Client","","",null,null],[10,"status","","",104,{"inputs":[{"name":"self"},{"name":"u16"}],"output":null}],[10,"state_of_charge","","",104,{"inputs":[{"name":"self"},{"name":"u16"},{"name":"u16"},{"name":"u16"}],"output":null}],[10,"voltage_current","","",104,{"inputs":[{"name":"self"},{"name":"u16"},{"name":"u16"}],"output":null}],[10,"coulomb","","",104,{"inputs":[{"name":"self"},{"name":"u16"}],"output":null}],[11,"clone","","",103,{"inputs":[{"name":"self"}],"output":{"name":"state"}}],[11,"eq","","",103,{"inputs":[{"name":"self"},{"name":"state"}],"output":{"name":"bool"}}],[11,"new","","",100,null],[11,"set_client","","",100,{"inputs":[{"name":"self"},{"name":"c"}],"output":null}],[11,"setup_read_status","","",100,{"inputs":[{"name":"self"}],"output":{"name":"returncode"}}],[11,"setup_read_soc","","",100,{"inputs":[{"name":"self"}],"output":{"name":"returncode"}}],[11,"setup_read_curvolt","","",100,{"inputs":[{"name":"self"}],"output":{"name":"returncode"}}],[11,"setup_read_coulomb","","",100,{"inputs":[{"name":"self"}],"output":{"name":"returncode"}}],[11,"command_complete","","",100,null],[11,"new","","",101,{"inputs":[{"name":"max17205"}],"output":{"name":"max17205driver"}}],[11,"status","","",101,{"inputs":[{"name":"self"},{"name":"u16"}],"output":null}],[11,"state_of_charge","","",101,{"inputs":[{"name":"self"},{"name":"u16"},{"name":"u16"},{"name":"u16"}],"output":null}],[11,"voltage_current","","",101,{"inputs":[{"name":"self"},{"name":"u16"},{"name":"u16"}],"output":null}],[11,"coulomb","","",101,{"inputs":[{"name":"self"},{"name":"u16"}],"output":null}],[11,"subscribe","","Setup callback.",101,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"callback"}],"output":{"name":"returncode"}}],[11,"command","","Setup and read the MAX17205.",101,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"usize"},{"name":"appid"}],"output":{"name":"returncode"}}],[0,"pca9544a","capsules","Driver for the PCA9544A I2C Selector.",null,null],[3,"PCA9544A","capsules::pca9544a","",null,null],[12,"i2c","","",105,null],[12,"state","","",105,null],[12,"buffer","","",105,null],[12,"callback","","",105,null],[4,"State","","",null,null],[13,"Idle","","",106,null],[13,"ReadControl","","Read the control register and return the specified data field.",106,null],[13,"Done","","",106,null],[4,"ControlField","","",null,null],[13,"InterruptMask","","",107,null],[13,"SelectedChannels","","",107,null],[7,"BUFFER","","",null,null],[11,"clone","","",106,{"inputs":[{"name":"self"}],"output":{"name":"state"}}],[11,"eq","","",106,{"inputs":[{"name":"self"},{"name":"state"}],"output":{"name":"bool"}}],[11,"ne","","",106,{"inputs":[{"name":"self"},{"name":"state"}],"output":{"name":"bool"}}],[11,"clone","","",107,{"inputs":[{"name":"self"}],"output":{"name":"controlfield"}}],[11,"eq","","",107,{"inputs":[{"name":"self"},{"name":"controlfield"}],"output":{"name":"bool"}}],[11,"new","","",105,null],[11,"select_channels","","Choose which channel(s) are active. Channels are encoded with a bitwise mask (0x01 means enable channel 0, 0x0F means enable all channels). Send 0 to disable all channels.",105,{"inputs":[{"name":"self"},{"name":"u8"}],"output":{"name":"returncode"}}],[11,"read_interrupts","","",105,{"inputs":[{"name":"self"}],"output":{"name":"returncode"}}],[11,"read_selected_channels","","",105,{"inputs":[{"name":"self"}],"output":{"name":"returncode"}}],[11,"read_control","","",105,{"inputs":[{"name":"self"},{"name":"controlfield"}],"output":{"name":"returncode"}}],[11,"command_complete","","",105,null],[11,"subscribe","","Setup callback for event done.",105,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"callback"}],"output":{"name":"returncode"}}],[11,"command","","Control the I2C selector.",105,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"usize"},{"name":"appid"}],"output":{"name":"returncode"}}],[0,"nonvolatile_to_pages","capsules","Map arbitrary nonvolatile reads and writes to page operations.",null,null],[3,"NonvolatileToPages","capsules::nonvolatile_to_pages","",null,null],[12,"driver","","The module providing a `Flash` interface.",108,null],[12,"client","","Callback to the user of this capsule.",108,null],[12,"pagebuffer","","Buffer correctly sized for the underlying flash page size.",108,null],[12,"state","","Current state of this capsule.",108,null],[12,"buffer","","Temporary holding place for the user's buffer.",108,null],[12,"address","","Absolute address of where we are reading or writing. This gets updated as the operation proceeds across pages.",108,null],[12,"length","","Total length to read or write. We need to store this to return it to the client.",108,null],[12,"remaining_length","","How many bytes are left to read or write.",108,null],[12,"buffer_index","","Where we are in the user buffer.",108,null],[4,"State","","This module is either waiting to do something, or handling a read/write.",null,null],[13,"Idle","","",109,null],[13,"Read","","",109,null],[13,"Write","","",109,null],[11,"clone","","",109,{"inputs":[{"name":"self"}],"output":{"name":"state"}}],[11,"fmt","","",109,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",109,{"inputs":[{"name":"self"},{"name":"state"}],"output":{"name":"bool"}}],[11,"new","","",108,null],[11,"set_client","","",108,{"inputs":[{"name":"self"},{"name":"nonvolatilestorageclient"}],"output":null}],[11,"read","","",108,null],[11,"write","","",108,null],[11,"read_complete","","",108,null],[11,"write_complete","","",108,null],[11,"erase_complete","","",108,{"inputs":[{"name":"self"},{"name":"error"}],"output":null}],[0,"nonvolatile_storage_driver","capsules","This provides kernel and userspace access to nonvolatile memory.",null,null],[3,"App","capsules::nonvolatile_storage_driver","",null,null],[12,"callback_read","","",110,null],[12,"callback_write","","",110,null],[12,"pending_command","","",110,null],[12,"command","","",110,null],[12,"offset","","",110,null],[12,"length","","",110,null],[12,"buffer_read","","",110,null],[12,"buffer_write","","",110,null],[3,"NonvolatileStorage","","",null,null],[12,"driver","","",111,null],[12,"apps","","",111,null],[12,"buffer","","",111,null],[12,"current_user","","",111,null],[12,"userspace_start_address","","",111,null],[12,"userspace_length","","",111,null],[12,"kernel_start_address","","",111,null],[12,"kernel_length","","",111,null],[12,"kernel_client","","",111,null],[12,"kernel_pending_command","","",111,null],[12,"kernel_command","","",111,null],[12,"kernel_buffer","","",111,null],[12,"kernel_readwrite_length","","",111,null],[12,"kernel_readwrite_address","","",111,null],[4,"NonvolatileCommand","","",null,null],[13,"UserspaceRead","","",112,null],[13,"UserspaceWrite","","",112,null],[13,"KernelRead","","",112,null],[13,"KernelWrite","","",112,null],[4,"NonvolatileUser","","",null,null],[13,"App","","",113,null],[12,"app_id","capsules::nonvolatile_storage_driver::NonvolatileUser","",113,null],[13,"Kernel","capsules::nonvolatile_storage_driver","",113,null],[7,"BUFFER","","",null,null],[11,"clone","","",112,{"inputs":[{"name":"self"}],"output":{"name":"nonvolatilecommand"}}],[11,"eq","","",112,{"inputs":[{"name":"self"},{"name":"nonvolatilecommand"}],"output":{"name":"bool"}}],[11,"clone","","",113,{"inputs":[{"name":"self"}],"output":{"name":"nonvolatileuser"}}],[11,"default","","",110,{"inputs":[],"output":{"name":"app"}}],[11,"new","","",111,null],[11,"enqueue_command","","",111,{"inputs":[{"name":"self"},{"name":"nonvolatilecommand"},{"name":"usize"},{"name":"usize"},{"name":"option"}],"output":{"name":"returncode"}}],[11,"userspace_call_driver","","",111,{"inputs":[{"name":"self"},{"name":"nonvolatilecommand"},{"name":"usize"},{"name":"usize"}],"output":{"name":"returncode"}}],[11,"check_queue","","",111,{"inputs":[{"name":"self"}],"output":null}],[11,"read_done","","",111,null],[11,"write_done","","",111,null],[11,"set_client","","",111,{"inputs":[{"name":"self"},{"name":"nonvolatilestorageclient"}],"output":null}],[11,"read","","",111,null],[11,"write","","",111,null],[11,"allow","","Setup shared buffers.",111,{"inputs":[{"name":"self"},{"name":"appid"},{"name":"usize"},{"name":"appslice"}],"output":{"name":"returncode"}}],[11,"subscribe","","Setup callbacks.",111,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"callback"}],"output":{"name":"returncode"}}],[11,"command","","Command interface.",111,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"usize"},{"name":"appid"}],"output":{"name":"returncode"}}]],"paths":[[3,"Button"],[3,"App"],[3,"Console"],[3,"FM25CL"],[4,"Opcodes"],[4,"State"],[8,"FM25CLCustom"],[8,"FM25CLClient"],[3,"GPIO"],[3,"Isl29035"],[4,"State"],[3,"LED"],[4,"ActivationMode"],[3,"App"],[3,"Nrf51822Serialization"],[3,"TimerData"],[3,"TimerDriver"],[4,"Expiration"],[3,"TMP006"],[4,"Registers"],[4,"ProtocolState"],[3,"SDCard"],[3,"SDCardDriver"],[3,"App"],[4,"SDCmd"],[4,"SDResponse"],[4,"SpiState"],[4,"AlarmState"],[4,"ErrorCode"],[4,"SDCardType"],[8,"SDCardClient"],[3,"SI7021"],[4,"Registers"],[4,"State"],[3,"App"],[3,"SlaveApp"],[3,"Spi"],[3,"SpiSlave"],[3,"VirtualMuxAlarm"],[3,"MuxAlarm"],[3,"MuxFlash"],[3,"FlashUser"],[4,"Op"],[3,"MuxI2C"],[3,"I2CDevice"],[4,"Op"],[3,"MuxSpiMaster"],[3,"VirtualSpiMasterDevice"],[3,"VirtualSpiSlaveDevice"],[4,"Op"],[3,"Adc"],[3,"App"],[4,"AdcMode"],[3,"Dac"],[3,"App"],[3,"I2CMasterSlaveDriver"],[4,"MasterAction"],[3,"LPS25HB"],[4,"Registers"],[4,"State"],[3,"TSL2561"],[4,"Registers"],[4,"State"],[3,"Fxos8700cq"],[4,"Registers"],[4,"State"],[3,"App"],[3,"Crc"],[3,"RF233"],[4,"InternalState"],[4,"RF233Register"],[4,"RF233BusCommand"],[4,"ExternalState"],[4,"RF233TrxCmd"],[3,"App"],[3,"RadioDriver"],[3,"App"],[3,"SimpleRng"],[3,"App"],[3,"Temperature"],[3,"App"],[3,"Crypto"],[4,"CryptoState"],[3,"App"],[3,"NineDof"],[4,"NineDofCommand"],[3,"LTC294X"],[3,"LTC294XDriver"],[4,"Registers"],[4,"State"],[4,"ChipModel"],[4,"InterruptPinConf"],[4,"VBatAlert"],[8,"LTC294XClient"],[3,"MCP23008"],[4,"Registers"],[4,"State"],[4,"Direction"],[4,"PinState"],[3,"GPIOAsync"],[3,"MAX17205"],[3,"MAX17205Driver"],[4,"Registers"],[4,"State"],[8,"MAX17205Client"],[3,"PCA9544A"],[4,"State"],[4,"ControlField"],[3,"NonvolatileToPages"],[4,"State"],[3,"App"],[3,"NonvolatileStorage"],[4,"NonvolatileCommand"],[4,"NonvolatileUser"]]};
searchIndex["cortexm4"] = {"doc":"Shared implementations for ARM Cortex-M4 MCUs.","items":[[5,"systick_handler","cortexm4","",null,{"inputs":[],"output":null}],[5,"generic_isr","","All ISRs are caught by this handler which indirects to a custom handler by indexing into `INTERRUPT_TABLE` based on the ISR number.",null,{"inputs":[],"output":null}],[5,"SVC_Handler","","",null,{"inputs":[],"output":null}],[5,"switch_to_user","","r0 is top of user stack, r1 Process GOT",null,null],[0,"mpu","","Implementation of the ARM memory protection unit.",null,null],[3,"MpuType","cortexm4::mpu","Indicates whether the MPU is present and, if so, how many regions it supports.",null,null],[12,"is_separate","","Indicates whether the processor support unified (0) or separate (1) instruction and data regions. Always reads 0 on the Cortex-M4.",0,null],[12,"data_regions","","The number of data regions supported. If this field reads-as-zero the processor does not implement an MPU",0,null],[12,"instruction_regions","","The number of instructions regions supported. Always reads 0.",0,null],[12,"_reserved","","",0,null],[3,"Registers","","MPU Registers for the Cortex-M4 family",null,null],[12,"mpu_type","","",1,null],[12,"control","","The control register:   * Enables the MPU (bit 0).   * Enables MPU in hard-fault, non-maskable interrupt (NMI) and     FAULTMASK escalated handlers (bit 1).   * Enables the default memory map background region in privileged mode     (bit 2).",1,null],[12,"region_number","","Selects the region number (zero-indexed) referenced by the region base address and region attribute and size registers.",1,null],[12,"region_base_address","","Defines the base address of the currently selected MPU region.",1,null],[12,"region_attributes_and_size","","Defines the region size and memory attributes of the selected MPU region. The bits are defined as in 4.5.5 of the Cortex-M4 user guide:",1,null],[3,"MPU","","Constructor field is private to limit who can create a new MPU",null,null],[12,"0","","",2,null],[6,"Region","","",null,null],[17,"MPU_BASE_ADDRESS","","",null,null],[11,"new","","",2,{"inputs":[],"output":{"name":"mpu"}}],[11,"enable_mpu","","",2,{"inputs":[{"name":"self"}],"output":null}],[11,"disable_mpu","","",2,{"inputs":[{"name":"self"}],"output":null}],[11,"create_region","","",2,{"inputs":[{"name":"usize"},{"name":"usize"},{"name":"usize"},{"name":"executepermission"},{"name":"accesspermission"}],"output":{"name":"option"}}],[11,"set_mpu","","",2,{"inputs":[{"name":"self"},{"name":"region"}],"output":null}],[0,"systick","cortexm4","ARM SysTick peripheral.",null,null],[3,"SysTick","cortexm4::systick","",null,null],[12,"control","","",3,null],[12,"reload","","",3,null],[12,"value","","",3,null],[12,"calibration","","",3,null],[7,"OVERFLOW_FIRED","","",null,null],[17,"BASE_ADDR","","",null,null],[11,"new","","",3,{"inputs":[],"output":{"name":"systick"}}],[11,"set_timer","","",3,{"inputs":[{"name":"self"},{"name":"u32"}],"output":null}],[11,"value","","",3,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"overflowed","","",3,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"reset","","",3,{"inputs":[{"name":"self"}],"output":null}],[11,"enable","","",3,{"inputs":[{"name":"self"},{"name":"bool"}],"output":null}],[11,"overflow_fired","","",3,{"inputs":[],"output":{"name":"bool"}}],[0,"scb","cortexm4","ARM System Control Block",null,null],[3,"ScbRegisters","cortexm4::scb","",null,null],[12,"cpuid","","",4,null],[12,"icsr","","",4,null],[12,"vtor","","",4,null],[12,"aircr","","",4,null],[12,"scr","","",4,null],[12,"ccr","","",4,null],[12,"shp","","",4,null],[12,"shcsr","","",4,null],[12,"cfsr","","",4,null],[12,"hfsr","","",4,null],[12,"dfsr","","",4,null],[12,"mmfar","","",4,null],[12,"bfar","","",4,null],[12,"afsr","","",4,null],[12,"pfr","","",4,null],[12,"dfr","","",4,null],[12,"adr","","",4,null],[12,"mmfr","","",4,null],[12,"isar","","",4,null],[12,"_reserved0","","",4,null],[12,"cpacr","","",4,null],[5,"set_sleepdeep","","Allow the core to go into deep sleep on WFI.",null,{"inputs":[],"output":null}],[5,"unset_sleepdeep","","Do not allow the core to go into deep sleep on WFI.",null,{"inputs":[],"output":null}],[5,"reset","","Software reset using the ARM System Control Block",null,{"inputs":[],"output":null}],[7,"SCB","","",null,null],[17,"SCB_BASE","","",null,null]],"paths":[[3,"MpuType"],[3,"Registers"],[3,"MPU"],[3,"SysTick"],[3,"ScbRegisters"]]};
searchIndex["hail"] = {"doc":"Board file for Hail development platform.","items":[[3,"Hail","hail","",null,null],[12,"console","","",0,null],[12,"gpio","","",0,null],[12,"timer","","",0,null],[12,"isl29035","","",0,null],[12,"si7021","","",0,null],[12,"ninedof","","",0,null],[12,"spi","","",0,null],[12,"nrf51822","","",0,null],[12,"adc","","",0,null],[12,"led","","",0,null],[12,"button","","",0,null],[12,"rng","","",0,null],[12,"ipc","","",0,null],[12,"crc","","",0,null],[12,"dac","","",0,null],[12,"aes","","",0,null],[5,"set_pin_primary_functions","","",null,{"inputs":[],"output":null}],[5,"reset_handler","","",null,{"inputs":[],"output":null}],[0,"io","","",null,null],[3,"Writer","hail::io","",null,null],[12,"initialized","","",1,null],[5,"panic_fmt","","",null,null],[7,"WRITER","","",null,null],[11,"write_str","","",1,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"result"}}],[0,"test_take_map_cell","hail","",null,null],[5,"test_take_map_cell","hail::test_take_map_cell","",null,{"inputs":[],"output":null}],[5,"test_map_cell","","",null,{"inputs":[{"name":"mapcell"}],"output":null}],[7,"SPI_READ_BUF","hail","",null,null],[7,"SPI_WRITE_BUF","","",null,null],[7,"APP_MEMORY","","",null,null],[7,"PROCESSES","","",null,null],[17,"NUM_PROCS","","",null,null],[17,"FAULT_RESPONSE","","",null,null],[11,"with_driver","","",0,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"f"}],"output":{"name":"r"}}],[14,"print","","",null,null],[14,"println","","",null,null]],"paths":[[3,"Hail"],[3,"Writer"]]};
searchIndex["kernel"] = {"doc":"","items":[[5,"main","kernel","Main loop.",null,null],[0,"common","","Common operations in the Tock OS.",null,null],[0,"ring_buffer","kernel::common","Implementation of a ring buffer.",null,null],[3,"RingBuffer","kernel::common::ring_buffer","",null,null],[12,"ring","","",0,null],[12,"head","","",0,null],[12,"tail","","",0,null],[11,"new","","",0,null],[11,"has_elements","","",0,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_full","","",0,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"len","","",0,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"enqueue","","",0,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"bool"}}],[11,"dequeue","","",0,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[0,"queue","kernel::common","Interface for queue structure.",null,null],[8,"Queue","kernel::common::queue","",null,null],[10,"has_elements","","",1,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[10,"is_full","","",1,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[10,"len","","",1,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[10,"enqueue","","",1,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"bool"}}],[10,"dequeue","","",1,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[0,"utils","kernel::common","Utility macros including `static_init!`.",null,null],[0,"take_cell","","Tock specific `Cell` types for sharing references.",null,null],[3,"TakeCell","kernel::common::take_cell","A shared reference to a mutable reference.",null,null],[12,"val","","",2,null],[3,"MapCell","","A mutable memory location that enforces borrow rules at runtime without possible panics.",null,null],[12,"val","","",3,null],[12,"occupied","","",3,null],[11,"empty","","",2,{"inputs":[],"output":{"name":"takecell"}}],[11,"new","","Creates a new `TakeCell` containing `value`",2,{"inputs":[{"name":"t"}],"output":{"name":"takecell"}}],[11,"is_none","","",2,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_some","","",2,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"take","","Takes the mutable reference out of the `TakeCell` leaving a `None` in it's place. If the value has already been taken elsewhere (and not `replace`ed), the returned `Option` will be empty.",2,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"put","","Stores `val` in the `TakeCell`",2,{"inputs":[{"name":"self"},{"name":"option"}],"output":null}],[11,"replace","","Replaces the contents of the `TakeCell` with `val`. If the cell was not empty, the previous value is returned, otherwise `None` is returned.",2,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"option"}}],[11,"map","","Allows `closure` to borrow the contents of the `TakeCell` if-and-only-if it is not `take`n already. The state of the `TakeCell` is unchanged after the closure completes.",2,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"option"}}],[11,"map_or","","Performs a `map` or returns a default value if the `TakeCell` is empty",2,{"inputs":[{"name":"self"},{"name":"r"},{"name":"f"}],"output":{"name":"r"}}],[11,"modify_or_replace","","Uses the first closure (`modify`) to modify the value in the `TakeCell` if it is present, otherwise, fills the `TakeCell` with the result of `mkval`.",2,{"inputs":[{"name":"self"},{"name":"f"},{"name":"g"}],"output":null}],[11,"empty","","",3,{"inputs":[],"output":{"name":"mapcell"}}],[11,"new","","Creates a new `MapCell` containing `value`",3,{"inputs":[{"name":"t"}],"output":{"name":"mapcell"}}],[11,"is_none","","",3,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_some","","",3,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"take","","Takes the value out of the `MapCell` leaving it empty. If the value has already been taken elsewhere (and not `replace`ed), the returned `Option` will be `None`.",3,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"put","","",3,{"inputs":[{"name":"self"},{"name":"t"}],"output":null}],[11,"replace","","Replaces the contents of the `MapCell` with `val`. If the cell was not empty, the previous value is returned, otherwise `None` is returned.",3,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"option"}}],[11,"map","","Allows `closure` to borrow the contents of the `MapCell` if-and-only-if it is not `take`n already. The state of the `MapCell` is unchanged after the closure completes.",3,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"option"}}],[11,"map_or","","",3,{"inputs":[{"name":"self"},{"name":"r"},{"name":"f"}],"output":{"name":"r"}}],[11,"modify_or_replace","","",3,{"inputs":[{"name":"self"},{"name":"f"},{"name":"g"}],"output":null}],[0,"volatile_cell","kernel::common","Implementation of types for accessing MCU registers.",null,null],[3,"VolatileCell","kernel::common::volatile_cell","",null,null],[12,"value","","",4,null],[11,"clone","","",4,{"inputs":[{"name":"self"}],"output":{"name":"volatilecell"}}],[11,"new","","",4,{"inputs":[{"name":"t"}],"output":{"name":"self"}}],[11,"get","","",4,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"set","","",4,{"inputs":[{"name":"self"},{"name":"t"}],"output":null}],[0,"list","kernel::common","Linked list implementation.",null,null],[3,"ListLink","kernel::common::list","",null,null],[12,"0","","",5,null],[3,"List","","",null,null],[12,"head","","",6,null],[3,"ListIterator","","",null,null],[12,"cur","","",7,null],[8,"ListNode","","",null,null],[10,"next","","",8,{"inputs":[{"name":"self"}],"output":{"name":"listlink"}}],[11,"empty","","",5,{"inputs":[],"output":{"name":"listlink"}}],[11,"next","","",7,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"new","","",6,{"inputs":[],"output":{"name":"list"}}],[11,"head","","",6,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"push_head","","",6,{"inputs":[{"name":"self"},{"name":"t"}],"output":null}],[11,"iter","","",6,{"inputs":[{"name":"self"}],"output":{"name":"listiterator"}}],[0,"math","kernel::common","Helper functions for common mathematical operations.",null,null],[3,"PowerOfTwo","kernel::common::math","",null,null],[12,"0","","",9,null],[5,"powf32","","",null,{"inputs":[{"name":"f32"},{"name":"f32"}],"output":{"name":"f32"}}],[5,"powif32","","",null,{"inputs":[{"name":"f32"},{"name":"i32"}],"output":{"name":"f32"}}],[5,"sqrtf32","","",null,{"inputs":[{"name":"f32"}],"output":{"name":"f32"}}],[5,"get_errno","","",null,{"inputs":[],"output":{"name":"i32"}}],[5,"closest_power_of_two","","",null,{"inputs":[{"name":"u32"}],"output":{"name":"u32"}}],[5,"log_base_two","","",null,{"inputs":[{"name":"u32"}],"output":{"name":"u32"}}],[5,"__errno","","",null,null],[11,"clone","","",9,{"inputs":[{"name":"self"}],"output":{"name":"poweroftwo"}}],[11,"fmt","","",9,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",9,{"inputs":[{"name":"self"},{"name":"poweroftwo"}],"output":{"name":"bool"}}],[11,"ne","","",9,{"inputs":[{"name":"self"},{"name":"poweroftwo"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",9,{"inputs":[{"name":"self"},{"name":"poweroftwo"}],"output":{"name":"option"}}],[11,"lt","","",9,{"inputs":[{"name":"self"},{"name":"poweroftwo"}],"output":{"name":"bool"}}],[11,"le","","",9,{"inputs":[{"name":"self"},{"name":"poweroftwo"}],"output":{"name":"bool"}}],[11,"gt","","",9,{"inputs":[{"name":"self"},{"name":"poweroftwo"}],"output":{"name":"bool"}}],[11,"ge","","",9,{"inputs":[{"name":"self"},{"name":"poweroftwo"}],"output":{"name":"bool"}}],[11,"assert_receiver_is_total_eq","","",9,null],[11,"cmp","","",9,{"inputs":[{"name":"self"},{"name":"poweroftwo"}],"output":{"name":"ordering"}}],[11,"exp","","Returns the base-2 exponent as a numeric type",9,{"inputs":[{"name":"self"}],"output":{"name":"r"}}],[11,"floor","","Converts a number two the nearest `PowerOfTwo` less-than-or-equal to it.",9,{"inputs":[{"name":"f"}],"output":{"name":"poweroftwo"}}],[11,"ceiling","","Converts a number two the nearest `PowerOfTwo` greater-than-or-equal to it.",9,{"inputs":[{"name":"f"}],"output":{"name":"poweroftwo"}}],[11,"zero","","Creates a new `PowerOfTwo` representing the number zero.",9,{"inputs":[],"output":{"name":"poweroftwo"}}],[11,"as_num","","Converts a `PowerOfTwo` to a number.",9,{"inputs":[{"name":"self"}],"output":{"name":"f"}}],[0,"callback","kernel","Data structure for storing a callback to userspace or kernelspace.",null,null],[3,"AppId","kernel::callback","Userspace app identifier.",null,null],[12,"idx","","",10,null],[3,"Callback","","Wrapper around a function pointer.",null,null],[12,"app_id","","",11,null],[12,"appdata","","",11,null],[12,"fn_ptr","","",11,null],[4,"RustOrRawFnPtr","","",null,null],[13,"Raw","","",12,null],[12,"ptr","kernel::callback::RustOrRawFnPtr","",12,null],[13,"Rust","kernel::callback","",12,null],[12,"func","kernel::callback::RustOrRawFnPtr","",12,null],[17,"KERNEL_APPID_BOUNDARY","kernel::callback","The kernel can masquerade as an app. IDs >= this value are the kernel. These IDs are used to identify which kernel container is being accessed.",null,null],[11,"clone","","",10,{"inputs":[{"name":"self"}],"output":{"name":"appid"}}],[11,"fmt","","",10,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","",10,{"inputs":[{"name":"usize"}],"output":{"name":"appid"}}],[11,"kernel_new","","",10,{"inputs":[{"name":"usize"}],"output":{"name":"appid"}}],[11,"is_kernel","","",10,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_kernel_idx","","",10,{"inputs":[{"name":"usize"}],"output":{"name":"bool"}}],[11,"idx","","",10,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"clone","","",12,{"inputs":[{"name":"self"}],"output":{"name":"rustorrawfnptr"}}],[11,"fmt","","",12,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",11,{"inputs":[{"name":"self"}],"output":{"name":"callback"}}],[11,"fmt","","",11,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","",11,{"inputs":[{"name":"appid"},{"name":"usize"},{"name":"nonzero"}],"output":{"name":"callback"}}],[11,"kernel_new","","",11,null],[11,"schedule","","",11,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"usize"},{"name":"usize"}],"output":{"name":"bool"}}],[11,"app_id","","",11,{"inputs":[{"name":"self"}],"output":{"name":"appid"}}],[0,"container","kernel","Data structure to store a list of userspace applications.",null,null],[3,"Container","kernel::container","",null,null],[12,"container_num","","",13,null],[12,"ptr","","",13,null],[3,"AppliedContainer","","",null,null],[12,"appid","","",14,null],[12,"container","","",14,null],[12,"_phantom","","",14,null],[3,"Allocator","","",null,null],[12,"app","","",15,null],[12,"app_id","","",15,null],[3,"Owned","","",null,null],[12,"data","","",16,null],[12,"app_id","","",16,null],[3,"Iter","","",null,null],[12,"container","","",17,null],[12,"index","","",17,null],[12,"len","","",17,null],[5,"kernel_container_for","","",null,null],[7,"CONTAINER_COUNTER","","",null,null],[11,"enter","","",14,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"r"}}],[11,"new","","",16,null],[11,"appid","","",16,{"inputs":[{"name":"self"}],"output":{"name":"appid"}}],[11,"drop","","",16,{"inputs":[{"name":"self"}],"output":null}],[11,"deref","","",16,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"deref_mut","","",16,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"alloc","","",15,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"result"}}],[11,"create","","",13,{"inputs":[],"output":{"name":"container"}}],[11,"container","","",13,{"inputs":[{"name":"self"},{"name":"appid"}],"output":{"name":"option"}}],[11,"enter","","",13,{"inputs":[{"name":"self"},{"name":"appid"},{"name":"f"}],"output":{"name":"result"}}],[11,"each","","",13,{"inputs":[{"name":"self"},{"name":"f"}],"output":null}],[11,"iter","","",13,{"inputs":[{"name":"self"}],"output":{"name":"iter"}}],[11,"next","","",17,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[0,"debug","kernel","Provides a `debug!` macro for in-kernel debugging.",null,null],[3,"DebugWriter","kernel::debug","",null,null],[12,"driver","","",18,null],[12,"container","","",18,null],[12,"output_buffer","","",18,null],[12,"output_head","","",18,null],[12,"output_tail","","",18,null],[12,"output_active_len","","",18,null],[12,"count","","",18,null],[5,"assign_console_driver","","",null,{"inputs":[{"name":"option"},{"name":"t"}],"output":null}],[5,"get_container","","",null,null],[5,"begin_debug_fmt","","",null,null],[5,"begin_debug","","",null,null],[7,"DEBUG_WRITER","","",null,null],[7,"KERNEL_CONSOLE_CALLBACK","","",null,null],[17,"APPID_IDX","","",null,null],[17,"BUF_SIZE","","",null,null],[8,"Debug","","",null,null],[10,"write","","",19,null],[11,"write_buffer","","Convenience method that writes (end-start) bytes from bytes into the debug buffer",18,null],[11,"publish_str","","",18,{"inputs":[{"name":"self"}],"output":null}],[11,"callback","","",18,{"inputs":[{"name":"usize"},{"name":"usize"},{"name":"usize"},{"name":"usize"}],"output":null}],[11,"write_str","","",18,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"result"}}],[0,"driver","kernel","System call interface for userspace applications.",null,null],[8,"Driver","kernel::driver","`Driver`s implement the three driver-specific system calls: `subscribe`, `command` and `allow`.",null,null],[11,"subscribe","","`subscribe` lets an application pass a callback to the driver to be called later. This returns `ENOSUPPORT` if not used.",20,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"callback"}],"output":{"name":"returncode"}}],[11,"command","","`command` instructs a driver to perform some action synchronously. This returns `ENOSUPPORT` if not used.",20,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"usize"},{"name":"appid"}],"output":{"name":"returncode"}}],[11,"allow","","`allow` lets an application give the driver access to a buffer in the application's memory. This returns `ENOSUPPORT` if not used.",20,{"inputs":[{"name":"self"},{"name":"appid"},{"name":"usize"},{"name":"appslice"}],"output":{"name":"returncode"}}],[0,"ipc","kernel","Inter-process communication mechanism for Tock.",null,null],[3,"IPCData","kernel::ipc","",null,null],[12,"shared_memory","","",21,null],[12,"client_callbacks","","",21,null],[12,"callback","","",21,null],[3,"IPC","","",null,null],[12,"data","","",22,null],[11,"default","","",21,{"inputs":[],"output":{"name":"ipcdata"}}],[11,"new","","",22,{"inputs":[],"output":{"name":"ipc"}}],[11,"schedule_callback","","",22,{"inputs":[{"name":"self"},{"name":"appid"},{"name":"appid"},{"name":"ipctype"}],"output":null}],[11,"subscribe","","subscribe enables processes using IPC to register callbacks that fire when notify() is called.",22,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"callback"}],"output":{"name":"returncode"}}],[11,"command","","command is how notify() is implemented. Notifying an IPC service is done by setting client_or_svc to 0, and notifying an IPC client is done by setting client_or_svc to 1. In either case, the target_id is the same number as provided in a notify callback or as returned by allow.",22,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"usize"},{"name":"appid"}],"output":{"name":"returncode"}}],[11,"allow","","allow enables processes to discover IPC services on the platform or share buffers with existing services.",22,{"inputs":[{"name":"self"},{"name":"appid"},{"name":"usize"},{"name":"appslice"}],"output":{"name":"returncode"}}],[0,"mem","kernel","Data structure for passing application memory to the kernel.",null,null],[3,"Private","kernel::mem","",null,null],[3,"Shared","","",null,null],[3,"AppPtr","","",null,null],[12,"ptr","","",23,null],[12,"process","","",23,null],[12,"_phantom","","",23,null],[3,"AppSlice","","",null,null],[12,"ptr","","",24,null],[12,"len","","",24,null],[11,"fmt","","",25,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",26,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","",23,null],[11,"deref","","",23,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"deref_mut","","",23,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"drop","","",23,{"inputs":[{"name":"self"}],"output":null}],[11,"new","","",24,null],[11,"len","","",24,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"ptr","","",24,null],[11,"expose_to","","",24,{"inputs":[{"name":"self"},{"name":"appid"}],"output":{"name":"bool"}}],[11,"iter","","",24,{"inputs":[{"name":"self"}],"output":{"name":"iter"}}],[11,"iter_mut","","",24,{"inputs":[{"name":"self"}],"output":{"name":"itermut"}}],[11,"chunks","","",24,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"chunks"}}],[11,"chunks_mut","","",24,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"chunksmut"}}],[11,"as_ref","","",24,null],[11,"as_mut","","",24,null],[0,"memop","kernel","Implementation of the MEMOP family of syscalls.",null,null],[5,"memop","kernel::memop","",null,{"inputs":[{"name":"process"}],"output":{"name":"returncode"}}],[0,"returncode","kernel","Standard return type for invoking operations, returning success or an error code.",null,null],[4,"ReturnCode","kernel::returncode","",null,null],[13,"SuccessWithValue","","",27,null],[12,"value","kernel::returncode::ReturnCode","",27,null],[13,"SUCCESS","kernel::returncode","",27,null],[13,"FAIL","","",27,null],[13,"EBUSY","","",27,null],[13,"EALREADY","","",27,null],[13,"EOFF","","",27,null],[13,"ERESERVE","","",27,null],[13,"EINVAL","","",27,null],[13,"ESIZE","","",27,null],[13,"ECANCEL","","",27,null],[13,"ENOMEM","","",27,null],[13,"ENOSUPPORT","","",27,null],[13,"ENODEVICE","","",27,null],[13,"EUNINSTALLED","","",27,null],[13,"ENOACK","","",27,null],[11,"clone","","",27,{"inputs":[{"name":"self"}],"output":{"name":"returncode"}}],[11,"fmt","","",27,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",27,{"inputs":[{"name":"self"},{"name":"returncode"}],"output":{"name":"bool"}}],[11,"ne","","",27,{"inputs":[{"name":"self"},{"name":"returncode"}],"output":{"name":"bool"}}],[0,"hil","kernel","Public traits for interfaces between Tock components.",null,null],[0,"led","kernel::hil","Interface for LEDs that abstract away polarity and pin.",null,null],[3,"LedHigh","kernel::hil::led","For LEDs in which on is when GPIO is high.",null,null],[12,"pin","","",28,null],[3,"LedLow","","For LEDs in which on is when GPIO is low.",null,null],[12,"pin","","",29,null],[8,"Led","","",null,null],[10,"init","","",30,{"inputs":[{"name":"self"}],"output":null}],[10,"on","","",30,{"inputs":[{"name":"self"}],"output":null}],[10,"off","","",30,{"inputs":[{"name":"self"}],"output":null}],[10,"toggle","","",30,{"inputs":[{"name":"self"}],"output":null}],[10,"read","","",30,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"new","","",28,{"inputs":[{"name":"pin"}],"output":{"name":"ledhigh"}}],[11,"new","","",29,{"inputs":[{"name":"pin"}],"output":{"name":"ledlow"}}],[11,"init","","",28,{"inputs":[{"name":"self"}],"output":null}],[11,"on","","",28,{"inputs":[{"name":"self"}],"output":null}],[11,"off","","",28,{"inputs":[{"name":"self"}],"output":null}],[11,"toggle","","",28,{"inputs":[{"name":"self"}],"output":null}],[11,"read","","",28,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"init","","",29,{"inputs":[{"name":"self"}],"output":null}],[11,"on","","",29,{"inputs":[{"name":"self"}],"output":null}],[11,"off","","",29,{"inputs":[{"name":"self"}],"output":null}],[11,"toggle","","",29,{"inputs":[{"name":"self"}],"output":null}],[11,"read","","",29,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[0,"time","kernel::hil","Hardware agnostic interfaces for counter-like resources.",null,null],[3,"Freq32KHz","kernel::hil::time","32KHz `Frequency`",null,null],[3,"Freq16KHz","","16KHz `Frequency`",null,null],[3,"Freq1KHz","","1KHz `Frequency`",null,null],[8,"Time","","",null,null],[16,"Frequency","","",31,null],[10,"disable","","",31,{"inputs":[{"name":"self"}],"output":null}],[10,"is_armed","","",31,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[8,"Frequency","","Trait to represent clock frequency in Hz",null,null],[10,"frequency","","",32,{"inputs":[],"output":{"name":"u32"}}],[8,"Alarm","","The `Alarm` trait models a wrapping counter capapable of notifying when the counter reaches a certain value.",null,null],[10,"now","","Returns the current time in hardware clock units.",33,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[10,"set_alarm","","Sets a one-shot alarm fire when the clock reaches `tics`.",33,{"inputs":[{"name":"self"},{"name":"u32"}],"output":null}],[10,"get_alarm","","Returns the value set in `set_alarm`",33,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[8,"Client","","A client of an implementor of the `Alarm` trait.",null,null],[10,"fired","","Callback signaled when the alarm's clock reaches the value set in `Alarm#set_alarm`.",34,{"inputs":[{"name":"self"}],"output":null}],[8,"Timer","","The `Timer` trait models a timer that can notify when a particular interval has elapsed.",null,null],[10,"oneshot","","Sets a one-shot timer to fire in `interval` clock-tics.",35,{"inputs":[{"name":"self"},{"name":"u32"}],"output":null}],[10,"repeat","","Sets repeating timer to fire every `interval` clock-tics.",35,{"inputs":[{"name":"self"},{"name":"u32"}],"output":null}],[11,"fmt","","",36,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"frequency","","",36,{"inputs":[],"output":{"name":"u32"}}],[11,"fmt","","",37,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"frequency","","",37,{"inputs":[],"output":{"name":"u32"}}],[11,"fmt","","",38,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"frequency","","",38,{"inputs":[],"output":{"name":"u32"}}],[0,"gpio","kernel::hil","Interface for direct control of GPIO pins.",null,null],[4,"InputMode","kernel::hil::gpio","Enum for configuring any pull-up or pull-down resistors on the GPIO pin.",null,null],[13,"PullUp","","",39,null],[13,"PullDown","","",39,null],[13,"PullNone","","",39,null],[4,"InterruptMode","","Enum for selecting which edge to trigger interrupts on.",null,null],[13,"RisingEdge","","",40,null],[13,"FallingEdge","","",40,null],[13,"EitherEdge","","",40,null],[8,"PinCtl","","",null,null],[10,"set_input_mode","","Configure whether the pin should have a pull-up or pull-down resistor or neither.",41,{"inputs":[{"name":"self"},{"name":"inputmode"}],"output":null}],[8,"Pin","","Interface for synchronous GPIO pins.",null,null],[10,"make_output","","Configure the GPIO pin as an output pin.",42,{"inputs":[{"name":"self"}],"output":null}],[10,"make_input","","Configure the GPIO pin as an input pin.",42,{"inputs":[{"name":"self"}],"output":null}],[10,"disable","","Disable the GPIO pin and put it into its lowest power mode.",42,{"inputs":[{"name":"self"}],"output":null}],[10,"set","","Set the GPIO pin high. It must be an output.",42,{"inputs":[{"name":"self"}],"output":null}],[10,"clear","","Set the GPIO pin low. It must be an output.",42,{"inputs":[{"name":"self"}],"output":null}],[10,"toggle","","Toggle the GPIO pin. It must be an output.",42,{"inputs":[{"name":"self"}],"output":null}],[10,"read","","Get the current state of an input GPIO pin.",42,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[10,"enable_interrupt","","Enable an interrupt on the GPIO pin. It must be configured as an interrupt. The `identifier` can be any value and will be returned to you when the interrupt on this pin fires.",42,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"interruptmode"}],"output":null}],[10,"disable_interrupt","","Disable the interrupt for the GPIO pin.",42,{"inputs":[{"name":"self"}],"output":null}],[8,"Client","","Interface for users of synchronous GPIO. In order to receive interrupts, the user must implement this `Client` interface.",null,null],[10,"fired","","Called when an interrupt occurs. The `identifier` will be the same value that was passed to `enable_interrupt()` when the interrupt was configured.",43,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[11,"fmt","","",39,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",40,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[0,"i2c","kernel::hil","Interface for I2C master and slave peripherals.",null,null],[4,"Error","kernel::hil::i2c","The type of error encoutered during an I2C command transmission.",null,null],[13,"AddressNak","","The slave did not acknowledge the chip address. Most likely the address is incorrect or the slave is not properly connected.",44,null],[13,"DataNak","","The data was not acknowledged by the slave.",44,null],[13,"ArbitrationLost","","Arbitration lost, meaning the state of the data line does not correspond to the data driven onto it. This can happen, for example, when a higher-priority transmission is in progress by a different master.",44,null],[13,"CommandComplete","","No error occured and the command completed successfully.",44,null],[4,"SlaveTransmissionType","","This specifies what type of transmission just finished from a Master device.",null,null],[13,"Write","","",45,null],[13,"Read","","",45,null],[8,"I2CMaster","","Interface for an I2C Master hardware driver.",null,null],[10,"enable","","",46,{"inputs":[{"name":"self"}],"output":null}],[10,"disable","","",46,{"inputs":[{"name":"self"}],"output":null}],[10,"write_read","","",46,null],[10,"write","","",46,null],[10,"read","","",46,null],[8,"I2CSlave","","Interface for an I2C Slave hardware driver.",null,null],[10,"enable","","",47,{"inputs":[{"name":"self"}],"output":null}],[10,"disable","","",47,{"inputs":[{"name":"self"}],"output":null}],[10,"set_address","","",47,{"inputs":[{"name":"self"},{"name":"u8"}],"output":null}],[10,"write_receive","","",47,null],[10,"read_send","","",47,null],[10,"listen","","",47,{"inputs":[{"name":"self"}],"output":null}],[8,"I2CMasterSlave","","Convenience type for capsules that need hardware that supports both Master and Slave modes.",null,null],[8,"I2CHwMasterClient","","Client interface for capsules that use I2CMaster devices.",null,null],[10,"command_complete","","Called when an I2C command completed. The `error` denotes whether the command completed successfully or if an error occured.",48,null],[8,"I2CHwSlaveClient","","Client interface for capsules that use I2CSlave devices.",null,null],[10,"command_complete","","Called when an I2C command completed.",49,null],[10,"read_expected","","Called from the I2C slave hardware to say that a Master has sent us a read message, but the driver did not have a buffer containing data setup, and therefore cannot respond. The I2C slave hardware will stretch the clock while waiting for the upper layer capsule to provide data to send to the remote master. Call `I2CSlave::read_send()` to provide data.",49,{"inputs":[{"name":"self"}],"output":null}],[10,"write_expected","","Called from the I2C slave hardware to say that a Master has sent us a write message, but there was no buffer setup to read the bytes into. The HW will stretch the clock while waiting for the user to call `I2CSlave::write_receive()` with a buffer.",49,{"inputs":[{"name":"self"}],"output":null}],[8,"I2CDevice","","Higher-level interface for I2C Master commands that wraps in the I2C address. It gives an interface for communicating with a specific I2C device.",null,null],[10,"enable","","",50,{"inputs":[{"name":"self"}],"output":null}],[10,"disable","","",50,{"inputs":[{"name":"self"}],"output":null}],[10,"write_read","","",50,null],[10,"write","","",50,null],[10,"read","","",50,null],[8,"I2CClient","","Client interface for I2CDevice implementations.",null,null],[10,"command_complete","","Called when an I2C command completed. The `error` denotes whether the command completed successfully or if an error occured.",51,null],[11,"clone","","",44,{"inputs":[{"name":"self"}],"output":{"name":"error"}}],[11,"fmt","","",44,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"assert_receiver_is_total_eq","","",44,null],[11,"eq","","",44,{"inputs":[{"name":"self"},{"name":"error"}],"output":{"name":"bool"}}],[11,"fmt","","",44,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",45,{"inputs":[{"name":"self"}],"output":{"name":"slavetransmissiontype"}}],[11,"fmt","","",45,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[0,"spi","kernel::hil","Interfaces for SPI master and slave communication.",null,null],[4,"DataOrder","kernel::hil::spi","Values for the ordering of bits",null,null],[13,"MSBFirst","","",52,null],[13,"LSBFirst","","",52,null],[4,"ClockPolarity","","Values for the clock polarity (idle state or CPOL)",null,null],[13,"IdleLow","","",53,null],[13,"IdleHigh","","",53,null],[4,"ClockPhase","","Which clock edge values are sampled on",null,null],[13,"SampleLeading","","",54,null],[13,"SampleTrailing","","",54,null],[8,"SpiMasterClient","","",null,null],[10,"read_write_done","","Called when a read/write operation finishes",55,null],[8,"SpiMaster","","The `SpiMaster` trait for interacting with SPI slave devices at a byte or buffer level.",null,null],[16,"ChipSelect","","",56,null],[10,"set_client","","",56,{"inputs":[{"name":"self"},{"name":"spimasterclient"}],"output":null}],[10,"init","","",56,{"inputs":[{"name":"self"}],"output":null}],[10,"is_busy","","",56,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[10,"read_write_bytes","","Perform an asynchronous read/write operation, whose completion is signaled by invoking SpiMasterClient on the initialized client. write_buffer must be Some, read_buffer may be None. If read_buffer is Some, the length of the operation is the minimum of the size of the two buffers.",56,null],[10,"write_byte","","",56,{"inputs":[{"name":"self"},{"name":"u8"}],"output":null}],[10,"read_byte","","",56,{"inputs":[{"name":"self"}],"output":{"name":"u8"}}],[10,"read_write_byte","","",56,{"inputs":[{"name":"self"},{"name":"u8"}],"output":{"name":"u8"}}],[10,"specify_chip_select","","Tell the SPI peripheral what to use as a chip select pin. The type of the argument is based on what makes sense for the peripheral when this trait is implemented.",56,null],[10,"set_rate","","Returns the actual rate set",56,{"inputs":[{"name":"self"},{"name":"u32"}],"output":{"name":"u32"}}],[10,"get_rate","","",56,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[10,"set_clock","","",56,{"inputs":[{"name":"self"},{"name":"clockpolarity"}],"output":null}],[10,"get_clock","","",56,{"inputs":[{"name":"self"}],"output":{"name":"clockpolarity"}}],[10,"set_phase","","",56,{"inputs":[{"name":"self"},{"name":"clockphase"}],"output":null}],[10,"get_phase","","",56,{"inputs":[{"name":"self"}],"output":{"name":"clockphase"}}],[10,"hold_low","","",56,{"inputs":[{"name":"self"}],"output":null}],[10,"release_low","","",56,{"inputs":[{"name":"self"}],"output":null}],[8,"SpiMasterDevice","","SPIMasterDevice provides a chip-specific interface to the SPI Master hardware. The interface wraps the chip select line so that chip drivers cannot communicate with different SPI devices.",null,null],[10,"configure","","Setup the SPI settings and speed of the bus.",57,{"inputs":[{"name":"self"},{"name":"clockpolarity"},{"name":"clockphase"},{"name":"u32"}],"output":null}],[10,"read_write_bytes","","Perform an asynchronous read/write operation, whose completion is signaled by invoking SpiMasterClient.read_write_done on the provided client. write_buffer must be Some, read_buffer may be None. If read_buffer is Some, the length of the operation is the minimum of the size of the two buffers.",57,null],[10,"set_polarity","","",57,{"inputs":[{"name":"self"},{"name":"clockpolarity"}],"output":null}],[10,"set_phase","","",57,{"inputs":[{"name":"self"},{"name":"clockphase"}],"output":null}],[10,"set_rate","","",57,{"inputs":[{"name":"self"},{"name":"u32"}],"output":null}],[10,"get_polarity","","",57,{"inputs":[{"name":"self"}],"output":{"name":"clockpolarity"}}],[10,"get_phase","","",57,{"inputs":[{"name":"self"}],"output":{"name":"clockphase"}}],[10,"get_rate","","",57,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[8,"SpiSlaveClient","","",null,null],[10,"chip_selected","","This is called whenever the slave is selected by the master",58,{"inputs":[{"name":"self"}],"output":null}],[10,"read_write_done","","This is called as a DMA interrupt when a transfer has completed",58,{"inputs":[{"name":"self"},{"name":"option"},{"name":"option"},{"name":"usize"}],"output":null}],[8,"SpiSlave","","",null,null],[10,"init","","",59,{"inputs":[{"name":"self"}],"output":null}],[10,"has_client","","Returns true if there is a client.",59,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[10,"set_client","","",59,{"inputs":[{"name":"self"},{"name":"option"}],"output":null}],[10,"set_write_byte","","",59,{"inputs":[{"name":"self"},{"name":"u8"}],"output":null}],[10,"read_write_bytes","","",59,{"inputs":[{"name":"self"},{"name":"option"},{"name":"option"},{"name":"usize"}],"output":{"name":"returncode"}}],[10,"set_clock","","",59,{"inputs":[{"name":"self"},{"name":"clockpolarity"}],"output":null}],[10,"get_clock","","",59,{"inputs":[{"name":"self"}],"output":{"name":"clockpolarity"}}],[10,"set_phase","","",59,{"inputs":[{"name":"self"},{"name":"clockphase"}],"output":null}],[10,"get_phase","","",59,{"inputs":[{"name":"self"}],"output":{"name":"clockphase"}}],[8,"SpiSlaveDevice","","SPISlaveDevice provides a chip-specific interface to the SPI Slave hardware. The interface wraps the chip select line so that chip drivers cannot communicate with different SPI devices.",null,null],[10,"configure","","Setup the SPI settings and speed of the bus.",60,{"inputs":[{"name":"self"},{"name":"clockpolarity"},{"name":"clockphase"}],"output":null}],[10,"read_write_bytes","","Perform an asynchronous read/write operation, whose completion is signaled by invoking SpiSlaveClient.read_write_done on the provided client. Either write_buffer or read_buffer may be None. If read_buffer is Some, the length of the operation is the minimum of the size of the two buffers.",60,{"inputs":[{"name":"self"},{"name":"option"},{"name":"option"},{"name":"usize"}],"output":{"name":"returncode"}}],[10,"set_polarity","","",60,{"inputs":[{"name":"self"},{"name":"clockpolarity"}],"output":null}],[10,"get_polarity","","",60,{"inputs":[{"name":"self"}],"output":{"name":"clockpolarity"}}],[10,"set_phase","","",60,{"inputs":[{"name":"self"},{"name":"clockphase"}],"output":null}],[10,"get_phase","","",60,{"inputs":[{"name":"self"}],"output":{"name":"clockphase"}}],[11,"clone","","",52,{"inputs":[{"name":"self"}],"output":{"name":"dataorder"}}],[11,"fmt","","",52,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",53,{"inputs":[{"name":"self"}],"output":{"name":"clockpolarity"}}],[11,"fmt","","",53,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",53,{"inputs":[{"name":"self"},{"name":"clockpolarity"}],"output":{"name":"bool"}}],[11,"clone","","",54,{"inputs":[{"name":"self"}],"output":{"name":"clockphase"}}],[11,"fmt","","",54,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",54,{"inputs":[{"name":"self"},{"name":"clockphase"}],"output":{"name":"bool"}}],[0,"uart","kernel::hil","Interfaces for UART communications.",null,null],[3,"UARTParams","kernel::hil::uart","",null,null],[12,"baud_rate","","",61,null],[12,"stop_bits","","",61,null],[12,"parity","","",61,null],[12,"hw_flow_control","","",61,null],[4,"StopBits","","",null,null],[13,"One","","",62,null],[13,"Two","","",62,null],[4,"Parity","","",null,null],[13,"None","","",63,null],[13,"Odd","","",63,null],[13,"Even","","",63,null],[4,"Error","","The type of error encountered during UART transaction.",null,null],[13,"ParityError","","Parity error during receive",64,null],[13,"FramingError","","Framing error during receive",64,null],[13,"OverrunError","","Overrun error during receive",64,null],[13,"RepeatCallError","","Repeat call of transmit or receive before initial command complete",64,null],[13,"ResetError","","UART hardware was reset",64,null],[13,"CommandComplete","","No error occurred and the command completed successfully",64,null],[8,"UART","","",null,null],[10,"set_client","","Set the client for this UART peripheral. The client will be called when events finish.",65,{"inputs":[{"name":"self"},{"name":"client"}],"output":null}],[10,"init","","Initialize UART",65,{"inputs":[{"name":"self"},{"name":"uartparams"}],"output":null}],[10,"transmit","","Transmit data.",65,null],[10,"receive","","Receive data until buffer is full.",65,null],[8,"UARTAdvanced","","",null,null],[10,"receive_automatic","","Receive data until `interbyte_timeout` bit periods have passed since the last byte or buffer is full. Does not timeout until at least one byte has been received.",66,null],[10,"receive_until_terminator","","Receive data until `terminator` data byte has been received or buffer is full",66,null],[8,"Client","","Implement Client to receive callbacks from UART.",null,null],[10,"transmit_complete","","UART transmit complete.",67,null],[10,"receive_complete","","UART receive complete.",67,null],[11,"clone","","",62,{"inputs":[{"name":"self"}],"output":{"name":"stopbits"}}],[11,"fmt","","",62,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",63,{"inputs":[{"name":"self"}],"output":{"name":"parity"}}],[11,"fmt","","",63,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",61,{"inputs":[{"name":"self"}],"output":{"name":"uartparams"}}],[11,"fmt","","",61,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",64,{"inputs":[{"name":"self"}],"output":{"name":"error"}}],[11,"eq","","",64,{"inputs":[{"name":"self"},{"name":"error"}],"output":{"name":"bool"}}],[0,"rng","kernel::hil","Interfaces for accessing a random number generator.",null,null],[4,"Continue","kernel::hil::rng","Denotes whether the Client wants to be notified when `More` randomness is available or if they are `Done`",null,null],[13,"More","","More randomness is required.",68,null],[13,"Done","","No more randomness required.",68,null],[8,"RNG","","Generic interface for a random number generator",null,null],[10,"get","","Initiate the aquisition of new random number generation.",69,{"inputs":[{"name":"self"}],"output":null}],[8,"Client","","An RNG client",null,null],[10,"randomness_available","","Called by the (RNG)[trait.RNG.html] when there are one or more random numbers available",70,{"inputs":[{"name":"self"},{"name":"iterator"}],"output":{"name":"continue"}}],[11,"fmt","","",68,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"assert_receiver_is_total_eq","","",68,null],[11,"eq","","",68,{"inputs":[{"name":"self"},{"name":"continue"}],"output":{"name":"bool"}}],[0,"adc","kernel::hil","Interfaces for analog to digital converter peripherals.",null,null],[8,"Adc","kernel::hil::adc","Simple interface for reading an ADC sample on any channel.",null,null],[16,"Channel","","The chip-dependent type of an ADC channel.",71,null],[10,"initialize","","Initialize must be called before taking a sample.",71,{"inputs":[{"name":"self"}],"output":{"name":"returncode"}}],[10,"sample","","Request a single ADC sample on a particular channel. Used for individual samples that have no timing requirements.",71,null],[10,"sample_continuous","","Request repeated ADC samples on a particular channel. Callbacks will occur at the given frequency with low jitter and can be set to any frequency supported by the chip implementation. However callbacks may be limited based on how quickly the system can service individual samples, leading to missed samples at high frequencies.",71,null],[10,"stop_sampling","","Stop a sampling operation. Can be used to stop any simple or high-speed sampling operation. No further callbacks will occur.",71,{"inputs":[{"name":"self"}],"output":{"name":"returncode"}}],[8,"Client","","Trait for handling callbacks from simple ADC calls.",null,null],[10,"sample_ready","","Called when a sample is ready.",72,{"inputs":[{"name":"self"},{"name":"u16"}],"output":null}],[8,"AdcHighSpeed","","Interface for continuously sampling at a given frequency on a channel. Requires the AdcSimple interface to have been implemented as well.",null,null],[10,"sample_highspeed","","Start sampling continuously into buffers. Samples are double-buffered, going first into `buffer1` and then into `buffer2`. A callback is performed to the client whenever either buffer is full, which expects either a second buffer to be sent via the `provide_buffer` call. Length fields correspond to the number of samples that should be collected in each buffer. If an error occurs, the buffers will be returned.",73,null],[10,"provide_buffer","","Provide a new buffer to fill with the ongoing `sample_continuous` configuration. Expected to be called in a `buffer_ready` callback. Note that if this is not called before the second buffer is filled, samples will be missed. Length field corresponds to the number of samples that should be collected in the buffer. If an error occurs, the buffer will be returned.",73,null],[10,"retrieve_buffers","","Reclaim ownership of buffers. Can only be called when the ADC is inactive, which occurs after a successful `stop_sampling`. Used to reclaim buffers after a sampling operation is complete. Returns success if the ADC was inactive, but there may still be no buffers that are `some` if the driver had already returned all buffers.",73,null],[8,"HighSpeedClient","","Trait for handling callbacks from high-speed ADC calls.",null,null],[10,"samples_ready","","Called when a buffer is full. The length provided will always be less than or equal to the length of the buffer. Expects an additional call to either provide another buffer or stop sampling",74,null],[0,"flash","kernel::hil","Interface for reading, writing, and erasing flash storage pages.",null,null],[4,"Error","kernel::hil::flash","Flash errors returned in the callbacks.",null,null],[13,"CommandComplete","","Success.",75,null],[13,"FlashError","","An error occurred during the flash operation.",75,null],[8,"HasClient","","",null,null],[10,"set_client","","Set the client for this flash peripheral. The client will be called when operations complete.",76,{"inputs":[{"name":"self"},{"name":"c"}],"output":null}],[8,"Flash","","A page of writable persistent flash memory.",null,null],[16,"Page","","Type of a single flash page for the given implementation.",77,null],[10,"read_page","","Read a page of flash into the buffer.",77,null],[10,"write_page","","Write a page of flash from the buffer.",77,null],[10,"erase_page","","Erase a page of flash.",77,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"returncode"}}],[8,"Client","","Implement `Client` to receive callbacks from `Flash`.",null,null],[10,"read_complete","","Flash read complete.",78,null],[10,"write_complete","","Flash write complete.",78,null],[10,"erase_complete","","Flash erase complete.",78,{"inputs":[{"name":"self"},{"name":"error"}],"output":null}],[11,"clone","","",75,{"inputs":[{"name":"self"}],"output":{"name":"error"}}],[11,"fmt","","",75,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"assert_receiver_is_total_eq","","",75,null],[11,"eq","","",75,{"inputs":[{"name":"self"},{"name":"error"}],"output":{"name":"bool"}}],[0,"watchdog","kernel::hil","Interface for a watchdog timer.",null,null],[8,"Watchdog","kernel::hil::watchdog","",null,null],[10,"start","","Enable the watchdog timer. Period is the time in milliseconds the watchdog will timeout if not serviced.",79,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[10,"stop","","Disable the watchdog timer.",79,{"inputs":[{"name":"self"}],"output":null}],[10,"tickle","","Service the watchdog to let the hardware know the application is still executing.",79,{"inputs":[{"name":"self"}],"output":null}],[0,"radio","kernel::hil","Interface for sending and receiving IEEE 802.15.4 packets.",null,null],[3,"Header","kernel::hil::radio","",null,null],[12,"len","","",80,null],[12,"fcf","","",80,null],[12,"dsn","","",80,null],[12,"pan","","",80,null],[12,"src","","",80,null],[12,"dst","","",80,null],[4,"RadioMacLen","","",null,null],[13,"ZERO","","",81,null],[13,"FOUR","","",81,null],[13,"EIGHT","","",81,null],[13,"SIXTEEN","","",81,null],[17,"MIN_MHR_SIZE","","These constants are used for interacting with the SPI buffer, which contains a 1-byte SPI command, a 1-byte PHY header, and then the 802.15.4 frame. In theory, the number of extra bytes in front of the frame can depend on the particular method used to communicate with the radio, but we leave this as a constant in this generic trait for now.",null,null],[17,"MFR_SIZE","","",null,null],[17,"MAX_MTU","","",null,null],[17,"MIN_FRAME_SIZE","","",null,null],[17,"MAX_FRAME_SIZE","","",null,null],[17,"PSDU_OFFSET","","",null,null],[17,"MAX_BUF_SIZE","","",null,null],[17,"MIN_PAYLOAD_OFFSET","","",null,null],[8,"TxClient","","",null,null],[10,"send_done","","",82,null],[8,"RxClient","","",null,null],[10,"receive","","",83,null],[8,"ConfigClient","","",null,null],[10,"config_done","","",84,{"inputs":[{"name":"self"},{"name":"returncode"}],"output":null}],[8,"PowerClient","","",null,null],[10,"changed","","",85,{"inputs":[{"name":"self"},{"name":"bool"}],"output":null}],[8,"Radio","","",null,null],[8,"RadioConfig","","Configure the 802.15.4 radio.",null,null],[10,"initialize","","buf must be at least MAX_BUF_SIZE in length, and reg_read and reg_write must be 2 bytes.",86,null],[10,"reset","","",86,{"inputs":[{"name":"self"}],"output":{"name":"returncode"}}],[10,"start","","",86,{"inputs":[{"name":"self"}],"output":{"name":"returncode"}}],[10,"stop","","",86,{"inputs":[{"name":"self"}],"output":{"name":"returncode"}}],[10,"is_on","","",86,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[10,"busy","","",86,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[10,"set_power_client","","",86,{"inputs":[{"name":"self"},{"name":"powerclient"}],"output":null}],[10,"config_commit","","Commit the config calls to hardware, changing the address, PAN ID, TX power, and channel to the specified values, issues a callback to the config client when done.",86,{"inputs":[{"name":"self"}],"output":{"name":"returncode"}}],[10,"set_config_client","","",86,{"inputs":[{"name":"self"},{"name":"configclient"}],"output":null}],[10,"config_address","","",86,{"inputs":[{"name":"self"}],"output":{"name":"u16"}}],[10,"config_address_long","","",86,null],[10,"config_pan","","",86,{"inputs":[{"name":"self"}],"output":{"name":"u16"}}],[10,"config_tx_power","","",86,{"inputs":[{"name":"self"}],"output":{"name":"i8"}}],[10,"config_channel","","",86,{"inputs":[{"name":"self"}],"output":{"name":"u8"}}],[10,"config_set_address","","",86,{"inputs":[{"name":"self"},{"name":"u16"}],"output":null}],[10,"config_set_address_long","","",86,null],[10,"config_set_pan","","",86,{"inputs":[{"name":"self"},{"name":"u16"}],"output":null}],[10,"config_set_tx_power","","",86,{"inputs":[{"name":"self"},{"name":"i8"}],"output":{"name":"returncode"}}],[10,"config_set_channel","","",86,{"inputs":[{"name":"self"},{"name":"u8"}],"output":{"name":"returncode"}}],[8,"RadioData","","",null,null],[10,"payload_offset","","",87,{"inputs":[{"name":"self"},{"name":"bool"},{"name":"bool"}],"output":{"name":"u8"}}],[10,"header_size","","",87,{"inputs":[{"name":"self"},{"name":"bool"},{"name":"bool"}],"output":{"name":"u8"}}],[10,"packet_payload_offset","","",87,null],[10,"packet_header_size","","",87,null],[10,"packet_get_src","","",87,null],[10,"packet_get_dest","","",87,null],[10,"packet_get_src_long","","",87,null],[10,"packet_get_dest_long","","",87,null],[10,"packet_get_length","","",87,null],[10,"packet_get_pan","","",87,null],[10,"packet_has_src_long","","",87,null],[10,"packet_has_dest_long","","",87,null],[10,"set_transmit_client","","",87,{"inputs":[{"name":"self"},{"name":"txclient"}],"output":null}],[10,"set_receive_client","","",87,null],[10,"set_receive_buffer","","",87,null],[10,"transmit","","",87,null],[10,"transmit_long","","",87,null],[8,"RadioCrypto","","",null,null],[10,"set_encrypt_key","","",88,{"inputs":[{"name":"self"},{"name":"c"}],"output":null}],[10,"set_decrypt_key","","",88,{"inputs":[{"name":"self"},{"name":"c"}],"output":null}],[10,"set_mac_key","","",88,{"inputs":[{"name":"self"},{"name":"i"}],"output":null}],[10,"set_mac_check_key","","",88,{"inputs":[{"name":"self"},{"name":"i"}],"output":null}],[10,"set_encrypt","","",88,{"inputs":[{"name":"self"},{"name":"bool"}],"output":null}],[10,"set_mac","","",88,{"inputs":[{"name":"self"},{"name":"radiomaclen"}],"output":null}],[0,"temperature","kernel::hil","Interface for sampling a temperature sensor.",null,null],[8,"TemperatureDriver","kernel::hil::temperature","",null,null],[10,"take_measurement","","",89,{"inputs":[{"name":"self"}],"output":null}],[8,"Client","","",null,null],[10,"measurement_done","","",90,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"returncode"}}],[0,"crc","kernel::hil","Interface for CRC computation.",null,null],[4,"CrcAlg","kernel::hil::crc","CRC algorithms",null,null],[13,"Crc32","","Polynomial 0x04C11DB7, output reversed then inverted (\"CRC-32\")",91,null],[13,"Crc32C","","Polynomial 0x1EDC6F41, output reversed then inverted (\"CRC-32C\" / \"Castagnoli\")",91,null],[13,"Sam4L16","","Polynomial 0x1021, no output post-processing",91,null],[13,"Sam4L32","","Polynomial 0x04C11DB7, no output post-processing",91,null],[13,"Sam4L32C","","Polynomial 0x1EDC6F41, no output post-processing",91,null],[8,"CRC","","",null,null],[10,"get_version","","Get the version of the CRC unit",92,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[10,"compute","","Initiate a CRC calculation",92,null],[10,"disable","","Disable the CRC unit until compute() is next called",92,{"inputs":[{"name":"self"}],"output":null}],[8,"Client","","",null,null],[10,"receive_result","","Receive the successful result of a CRC calculation",93,{"inputs":[{"name":"self"},{"name":"u32"}],"output":null}],[11,"clone","","",91,{"inputs":[{"name":"self"}],"output":{"name":"crcalg"}}],[0,"symmetric_encryption","kernel::hil","Interfaces for accessing encryption and decryption of symmetric ciphers.",null,null],[8,"SymmetricEncryption","kernel::hil::symmetric_encryption","",null,null],[10,"set_client","","Set the callback client.",94,{"inputs":[{"name":"self"},{"name":"client"}],"output":null}],[10,"init","","Initialization of the chip register",94,{"inputs":[{"name":"self"}],"output":null}],[10,"set_key","","Configure encryption/decryption key assumes that key size is 16, 24 or 32 bytes",94,null],[10,"aes128_crypt_ctr","","encryption and decryption for aes in counter mode because only the encryption-mode of the cipher only one method is needed other chips perhaps only ignore \"init_ctr\" and assume all is performed in HW",94,null],[8,"Client","","",null,null],[10,"crypt_done","","send back to result of the encryption/decryption to the capsule this should be hardware independent if the cryptostate is used for all implementations",95,null],[0,"ninedof","kernel::hil","Interface for chips that provide 9DOF functionality.",null,null],[8,"NineDof","kernel::hil::ninedof","A basic interface for a 9-DOF compatible chip. Not all functions must be implemented if not all features are supported (for instance some chips may not include a gyroscope).",null,null],[10,"set_client","","Set the client to be notified when the capsule has data ready or has finished some command. This is likely called in a board's main.rs and is set to the virtual_ninedof.rs driver.",96,{"inputs":[{"name":"self"},{"name":"ninedofclient"}],"output":null}],[11,"read_accelerometer","","Get a single instantaneous reading of the acceleration in the X,Y,Z directions.",96,{"inputs":[{"name":"self"}],"output":{"name":"returncode"}}],[11,"read_magnetometer","","Get a single instantaneous reading from the magnetometer in all three directions.",96,{"inputs":[{"name":"self"}],"output":{"name":"returncode"}}],[11,"read_gyroscope","","Get a single instantaneous reading from the gyroscope of the rotation around all three axes.",96,{"inputs":[{"name":"self"}],"output":{"name":"returncode"}}],[8,"NineDofClient","","Client for receiving done events from the chip.",null,null],[10,"callback","","Signals a command has finished. The arguments will most likely be passed over the syscall interface to an application.",97,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"usize"},{"name":"usize"}],"output":null}],[0,"gpio_async","kernel::hil","Interface for GPIO pins that require split-phase operation to control.",null,null],[8,"Port","kernel::hil::gpio_async","Interface for banks of asynchronous GPIO pins. GPIO pins are asynchronous when there is an asynchronous interface used to control them. The most common example is when using a GPIO extender on an I2C or SPI bus. With asynchronous GPIO functions, every config action results in an eventual callback function that indicates that the configuration has finished (unless the initial function call returns an error code, then no callback will be generated).",null,null],[10,"disable","","Try to disable a GPIO pin. This cannot be supported for all devices.",98,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"returncode"}}],[10,"make_output","","Configure a pin as an ouput GPIO.",98,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"returncode"}}],[10,"make_input","","Configure a pin as an input GPIO. Not all InputMode settings may be supported by a given device.",98,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"inputmode"}],"output":{"name":"returncode"}}],[10,"read","","Get the state (0 or 1) of an input pin. The value will be returned via a callback.",98,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"returncode"}}],[10,"toggle","","Toggle an output GPIO pin.",98,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"returncode"}}],[10,"set","","Assert a GPIO pin high.",98,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"returncode"}}],[10,"clear","","Clear a GPIO pin low.",98,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"returncode"}}],[10,"enable_interrupt","","Setup an interrupt on a GPIO input pin. The identifier should be the port number and will be returned when the interrupt callback fires.",98,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"interruptmode"},{"name":"usize"}],"output":{"name":"returncode"}}],[10,"disable_interrupt","","Disable an interrupt on a GPIO input pin.",98,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"returncode"}}],[8,"Client","","The gpio_async Client interface is used to both receive callbacks when a configuration command finishes and to handle interrupt events from pins with interrupts enabled.",null,null],[10,"fired","","Called when an interrupt occurs. The pin that interrupted is included, and the identifier that was passed with the call to `enable_interrupt` is also returned.",99,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"usize"}],"output":null}],[10,"done","","Done is called when a configuration command finishes.",99,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[0,"dac","kernel::hil","Interface for digital to analog converters.",null,null],[8,"DacChannel","kernel::hil::dac","Simple interface for using the DAC.",null,null],[10,"initialize","","Initialize and enable the DAC.",100,{"inputs":[{"name":"self"}],"output":{"name":"returncode"}}],[10,"set_value","","Set the DAC output value.",100,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"returncode"}}],[0,"nonvolatile_storage","kernel::hil","Generic interface for nonvolatile memory.",null,null],[8,"NonvolatileStorage","kernel::hil::nonvolatile_storage","Simple interface for reading and writing nonvolatile memory. It is expected that drivers for nonvolatile memory would implement this trait.",null,null],[10,"set_client","","",101,{"inputs":[{"name":"self"},{"name":"nonvolatilestorageclient"}],"output":null}],[10,"read","","Read `length` bytes starting at address `address` in to the provided buffer. The buffer must be at least `length` bytes long. The address must be in the address space of the physical storage.",101,null],[10,"write","","Write `length` bytes starting at address `address` from the provided buffer. The buffer must be at least `length` bytes long. This address must be in the address space of the physical storage.",101,null],[8,"NonvolatileStorageClient","","Client interface for nonvolatile storage.",null,null],[10,"read_done","","`read_done` is called when the implementor is finished reading in to the buffer. The callback returns the buffer and the number of bytes that were actually read.",102,null],[10,"write_done","","`write_done` is called when the implementor is finished writing from the buffer. The callback returns the buffer and the number of bytes that were actually written.",102,null],[8,"Controller","kernel::hil","Shared interface for configuring components.",null,null],[16,"Config","","",103,null],[10,"configure","","",103,null],[0,"process","kernel","Support for creating and running userspace applications.",null,null],[3,"FunctionCall","kernel::process","",null,null],[12,"r0","","",104,null],[12,"r1","","",104,null],[12,"r2","","",104,null],[12,"r3","","",104,null],[12,"pc","","",104,null],[3,"LoadInfo","","",null,null],[12,"version","","",105,null],[12,"total_size","","",105,null],[12,"entry_offset","","",105,null],[12,"rel_data_offset","","",105,null],[12,"rel_data_size","","",105,null],[12,"text_offset","","",105,null],[12,"text_size","","",105,null],[12,"got_offset","","",105,null],[12,"got_size","","",105,null],[12,"data_offset","","",105,null],[12,"data_size","","",105,null],[12,"bss_mem_offset","","",105,null],[12,"bss_size","","",105,null],[12,"min_stack_len","","",105,null],[12,"min_app_heap_len","","",105,null],[12,"min_kernel_heap_len","","",105,null],[12,"pkg_name_offset","","",105,null],[12,"pkg_name_size","","",105,null],[12,"checksum","","",105,null],[3,"StoredRegs","","",null,null],[12,"r4","","",106,null],[12,"r5","","",106,null],[12,"r6","","",106,null],[12,"r7","","",106,null],[12,"r8","","",106,null],[12,"r9","","",106,null],[12,"r10","","",106,null],[12,"r11","","",106,null],[3,"Process","","",null,null],[12,"memory","","Application memory layout:",107,null],[12,"kernel_memory_break","","",107,null],[12,"app_heap_break","","",107,null],[12,"app_heap_start","","",107,null],[12,"stack_data_boundary","","",107,null],[12,"cur_stack","","",107,null],[12,"min_stack_pointer","","How low have we ever seen the stack pointer",107,null],[12,"syscall_count","","How many syscalls have occurred since the process started",107,null],[12,"last_syscall","","What was the most recent syscall",107,null],[12,"text","","Process text segment",107,null],[12,"stored_regs","","",107,null],[12,"yield_pc","","",107,null],[12,"psr","","",107,null],[12,"state","","",107,null],[12,"fault_response","","How to deal with Faults occuring in the process",107,null],[12,"mpu_regions","","MPU regions are saved as a pointer-size pair.",107,null],[12,"tasks","","",107,null],[12,"package_name","","",107,null],[3,"LoadResult","","",null,null],[12,"init_fn","","The absolute address of the process entry point (i.e. `_start`).",108,null],[12,"app_heap_start","","The lowest free address in process memory after allocating space for the stack, loading the GOT, data and BSS",108,null],[12,"stack_data_boundary","","The initial stack pointer",108,null],[12,"fixed_len","","The length of the fixed segment, including the stack, GOT, .data, / BSS, and any necessary alignment",108,null],[12,"package_name","","The process's package name (used for IPC)",108,null],[4,"Error","","",null,null],[13,"NoSuchApp","","",109,null],[13,"OutOfMemory","","",109,null],[13,"AddressOutOfBounds","","",109,null],[4,"State","","",null,null],[13,"Running","","",110,null],[13,"Yielded","","",110,null],[13,"Fault","","",110,null],[4,"FaultResponse","","",null,null],[13,"Panic","","",111,null],[13,"Restart","","",111,null],[4,"IPCType","","",null,null],[13,"Service","","",112,null],[13,"Client","","",112,null],[4,"Task","","",null,null],[13,"FunctionCall","","",113,null],[13,"IPC","","",113,null],[5,"load_processes","","Helper function to load processes from flash into an array of active processes. This is the default template for loading processes, but a board is able to create its own `load_processes()` function and use that instead.",null,null],[5,"schedule","","",null,{"inputs":[{"name":"functioncall"},{"name":"appid"}],"output":{"name":"bool"}}],[5,"parse_and_validate_load_info","","Converts a pointer to memory to a LoadInfo struct",null,null],[5,"processes_blocked","","",null,{"inputs":[],"output":{"name":"bool"}}],[5,"ipsr_isr_number_to_str","","",null,{"inputs":[{"name":"usize"}],"output":{"name":"str"}}],[5,"load","","Loads the process into memory",null,null],[5,"switch_to_user","","",null,null],[7,"SYSCALL_FIRED","","",null,null],[7,"APP_FAULT","","",null,null],[7,"SCB_REGISTERS","","",null,null],[7,"PROCS","","",null,null],[7,"HAVE_WORK","","",null,null],[11,"clone","","",109,{"inputs":[{"name":"self"}],"output":{"name":"error"}}],[11,"fmt","","",109,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"assert_receiver_is_total_eq","","",109,null],[11,"eq","","",109,{"inputs":[{"name":"self"},{"name":"error"}],"output":{"name":"bool"}}],[11,"clone","","",110,{"inputs":[{"name":"self"}],"output":{"name":"state"}}],[11,"fmt","","",110,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"assert_receiver_is_total_eq","","",110,null],[11,"eq","","",110,{"inputs":[{"name":"self"},{"name":"state"}],"output":{"name":"bool"}}],[11,"clone","","",111,{"inputs":[{"name":"self"}],"output":{"name":"faultresponse"}}],[11,"fmt","","",111,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"assert_receiver_is_total_eq","","",111,null],[11,"eq","","",111,{"inputs":[{"name":"self"},{"name":"faultresponse"}],"output":{"name":"bool"}}],[11,"clone","","",112,{"inputs":[{"name":"self"}],"output":{"name":"ipctype"}}],[11,"fmt","","",112,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",113,{"inputs":[{"name":"self"}],"output":{"name":"task"}}],[11,"fmt","","",113,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",104,{"inputs":[{"name":"self"}],"output":{"name":"functioncall"}}],[11,"fmt","","",104,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",105,{"inputs":[{"name":"self"}],"output":{"name":"loadinfo"}}],[11,"fmt","","",105,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"default","","",106,{"inputs":[],"output":{"name":"storedregs"}}],[11,"schedule_ipc","","",107,{"inputs":[{"name":"self"},{"name":"appid"},{"name":"ipctype"}],"output":null}],[11,"current_state","","",107,{"inputs":[{"name":"self"}],"output":{"name":"state"}}],[11,"yield_state","","",107,{"inputs":[{"name":"self"}],"output":null}],[11,"fault_state","","",107,{"inputs":[{"name":"self"}],"output":null}],[11,"dequeue_task","","",107,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"mem_start","","",107,null],[11,"mem_end","","",107,null],[11,"flash_start","","",107,null],[11,"flash_end","","",107,null],[11,"kernel_memory_break","","",107,null],[11,"setup_mpu","","",107,{"inputs":[{"name":"self"},{"name":"mpu"}],"output":null}],[11,"add_mpu_region","","",107,null],[11,"create","","",107,null],[11,"sbrk","","",107,{"inputs":[{"name":"self"},{"name":"isize"}],"output":{"name":"result"}}],[11,"brk","","",107,null],[11,"in_exposed_bounds","","",107,null],[11,"alloc","","",107,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}],[11,"free","","",107,null],[11,"container_ptr","","",107,null],[11,"container_for","","",107,null],[11,"container_for_or_alloc","","",107,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}],[11,"pop_syscall_stack","","",107,{"inputs":[{"name":"self"}],"output":null}],[11,"push_function_call","","Context switch to the process.",107,{"inputs":[{"name":"self"},{"name":"functioncall"}],"output":null}],[11,"app_fault","","",107,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"syscall_fired","","",107,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"switch_to","","Context switch to the process.",107,{"inputs":[{"name":"self"}],"output":null}],[11,"svc_number","","",107,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"incr_syscall_count","","",107,{"inputs":[{"name":"self"}],"output":null}],[11,"sp","","",107,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"lr","","",107,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"pc","","",107,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"r0","","",107,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"set_return_code","","",107,{"inputs":[{"name":"self"},{"name":"returncode"}],"output":null}],[11,"set_r0","","",107,{"inputs":[{"name":"self"},{"name":"isize"}],"output":null}],[11,"r1","","",107,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"r2","","",107,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"r3","","",107,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"r12","","",107,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"xpsr","","",107,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"fault_str","","",107,{"inputs":[{"name":"self"},{"name":"w"}],"output":null}],[11,"statistics_str","","",107,{"inputs":[{"name":"self"},{"name":"w"}],"output":null}],[11,"fmt","","",108,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[0,"support","kernel","A bare-metal library supplying functions rustc may lower code to.",null,null],[5,"nop","kernel::support","NOP instruction",null,{"inputs":[],"output":null}],[5,"wfi","","WFI instruction",null,{"inputs":[],"output":null}],[5,"atomic","","",null,{"inputs":[{"name":"f"}],"output":{"name":"r"}}],[5,"eh_personality","","",null,{"inputs":[],"output":null}],[0,"arm","","",null,null],[5,"nop","kernel::support::arm","NOP instruction",null,{"inputs":[],"output":null}],[5,"wfi","","WFI instruction",null,{"inputs":[],"output":null}],[5,"atomic","","",null,{"inputs":[{"name":"f"}],"output":{"name":"r"}}],[5,"eh_personality","","",null,{"inputs":[],"output":null}],[0,"sched","kernel","Tock core scheduler.",null,null],[5,"do_process","kernel::sched","",null,{"inputs":[{"name":"p"},{"name":"c"},{"name":"process"},{"name":"appid"},{"name":"ipc"}],"output":null}],[0,"syscall","kernel","Tock syscall number definitions.",null,null],[4,"Syscall","kernel::syscall","The syscall number assignments.",null,null],[13,"YIELD","","Return to the kernel to allow other processes to execute or to wait for interrupts and callbacks.",114,null],[13,"SUBSCRIBE","","Pass a callback function to the kernel.",114,null],[13,"COMMAND","","Instruct the kernel or a capsule to perform an operation.",114,null],[13,"ALLOW","","Share a memory buffer with the kernel.",114,null],[13,"MEMOP","","Various memory operations.",114,null],[11,"clone","","",114,{"inputs":[{"name":"self"}],"output":{"name":"syscall"}}],[11,"fmt","","",114,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[0,"platform","kernel","",null,null],[0,"mpu","kernel::platform","Interface for configuring the Memory Protection Unit.",null,null],[3,"Region","kernel::platform::mpu","",null,null],[12,"base_address","","",115,null],[12,"attributes","","",115,null],[4,"AccessPermission","","",null,null],[13,"NoAccess","","",116,null],[13,"PrivilegedOnly","","",116,null],[13,"UnprivilegedReadOnly","","",116,null],[13,"ReadWrite","","",116,null],[13,"Reserved","","",116,null],[13,"PrivilegedOnlyReadOnly","","",116,null],[13,"ReadOnly","","",116,null],[13,"ReadOnlyAlias","","",116,null],[4,"ExecutePermission","","",null,null],[13,"ExecutionPermitted","","",117,null],[13,"ExecutionNotPermitted","","",117,null],[8,"MPU","","",null,null],[10,"enable_mpu","","Enable the MPU.",118,{"inputs":[{"name":"self"}],"output":null}],[10,"disable_mpu","","Completely disable the MPU.",118,{"inputs":[{"name":"self"}],"output":null}],[10,"create_region","","Creates a new MPU-specific memory protection region",118,{"inputs":[{"name":"usize"},{"name":"usize"},{"name":"usize"},{"name":"executepermission"},{"name":"accesspermission"}],"output":{"name":"option"}}],[10,"set_mpu","","Sets the base address, size and access attributes of the given MPU region number.",118,{"inputs":[{"name":"self"},{"name":"region"}],"output":null}],[11,"fmt","","",116,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",117,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","",115,{"inputs":[{"name":"u32"},{"name":"u32"}],"output":{"name":"region"}}],[11,"empty","","",115,{"inputs":[{"name":"usize"}],"output":{"name":"region"}}],[11,"base_address","","",115,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"attributes","","",115,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[0,"systick","kernel::platform","Interface and default implementation for the system tick timer.",null,null],[8,"SysTick","kernel::platform::systick","Interface for the system tick timer.",null,null],[10,"set_timer","","Sets the timer as close as possible to the given interval in microseconds.  The clock is 24-bits wide and specific timing is dependent on the driving clock. Increments of 10ms are most accurate and, in practice 466ms is the approximate maximum.",119,{"inputs":[{"name":"self"},{"name":"u32"}],"output":null}],[10,"value","","Returns the time left in approximate microseconds",119,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[10,"overflowed","","",119,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[10,"reset","","",119,{"inputs":[{"name":"self"}],"output":null}],[10,"enable","","",119,{"inputs":[{"name":"self"},{"name":"bool"}],"output":null}],[10,"overflow_fired","","",119,{"inputs":[],"output":{"name":"bool"}}],[8,"Platform","kernel::platform","Interface for individual boards.",null,null],[10,"with_driver","","",120,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"f"}],"output":{"name":"r"}}],[8,"Chip","","Interface for individual MCUs.",null,null],[16,"MPU","","",121,null],[16,"SysTick","","",121,null],[10,"service_pending_interrupts","","",121,{"inputs":[{"name":"self"}],"output":null}],[10,"has_pending_interrupts","","",121,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[10,"mpu","","",121,null],[10,"systick","","",121,null],[11,"prepare_for_sleep","","",121,{"inputs":[{"name":"self"}],"output":null}],[0,"mpu","kernel","Interface for configuring the Memory Protection Unit.",null,null],[3,"Region","kernel::mpu","",null,null],[12,"base_address","","",115,null],[12,"attributes","","",115,null],[4,"AccessPermission","","",null,null],[13,"NoAccess","","",116,null],[13,"PrivilegedOnly","","",116,null],[13,"UnprivilegedReadOnly","","",116,null],[13,"ReadWrite","","",116,null],[13,"Reserved","","",116,null],[13,"PrivilegedOnlyReadOnly","","",116,null],[13,"ReadOnly","","",116,null],[13,"ReadOnlyAlias","","",116,null],[4,"ExecutePermission","","",null,null],[13,"ExecutionPermitted","","",117,null],[13,"ExecutionNotPermitted","","",117,null],[8,"MPU","","",null,null],[10,"enable_mpu","","Enable the MPU.",118,{"inputs":[{"name":"self"}],"output":null}],[10,"disable_mpu","","Completely disable the MPU.",118,{"inputs":[{"name":"self"}],"output":null}],[10,"create_region","","Creates a new MPU-specific memory protection region",118,{"inputs":[{"name":"usize"},{"name":"usize"},{"name":"usize"},{"name":"executepermission"},{"name":"accesspermission"}],"output":{"name":"option"}}],[10,"set_mpu","","Sets the base address, size and access attributes of the given MPU region number.",118,{"inputs":[{"name":"self"},{"name":"region"}],"output":null}],[0,"systick","kernel","Interface and default implementation for the system tick timer.",null,null],[8,"SysTick","kernel::systick","Interface for the system tick timer.",null,null],[10,"set_timer","","Sets the timer as close as possible to the given interval in microseconds.  The clock is 24-bits wide and specific timing is dependent on the driving clock. Increments of 10ms are most accurate and, in practice 466ms is the approximate maximum.",119,{"inputs":[{"name":"self"},{"name":"u32"}],"output":null}],[10,"value","","Returns the time left in approximate microseconds",119,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[10,"overflowed","","",119,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[10,"reset","","",119,{"inputs":[{"name":"self"}],"output":null}],[10,"enable","","",119,{"inputs":[{"name":"self"},{"name":"bool"}],"output":null}],[10,"overflow_fired","","",119,{"inputs":[],"output":{"name":"bool"}}],[8,"Chip","kernel","Interface for individual MCUs.",null,null],[16,"MPU","","",121,null],[16,"SysTick","","",121,null],[10,"service_pending_interrupts","","",121,{"inputs":[{"name":"self"}],"output":null}],[10,"has_pending_interrupts","","",121,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[10,"mpu","","",121,null],[10,"systick","","",121,null],[11,"prepare_for_sleep","kernel::platform","",121,{"inputs":[{"name":"self"}],"output":null}],[8,"Platform","kernel","Interface for individual boards.",null,null],[10,"with_driver","","",120,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"f"}],"output":{"name":"r"}}],[8,"SysTick","","Interface for the system tick timer.",null,null],[10,"set_timer","","Sets the timer as close as possible to the given interval in microseconds.  The clock is 24-bits wide and specific timing is dependent on the driving clock. Increments of 10ms are most accurate and, in practice 466ms is the approximate maximum.",119,{"inputs":[{"name":"self"},{"name":"u32"}],"output":null}],[10,"value","","Returns the time left in approximate microseconds",119,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[10,"overflowed","","",119,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[10,"reset","","",119,{"inputs":[{"name":"self"}],"output":null}],[10,"enable","","",119,{"inputs":[{"name":"self"},{"name":"bool"}],"output":null}],[10,"overflow_fired","","",119,{"inputs":[],"output":{"name":"bool"}}],[14,"static_init","","Allocates a global array of static size to initialize data structures.",null,null],[14,"debug","","In-kernel `printf()` debugging.",null,null]],"paths":[[3,"RingBuffer"],[8,"Queue"],[3,"TakeCell"],[3,"MapCell"],[3,"VolatileCell"],[3,"ListLink"],[3,"List"],[3,"ListIterator"],[8,"ListNode"],[3,"PowerOfTwo"],[3,"AppId"],[3,"Callback"],[4,"RustOrRawFnPtr"],[3,"Container"],[3,"AppliedContainer"],[3,"Allocator"],[3,"Owned"],[3,"Iter"],[3,"DebugWriter"],[8,"Debug"],[8,"Driver"],[3,"IPCData"],[3,"IPC"],[3,"AppPtr"],[3,"AppSlice"],[3,"Private"],[3,"Shared"],[4,"ReturnCode"],[3,"LedHigh"],[3,"LedLow"],[8,"Led"],[8,"Time"],[8,"Frequency"],[8,"Alarm"],[8,"Client"],[8,"Timer"],[3,"Freq32KHz"],[3,"Freq16KHz"],[3,"Freq1KHz"],[4,"InputMode"],[4,"InterruptMode"],[8,"PinCtl"],[8,"Pin"],[8,"Client"],[4,"Error"],[4,"SlaveTransmissionType"],[8,"I2CMaster"],[8,"I2CSlave"],[8,"I2CHwMasterClient"],[8,"I2CHwSlaveClient"],[8,"I2CDevice"],[8,"I2CClient"],[4,"DataOrder"],[4,"ClockPolarity"],[4,"ClockPhase"],[8,"SpiMasterClient"],[8,"SpiMaster"],[8,"SpiMasterDevice"],[8,"SpiSlaveClient"],[8,"SpiSlave"],[8,"SpiSlaveDevice"],[3,"UARTParams"],[4,"StopBits"],[4,"Parity"],[4,"Error"],[8,"UART"],[8,"UARTAdvanced"],[8,"Client"],[4,"Continue"],[8,"RNG"],[8,"Client"],[8,"Adc"],[8,"Client"],[8,"AdcHighSpeed"],[8,"HighSpeedClient"],[4,"Error"],[8,"HasClient"],[8,"Flash"],[8,"Client"],[8,"Watchdog"],[3,"Header"],[4,"RadioMacLen"],[8,"TxClient"],[8,"RxClient"],[8,"ConfigClient"],[8,"PowerClient"],[8,"RadioConfig"],[8,"RadioData"],[8,"RadioCrypto"],[8,"TemperatureDriver"],[8,"Client"],[4,"CrcAlg"],[8,"CRC"],[8,"Client"],[8,"SymmetricEncryption"],[8,"Client"],[8,"NineDof"],[8,"NineDofClient"],[8,"Port"],[8,"Client"],[8,"DacChannel"],[8,"NonvolatileStorage"],[8,"NonvolatileStorageClient"],[8,"Controller"],[3,"FunctionCall"],[3,"LoadInfo"],[3,"StoredRegs"],[3,"Process"],[3,"LoadResult"],[4,"Error"],[4,"State"],[4,"FaultResponse"],[4,"IPCType"],[4,"Task"],[4,"Syscall"],[3,"Region"],[4,"AccessPermission"],[4,"ExecutePermission"],[8,"MPU"],[8,"SysTick"],[8,"Platform"],[8,"Chip"]]};
searchIndex["sam4l"] = {"doc":"Peripheral implementations for the SAM4L MCU.","items":[[5,"unhandled_interrupt","sam4l","",null,{"inputs":[],"output":null}],[5,"init","","",null,{"inputs":[],"output":null}],[5,"hard_fault_handler","","",null,{"inputs":[],"output":null}],[5,"_estack","","",null,null],[5,"reset_handler","","",null,null],[5,"SVC_Handler","","",null,null],[5,"systick_handler","","",null,null],[5,"generic_isr","","",null,null],[7,"_szero","","",null,null],[7,"_ezero","","",null,null],[7,"_etext","","",null,null],[7,"_srelocate","","",null,null],[7,"_erelocate","","",null,null],[0,"helpers","","",null,null],[0,"chip","","Interrupt mapping and DMA channel setup.",null,null],[3,"Sam4l","sam4l::chip","",null,null],[12,"mpu","","",0,null],[12,"systick","","",0,null],[7,"IQ_BUF","","",null,null],[7,"INTERRUPT_QUEUE","","",null,null],[17,"IQ_SIZE","","",null,null],[11,"new","","",0,{"inputs":[],"output":{"name":"sam4l"}}],[11,"service_pending_interrupts","","",0,{"inputs":[{"name":"self"}],"output":null}],[11,"has_pending_interrupts","","",0,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"mpu","","",0,{"inputs":[{"name":"self"}],"output":{"name":"mpu"}}],[11,"systick","","",0,{"inputs":[{"name":"self"}],"output":{"name":"systick"}}],[11,"prepare_for_sleep","","",0,{"inputs":[{"name":"self"}],"output":null}],[0,"ast","sam4l","Implementation of a single hardware timer.",null,null],[3,"AstRegisters","sam4l::ast","",null,null],[12,"cr","","",1,null],[12,"cv","","",1,null],[12,"sr","","",1,null],[12,"scr","","",1,null],[12,"ier","","",1,null],[12,"idr","","",1,null],[12,"imr","","",1,null],[12,"wer","","",1,null],[12,"ar0","","",1,null],[12,"ar1","","",1,null],[12,"_reserved0","","",1,null],[12,"pir0","","",1,null],[12,"pir1","","",1,null],[12,"_reserved1","","",1,null],[12,"clock","","",1,null],[12,"dtr","","",1,null],[12,"eve","","",1,null],[12,"evd","","",1,null],[12,"evm","","",1,null],[12,"calv","","",1,null],[3,"Ast","","",null,null],[12,"regs","","",2,null],[12,"callback","","",2,null],[4,"Clock","","",null,null],[13,"ClockRCSys","","",3,null],[13,"ClockOsc32","","",3,null],[13,"ClockAPB","","",3,null],[13,"ClockGclk2","","",3,null],[13,"Clock1K","","",3,null],[5,"ast_alarm_handler","","",null,{"inputs":[],"output":null}],[7,"AST","","",null,null],[17,"ALARM0_SYNC_TICS","","Minimum number of clock tics to make sure ALARM0 register is synchronized",null,null],[17,"AST_BASE","","",null,null],[11,"configure","","",2,{"inputs":[{"name":"self"},{"name":"client"}],"output":null}],[11,"clock_busy","","",2,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"set_client","","",2,{"inputs":[{"name":"self"},{"name":"client"}],"output":null}],[11,"busy","","",2,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"clear_alarm","","",2,{"inputs":[{"name":"self"}],"output":null}],[11,"clear_periodic","","",2,{"inputs":[{"name":"self"}],"output":null}],[11,"select_clock","","",2,{"inputs":[{"name":"self"},{"name":"clock"}],"output":null}],[11,"enable","","",2,{"inputs":[{"name":"self"}],"output":null}],[11,"is_enabled","","",2,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"disable","","",2,{"inputs":[{"name":"self"}],"output":null}],[11,"set_prescalar","","",2,{"inputs":[{"name":"self"},{"name":"u8"}],"output":null}],[11,"enable_alarm_irq","","",2,{"inputs":[{"name":"self"}],"output":null}],[11,"disable_alarm_irq","","",2,{"inputs":[{"name":"self"}],"output":null}],[11,"enable_ovf_irq","","",2,{"inputs":[{"name":"self"}],"output":null}],[11,"disable_ovf_irq","","",2,{"inputs":[{"name":"self"}],"output":null}],[11,"enable_periodic_irq","","",2,{"inputs":[{"name":"self"}],"output":null}],[11,"disable_periodic_irq","","",2,{"inputs":[{"name":"self"}],"output":null}],[11,"enable_alarm_wake","","",2,{"inputs":[{"name":"self"}],"output":null}],[11,"set_periodic_interval","","",2,{"inputs":[{"name":"self"},{"name":"u32"}],"output":null}],[11,"get_counter","","",2,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"set_counter","","",2,{"inputs":[{"name":"self"},{"name":"u32"}],"output":null}],[11,"handle_interrupt","","",2,{"inputs":[{"name":"self"}],"output":null}],[11,"disable","","",2,{"inputs":[{"name":"self"}],"output":null}],[11,"is_armed","","",2,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"now","","",2,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"set_alarm","","",2,{"inputs":[{"name":"self"},{"name":"u32"}],"output":null}],[11,"get_alarm","","",2,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[0,"bpm","sam4l","Implementation of the BPM peripheral.",null,null],[3,"BpmRegisters","sam4l::bpm","",null,null],[12,"interrupt_enable","","",4,null],[12,"interrupt_disable","","",4,null],[12,"interrupt_mask","","",4,null],[12,"interrupt_status","","",4,null],[12,"interrupt_clear","","",4,null],[12,"status","","",4,null],[12,"unlock","","",4,null],[12,"control","","",4,null],[12,"_reserved0","","",4,null],[12,"backup_wake_cause","","",4,null],[12,"backup_wake_enable","","",4,null],[12,"backup_pin_mux","","",4,null],[12,"io_retention","","",4,null],[4,"PowerScaling","","Which power scaling mode the chip should use for internal voltages",null,null],[13,"PS0","","Mode 0: Default out of reset - Maximum system clock frequency is 32MHz - Normal flash speed",5,null],[13,"PS1","","Mode 1: Reduced voltage - Maximum system clock frequency is 12MHz - Normal flash speed - These peripherals are not available in Mode 1:    - USB    - DFLL    - PLL    - Programming/Erasing Flash",5,null],[13,"PS2","","Mode 2: - Maximum system clock frequency is 48MHz - High speed flash",5,null],[4,"CK32Source","","",null,null],[13,"OSC32K","","",6,null],[13,"RC32K","","",6,null],[5,"set_ck32source","","",null,{"inputs":[{"name":"ck32source"}],"output":null}],[5,"unlock_register","","",null,{"inputs":[{"name":"u32"}],"output":null}],[5,"power_scaling_ok","","",null,{"inputs":[],"output":{"name":"bool"}}],[5,"set_power_scaling","","",null,{"inputs":[{"name":"powerscaling"}],"output":null}],[7,"BPM","","",null,null],[17,"BPM_BASE","","",null,null],[17,"BPM_UNLOCK_KEY","","",null,null],[0,"bscif","sam4l","Implementation of the Backup System Control Interface (BSCIF) peripheral.",null,null],[3,"BscifRegisters","sam4l::bscif","",null,null],[12,"ier","","",7,null],[12,"idr","","",7,null],[12,"imr","","",7,null],[12,"isr","","",7,null],[12,"icr","","",7,null],[12,"pclksr","","",7,null],[12,"unlock","","",7,null],[12,"cscr","","",7,null],[12,"oscctrl32","","",7,null],[12,"rc32kcr","","",7,null],[12,"rc32ktune","","",7,null],[12,"bod33ctrl","","",7,null],[12,"bod33level","","",7,null],[12,"bod33sampling","","",7,null],[12,"bod18ctrl","","",7,null],[12,"bot18level","","",7,null],[12,"bod18sampling","","",7,null],[12,"vregcr","","",7,null],[12,"_reserved1","","",7,null],[12,"rc1mcr","","",7,null],[12,"_reserved2","","",7,null],[12,"bgctrl","","",7,null],[12,"bgsr","","",7,null],[12,"_reserved3","","",7,null],[12,"br0","","",7,null],[12,"br1","","",7,null],[12,"br2","","",7,null],[12,"br3","","",7,null],[12,"_reserved4","","",7,null],[12,"brifbversion","","",7,null],[12,"bgrefifbversion","","",7,null],[12,"vregifgversion","","",7,null],[12,"bodifcversion","","",7,null],[12,"rc32kifbversion","","",7,null],[12,"osc32ifaversion","","",7,null],[12,"version","","",7,null],[5,"enable_rc32k","","Setup the internal 32kHz RC oscillator.",null,{"inputs":[],"output":null}],[7,"BSCIF","","",null,null],[17,"BSCIF_BASE","","",null,null],[0,"dma","sam4l","Implementation of the PDCA DMA peripheral.",null,null],[3,"DMARegisters","sam4l::dma","Memory registers for a DMA channel. Section 16.6.1 of the datasheet.",null,null],[12,"memory_address","","",8,null],[12,"peripheral_select","","",8,null],[12,"_peripheral_select_padding","","",8,null],[12,"transfer_counter","","",8,null],[12,"memory_address_reload","","",8,null],[12,"transfer_counter_reload","","",8,null],[12,"control","","",8,null],[12,"mode","","",8,null],[12,"status","","",8,null],[12,"interrupt_enable","","",8,null],[12,"interrupt_disable","","",8,null],[12,"interrupt_mask","","",8,null],[12,"interrupt_status","","",8,null],[12,"_unused","","",8,null],[3,"DMAChannel","","",null,null],[12,"registers","","",9,null],[12,"nvic","","",9,null],[12,"client","","",9,null],[12,"width","","",9,null],[12,"enabled","","",9,null],[12,"buffer","","",9,null],[4,"DMAChannelNum","","The DMA channel number. Each channel transfers data between memory and a particular peripheral function (e.g., SPI read or SPI write, but not both simultaneously). There are 16 available channels (Section 16.7).",null,null],[13,"DMAChannel00","","",10,null],[13,"DMAChannel01","","",10,null],[13,"DMAChannel02","","",10,null],[13,"DMAChannel03","","",10,null],[13,"DMAChannel04","","",10,null],[13,"DMAChannel05","","",10,null],[13,"DMAChannel06","","",10,null],[13,"DMAChannel07","","",10,null],[13,"DMAChannel08","","",10,null],[13,"DMAChannel09","","",10,null],[13,"DMAChannel10","","",10,null],[13,"DMAChannel11","","",10,null],[13,"DMAChannel12","","",10,null],[13,"DMAChannel13","","",10,null],[13,"DMAChannel14","","",10,null],[13,"DMAChannel15","","",10,null],[4,"DMAPeripheral","","The peripheral function a channel is assigned to (Section 16.7). `*_RX` means transfer data from peripheral to memory, `*_TX` means transfer data from memory to peripheral.",null,null],[13,"USART0_RX","","",11,null],[13,"USART1_RX","","",11,null],[13,"USART2_RX","","",11,null],[13,"USART3_RX","","",11,null],[13,"SPI_RX","","",11,null],[13,"TWIM0_RX","","",11,null],[13,"TWIM1_RX","","",11,null],[13,"TWIM2_RX","","",11,null],[13,"TWIM3_RX","","",11,null],[13,"TWIS0_RX","","",11,null],[13,"TWIS1_RX","","",11,null],[13,"ADCIFE_RX","","",11,null],[13,"CATB_RX","","",11,null],[13,"IISC_CH0_RX","","",11,null],[13,"IISC_CH1_RX","","",11,null],[13,"PARC_RX","","",11,null],[13,"AESA_RX","","",11,null],[13,"USART0_TX","","",11,null],[13,"USART1_TX","","",11,null],[13,"USART2_TX","","",11,null],[13,"USART3_TX","","",11,null],[13,"SPI_TX","","",11,null],[13,"TWIM0_TX","","",11,null],[13,"TWIM1_TX","","",11,null],[13,"TWIM2_TX","","",11,null],[13,"TWIM3_TX","","",11,null],[13,"TWIS0_TX","","",11,null],[13,"TWIS1_TX","","",11,null],[13,"ADCIFE_TX","","",11,null],[13,"CATB_TX","","",11,null],[13,"ABDACB_SDR0_TX","","",11,null],[13,"ABDACB_SDR1_TX","","",11,null],[13,"IISC_CH0_TX","","",11,null],[13,"IISC_CH1_TX","","",11,null],[13,"DACC_TX","","",11,null],[13,"AESA_TX","","",11,null],[13,"LCDCA_ACMDR_TX","","",11,null],[13,"LCDCA_ABMDR_TX","","",11,null],[4,"DMAWidth","","",null,null],[13,"Width8Bit","","",12,null],[13,"Width16Bit","","",12,null],[13,"Width32Bit","","",12,null],[5,"pdca0_handler","","",null,{"inputs":[],"output":null}],[5,"pdca1_handler","","",null,{"inputs":[],"output":null}],[5,"pdca2_handler","","",null,{"inputs":[],"output":null}],[5,"pdca3_handler","","",null,{"inputs":[],"output":null}],[5,"pdca4_handler","","",null,{"inputs":[],"output":null}],[5,"pdca5_handler","","",null,{"inputs":[],"output":null}],[5,"pdca6_handler","","",null,{"inputs":[],"output":null}],[5,"pdca7_handler","","",null,{"inputs":[],"output":null}],[5,"pdca8_handler","","",null,{"inputs":[],"output":null}],[5,"pdca9_handler","","",null,{"inputs":[],"output":null}],[5,"pdca10_handler","","",null,{"inputs":[],"output":null}],[5,"pdca11_handler","","",null,{"inputs":[],"output":null}],[5,"pdca12_handler","","",null,{"inputs":[],"output":null}],[5,"pdca13_handler","","",null,{"inputs":[],"output":null}],[5,"pdca14_handler","","",null,{"inputs":[],"output":null}],[5,"pdca15_handler","","",null,{"inputs":[],"output":null}],[7,"NUM_ENABLED","","Shared counter that Keeps track of how many DMA channels are currently active.",null,null],[7,"DMA_CHANNELS","","",null,null],[17,"DMA_BASE_ADDR","","The PDCA's base addresses in memory (Section 7.1 of manual).",null,null],[17,"DMA_CHANNEL_SIZE","","The number of bytes between each memory mapped DMA Channel (Section 16.6.1).",null,null],[8,"DMAClient","","",null,null],[10,"xfer_done","","",13,{"inputs":[{"name":"self"},{"name":"dmaperipheral"}],"output":null}],[11,"clone","","",10,{"inputs":[{"name":"self"}],"output":{"name":"dmachannelnum"}}],[11,"clone","","",11,{"inputs":[{"name":"self"}],"output":{"name":"dmaperipheral"}}],[11,"eq","","",11,{"inputs":[{"name":"self"},{"name":"dmaperipheral"}],"output":{"name":"bool"}}],[11,"clone","","",12,{"inputs":[{"name":"self"}],"output":{"name":"dmawidth"}}],[11,"fmt","","",12,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",12,{"inputs":[{"name":"self"},{"name":"dmawidth"}],"output":{"name":"bool"}}],[11,"new","","",9,{"inputs":[{"name":"dmachannelnum"},{"name":"nvicidx"}],"output":{"name":"dmachannel"}}],[11,"initialize","","",9,{"inputs":[{"name":"self"},{"name":"dmaclient"},{"name":"dmawidth"}],"output":null}],[11,"enable","","",9,{"inputs":[{"name":"self"}],"output":null}],[11,"disable","","",9,{"inputs":[{"name":"self"}],"output":null}],[11,"handle_interrupt","","",9,{"inputs":[{"name":"self"}],"output":null}],[11,"start_xfer","","",9,{"inputs":[{"name":"self"}],"output":null}],[11,"prepare_xfer","","",9,null],[11,"do_xfer","","",9,null],[11,"abort_xfer","","Aborts any current transactions and returns the buffer used in the transaction.",9,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"transfer_counter","","",9,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[0,"i2c","sam4l","Implementation of the SAM4L TWIMS peripheral.",null,null],[3,"TWIMRegisters","sam4l::i2c","",null,null],[12,"control","","",14,null],[12,"clock_waveform_generator","","",14,null],[12,"smbus_timing","","",14,null],[12,"command","","",14,null],[12,"next_command","","",14,null],[12,"receive_holding","","",14,null],[12,"transmit_holding","","",14,null],[12,"status","","",14,null],[12,"interrupt_enable","","",14,null],[12,"interrupt_disable","","",14,null],[12,"interrupt_mask","","",14,null],[12,"status_clear","","",14,null],[12,"parameter","","",14,null],[12,"version","","",14,null],[12,"hsmode_clock_waveform_generator","","",14,null],[12,"slew_rate","","",14,null],[12,"hsmod_slew_rate","","",14,null],[3,"TWISRegisters","","",null,null],[12,"control","","",15,null],[12,"nbytes","","",15,null],[12,"timing","","",15,null],[12,"receive_holding","","",15,null],[12,"transmit_holding","","",15,null],[12,"packet_error_check","","",15,null],[12,"status","","",15,null],[12,"interrupt_enable","","",15,null],[12,"interrupt_disable","","",15,null],[12,"interrupt_mask","","",15,null],[12,"status_clear","","",15,null],[12,"parameter","","",15,null],[12,"version","","",15,null],[12,"hsmode_timing","","",15,null],[12,"slew_rate","","",15,null],[12,"hsmod_slew_rate","","",15,null],[3,"I2CHw","","",null,null],[12,"registers","","",16,null],[12,"slave_registers","","",16,null],[12,"master_clock","","",16,null],[12,"slave_clock","","",16,null],[12,"dma","","",16,null],[12,"dma_pids","","",16,null],[12,"nvic","","",16,null],[12,"slave_nvic","","",16,null],[12,"master_client","","",16,null],[12,"slave_client","","",16,null],[12,"on_deck","","",16,null],[12,"slave_enabled","","",16,null],[12,"my_slave_address","","",16,null],[12,"slave_read_buffer","","",16,null],[12,"slave_read_buffer_len","","",16,null],[12,"slave_read_buffer_index","","",16,null],[12,"slave_write_buffer","","",16,null],[12,"slave_write_buffer_len","","",16,null],[12,"slave_write_buffer_index","","",16,null],[4,"Location","","",null,null],[13,"I2C00","","",17,null],[13,"I2C01","","",17,null],[13,"I2C02","","",17,null],[13,"I2C03","","",17,null],[4,"Speed","","",null,null],[13,"Standard100k","","",18,null],[13,"Fast400k","","",18,null],[13,"FastPlus1M","","",18,null],[5,"twim0_handler","","",null,{"inputs":[],"output":null}],[5,"twim1_handler","","",null,{"inputs":[],"output":null}],[5,"twim2_handler","","",null,{"inputs":[],"output":null}],[5,"twim3_handler","","",null,{"inputs":[],"output":null}],[5,"twis0_handler","","",null,{"inputs":[],"output":null}],[5,"twis1_handler","","",null,{"inputs":[],"output":null}],[7,"I2C0","","",null,null],[7,"I2C1","","",null,null],[7,"I2C2","","",null,null],[7,"I2C3","","",null,null],[17,"I2C_BASE_ADDRS","","",null,null],[17,"I2C_SLAVE_BASE_ADDRS","","",null,null],[17,"START","","",null,null],[17,"STOP","","",null,null],[17,"ACKLAST","","",null,null],[11,"clone","","",17,{"inputs":[{"name":"self"}],"output":{"name":"location"}}],[11,"clone","","",18,{"inputs":[{"name":"self"}],"output":{"name":"speed"}}],[11,"new","","",16,null],[11,"set_bus_speed","","Set the clock prescaler and the time widths of the I2C signals in the CWGR register to make the bus run at a particular I2C speed.",16,{"inputs":[{"name":"self"}],"output":null}],[11,"set_dma","","",16,{"inputs":[{"name":"self"},{"name":"dmachannel"}],"output":null}],[11,"set_master_client","","",16,{"inputs":[{"name":"self"},{"name":"i2chwmasterclient"}],"output":null}],[11,"set_slave_client","","",16,{"inputs":[{"name":"self"},{"name":"i2chwslaveclient"}],"output":null}],[11,"handle_interrupt","","",16,{"inputs":[{"name":"self"}],"output":null}],[11,"setup_xfer","","",16,{"inputs":[{"name":"self"},{"name":"u8"},{"name":"usize"},{"name":"bool"},{"name":"u8"}],"output":null}],[11,"setup_nextfer","","",16,{"inputs":[{"name":"self"},{"name":"u8"},{"name":"usize"},{"name":"bool"},{"name":"u8"}],"output":null}],[11,"master_enable","","",16,{"inputs":[{"name":"self"}],"output":null}],[11,"write","","",16,null],[11,"read","","",16,null],[11,"write_read","","",16,null],[11,"enable_interrupts","","",16,{"inputs":[{"name":"self"}],"output":null}],[11,"disable_interrupts","","",16,{"inputs":[{"name":"self"}],"output":null}],[11,"handle_slave_interrupt","","Handle possible interrupt for TWIS module.",16,{"inputs":[{"name":"self"}],"output":null}],[11,"slave_write_receive","","Receive the bytes the I2C master is writing to us.",16,null],[11,"slave_read_send","","Prepare a buffer for the I2C master to read from after a read call.",16,null],[11,"slave_enable_interrupts","","",16,{"inputs":[{"name":"self"}],"output":null}],[11,"slave_disable_interrupts","","",16,{"inputs":[{"name":"self"}],"output":null}],[11,"slave_set_address","","",16,{"inputs":[{"name":"self"},{"name":"u8"}],"output":null}],[11,"slave_listen","","",16,{"inputs":[{"name":"self"}],"output":null}],[11,"xfer_done","","",16,{"inputs":[{"name":"self"},{"name":"dmaperipheral"}],"output":null}],[11,"enable","","This enables the entire I2C peripheral",16,{"inputs":[{"name":"self"}],"output":null}],[11,"disable","","This disables the entire I2C peripheral",16,{"inputs":[{"name":"self"}],"output":null}],[11,"write","","",16,null],[11,"read","","",16,null],[11,"write_read","","",16,null],[11,"enable","","",16,{"inputs":[{"name":"self"}],"output":null}],[11,"disable","","This disables the entire I2C peripheral",16,{"inputs":[{"name":"self"}],"output":null}],[11,"set_address","","",16,{"inputs":[{"name":"self"},{"name":"u8"}],"output":null}],[11,"write_receive","","",16,null],[11,"read_send","","",16,null],[11,"listen","","",16,{"inputs":[{"name":"self"}],"output":null}],[0,"spi","sam4l","Implementation of DMA-based SPI master and slave communication for the SAM4L.",null,null],[3,"SpiRegisters","sam4l::spi","The registers used to interface with the hardware",null,null],[12,"cr","","",19,null],[12,"mr","","",19,null],[12,"rdr","","",19,null],[12,"tdr","","",19,null],[12,"sr","","",19,null],[12,"ier","","",19,null],[12,"idr","","",19,null],[12,"imr","","",19,null],[12,"_reserved0","","",19,null],[12,"csr0","","",19,null],[12,"csr1","","",19,null],[12,"csr2","","",19,null],[12,"csr3","","",19,null],[12,"_reserved1","","",19,null],[12,"wpcr","","",19,null],[12,"wpsr","","",19,null],[12,"_reserved2","","",19,null],[12,"features","","",19,null],[12,"version","","",19,null],[3,"Spi","","The SAM4L supports four peripherals.",null,null],[12,"registers","","",20,null],[12,"client","","",20,null],[12,"dma_read","","",20,null],[12,"dma_write","","",20,null],[12,"transfers_in_progress","","",20,null],[12,"dma_length","","",20,null],[12,"slave_client","","",20,null],[12,"role","","",20,null],[4,"Peripheral","","Values for selected peripherals",null,null],[13,"Peripheral0","","",21,null],[13,"Peripheral1","","",21,null],[13,"Peripheral2","","",21,null],[13,"Peripheral3","","",21,null],[4,"SpiRole","","",null,null],[13,"SpiMaster","","",22,null],[13,"SpiSlave","","",22,null],[5,"spi_interrupt_handler","","",null,{"inputs":[],"output":null}],[0,"spi_consts","","",null,null],[0,"cr","sam4l::spi::spi_consts","",null,null],[17,"SPIEN","sam4l::spi::spi_consts::cr","",null,null],[17,"SPIDIS","","",null,null],[17,"SWRST","","",null,null],[17,"FLUSHFIFO","","",null,null],[17,"LASTXFER","","",null,null],[0,"mr","sam4l::spi::spi_consts","",null,null],[17,"MSTR","sam4l::spi::spi_consts::mr","",null,null],[17,"PS","","",null,null],[17,"PCSDEC","","",null,null],[17,"MODFDIS","","",null,null],[17,"RXFIFOEN","","",null,null],[17,"LLB","","",null,null],[17,"PCS_MASK","","",null,null],[17,"PCS0","","",null,null],[17,"PCS1","","",null,null],[17,"PCS2","","",null,null],[17,"PCS3","","",null,null],[17,"DLYBCS_MASK","","",null,null],[0,"rdr","sam4l::spi::spi_consts","",null,null],[17,"RD","sam4l::spi::spi_consts::rdr","",null,null],[0,"tdr","sam4l::spi::spi_consts","",null,null],[17,"TD","sam4l::spi::spi_consts::tdr","",null,null],[0,"sr","sam4l::spi::spi_consts","",null,null],[17,"RDRF","sam4l::spi::spi_consts::sr","",null,null],[17,"TDRE","","",null,null],[17,"MODF","","",null,null],[17,"OVRES","","",null,null],[17,"NSSR","","",null,null],[17,"TXEMPTY","","",null,null],[17,"UNDES","","",null,null],[17,"SPIENS","","",null,null],[0,"csr","sam4l::spi::spi_consts","",null,null],[17,"CPOL","sam4l::spi::spi_consts::csr","",null,null],[17,"NCPHA","","",null,null],[17,"CSNAAT","","",null,null],[17,"CSAAT","","",null,null],[17,"BITS_MASK","","",null,null],[17,"BITS8","","",null,null],[17,"BITS9","","",null,null],[17,"BITS10","","",null,null],[17,"BITS11","","",null,null],[17,"BITS12","","",null,null],[17,"BITS13","","",null,null],[17,"BITS14","","",null,null],[17,"BITS15","","",null,null],[17,"BITS16","","",null,null],[17,"BITS4","","",null,null],[17,"BITS5","","",null,null],[17,"BITS6","","",null,null],[17,"BITS7","","",null,null],[17,"SCBR_MASK","","",null,null],[17,"DLYBS_MASK","","",null,null],[17,"DLYBCT_MASK","","",null,null],[7,"SPI","sam4l::spi","",null,null],[17,"SPI_BASE","","",null,null],[11,"clone","","",21,{"inputs":[{"name":"self"}],"output":{"name":"peripheral"}}],[11,"clone","","",22,{"inputs":[{"name":"self"}],"output":{"name":"spirole"}}],[11,"eq","","",22,{"inputs":[{"name":"self"},{"name":"spirole"}],"output":{"name":"bool"}}],[11,"new","","Creates a new SPI object, with peripheral 0 selected",20,{"inputs":[],"output":{"name":"spi"}}],[11,"init_as_role","","",20,{"inputs":[{"name":"self"},{"name":"spirole"}],"output":null}],[11,"enable","","",20,{"inputs":[{"name":"self"}],"output":null}],[11,"disable","","",20,{"inputs":[{"name":"self"}],"output":null}],[11,"set_baud_rate","","Sets the approximate baud rate for the active peripheral, and return the actual baud rate set.",20,{"inputs":[{"name":"self"},{"name":"u32"}],"output":{"name":"u32"}}],[11,"get_baud_rate","","",20,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"set_clock","","",20,{"inputs":[{"name":"self"},{"name":"clockpolarity"}],"output":null}],[11,"get_clock","","",20,{"inputs":[{"name":"self"}],"output":{"name":"clockpolarity"}}],[11,"set_phase","","",20,{"inputs":[{"name":"self"},{"name":"clockphase"}],"output":null}],[11,"get_phase","","",20,{"inputs":[{"name":"self"}],"output":{"name":"clockphase"}}],[11,"set_active_peripheral","","",20,{"inputs":[{"name":"self"},{"name":"peripheral"}],"output":null}],[11,"get_active_peripheral","","Returns the currently active peripheral",20,{"inputs":[{"name":"self"}],"output":{"name":"peripheral"}}],[11,"read_active_csr","","Returns the value of CSR0, CSR1, CSR2, or CSR3, whichever corresponds to the active peripheral",20,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"write_active_csr","","Sets the Chip Select Register (CSR) of the active peripheral (CSR0, CSR1, CSR2, or CSR3).",20,{"inputs":[{"name":"self"},{"name":"u32"}],"output":null}],[11,"set_dma","","Set the DMA channels used for reading and writing.",20,{"inputs":[{"name":"self"},{"name":"dmachannel"},{"name":"dmachannel"}],"output":null}],[11,"enable_clock","","",20,{"inputs":[{"name":"self"}],"output":null}],[11,"handle_interrupt","","",20,{"inputs":[{"name":"self"}],"output":null}],[11,"read_write_bytes","","Asynchronous buffer read/write of SPI. returns `SUCCESS` if operation starts (will receive callback through SpiMasterClient), returns `EBUSY` if the operation does not start.",20,{"inputs":[{"name":"self"},{"name":"option"},{"name":"option"},{"name":"usize"}],"output":{"name":"returncode"}}],[11,"set_client","","",20,{"inputs":[{"name":"self"},{"name":"spimasterclient"}],"output":null}],[11,"init","","By default, initialize SPI to operate at 40KHz, clock is idle on low, and sample on the leading edge.",20,{"inputs":[{"name":"self"}],"output":null}],[11,"is_busy","","",20,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"write_byte","","Write a byte to the SPI and discard the read; if an asynchronous operation is outstanding, do nothing.",20,{"inputs":[{"name":"self"},{"name":"u8"}],"output":null}],[11,"read_byte","","Write 0 to the SPI and return the read; if an asynchronous operation is outstanding, do nothing.",20,{"inputs":[{"name":"self"}],"output":{"name":"u8"}}],[11,"read_write_byte","","Write a byte to the SPI and return the read; if an asynchronous operation is outstanding, do nothing.",20,{"inputs":[{"name":"self"},{"name":"u8"}],"output":{"name":"u8"}}],[11,"read_write_bytes","","Asynchronous buffer read/write of SPI. write_buffer must  be Some; read_buffer may be None; if read_buffer is Some, then length of read/write is the minimum of two buffer lengths; returns `SUCCESS` if operation starts (will receive callback through SpiMasterClient), returns `EBUSY` if the operation does not start.",20,null],[11,"set_rate","","",20,{"inputs":[{"name":"self"},{"name":"u32"}],"output":{"name":"u32"}}],[11,"get_rate","","",20,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"set_clock","","",20,{"inputs":[{"name":"self"},{"name":"clockpolarity"}],"output":null}],[11,"get_clock","","",20,{"inputs":[{"name":"self"}],"output":{"name":"clockpolarity"}}],[11,"set_phase","","",20,{"inputs":[{"name":"self"},{"name":"clockphase"}],"output":null}],[11,"get_phase","","",20,{"inputs":[{"name":"self"}],"output":{"name":"clockphase"}}],[11,"hold_low","","",20,{"inputs":[{"name":"self"}],"output":null}],[11,"release_low","","",20,{"inputs":[{"name":"self"}],"output":null}],[11,"specify_chip_select","","",20,null],[11,"set_client","","",20,{"inputs":[{"name":"self"},{"name":"option"}],"output":null}],[11,"has_client","","",20,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"init","","",20,{"inputs":[{"name":"self"}],"output":null}],[11,"set_write_byte","","This sets the value in the TDR register, to be sent as soon as the chip select pin is low.",20,{"inputs":[{"name":"self"},{"name":"u8"}],"output":null}],[11,"read_write_bytes","","",20,{"inputs":[{"name":"self"},{"name":"option"},{"name":"option"},{"name":"usize"}],"output":{"name":"returncode"}}],[11,"set_clock","","",20,{"inputs":[{"name":"self"},{"name":"clockpolarity"}],"output":null}],[11,"get_clock","","",20,{"inputs":[{"name":"self"}],"output":{"name":"clockpolarity"}}],[11,"set_phase","","",20,{"inputs":[{"name":"self"},{"name":"clockphase"}],"output":null}],[11,"get_phase","","",20,{"inputs":[{"name":"self"}],"output":{"name":"clockphase"}}],[11,"xfer_done","","",20,{"inputs":[{"name":"self"},{"name":"dmaperipheral"}],"output":null}],[0,"nvic","sam4l","Implementation of the SAM4L interrupt controller.",null,null],[3,"Nvic","sam4l::nvic","",null,null],[12,"iser","","",23,null],[12,"_reserved0","","",23,null],[12,"icer","","",23,null],[12,"_reserved1","","",23,null],[12,"ispr","","",23,null],[12,"_reserved2","","",23,null],[12,"icpr","","",23,null],[4,"NvicIdx","","",null,null],[13,"HFLASHC","","",24,null],[13,"PDCA0","","",24,null],[13,"PDCA1","","",24,null],[13,"PDCA2","","",24,null],[13,"PDCA3","","",24,null],[13,"PDCA4","","",24,null],[13,"PDCA5","","",24,null],[13,"PDCA6","","",24,null],[13,"PDCA7","","",24,null],[13,"PDCA8","","",24,null],[13,"PDCA9","","",24,null],[13,"PDCA10","","",24,null],[13,"PDCA11","","",24,null],[13,"PDCA12","","",24,null],[13,"PDCA13","","",24,null],[13,"PDCA14","","",24,null],[13,"PDCA15","","",24,null],[13,"CRCCU","","",24,null],[13,"USBC","","",24,null],[13,"PEVCTR","","",24,null],[13,"PEVCOV","","",24,null],[13,"AESA","","",24,null],[13,"PM","","",24,null],[13,"SCIF","","",24,null],[13,"FREQM","","",24,null],[13,"GPIO0","","",24,null],[13,"GPIO1","","",24,null],[13,"GPIO2","","",24,null],[13,"GPIO3","","",24,null],[13,"GPIO4","","",24,null],[13,"GPIO5","","",24,null],[13,"GPIO6","","",24,null],[13,"GPIO7","","",24,null],[13,"GPIO8","","",24,null],[13,"GPIO9","","",24,null],[13,"GPIO10","","",24,null],[13,"GPIO11","","",24,null],[13,"BPM","","",24,null],[13,"BSCIF","","",24,null],[13,"ASTALARM","","",24,null],[13,"ASTPER","","",24,null],[13,"ASTOVF","","",24,null],[13,"ASTREADY","","",24,null],[13,"ASTCLKREADY","","",24,null],[13,"WDT","","",24,null],[13,"EIC1","","",24,null],[13,"EIC2","","",24,null],[13,"EIC3","","",24,null],[13,"EIC4","","",24,null],[13,"EIC5","","",24,null],[13,"EIC6","","",24,null],[13,"EIC7","","",24,null],[13,"EIC8","","",24,null],[13,"IISC","","",24,null],[13,"SPI","","",24,null],[13,"TC00","","",24,null],[13,"TC01","","",24,null],[13,"TC02","","",24,null],[13,"TC10","","",24,null],[13,"TC11","","",24,null],[13,"TC12","","",24,null],[13,"TWIM0","","",24,null],[13,"TWIS0","","",24,null],[13,"TWIM1","","",24,null],[13,"TWIS1","","",24,null],[13,"USART0","","",24,null],[13,"USART1","","",24,null],[13,"USART2","","",24,null],[13,"USART3","","",24,null],[13,"ADCIFE","","",24,null],[13,"DACC","","",24,null],[13,"ACIFC","","",24,null],[13,"ABDACB","","",24,null],[13,"TRNG","","",24,null],[13,"PARC","","",24,null],[13,"CATB","","",24,null],[13,"_RESERVED","","",24,null],[13,"TWIM2","","",24,null],[13,"TWIM3","","",24,null],[13,"LCDCA","","",24,null],[5,"enable","","",null,{"inputs":[{"name":"nvicidx"}],"output":null}],[5,"disable","","",null,{"inputs":[{"name":"nvicidx"}],"output":null}],[5,"clear_pending","","",null,{"inputs":[{"name":"nvicidx"}],"output":null}],[17,"BASE_ADDRESS","","",null,null],[11,"clone","","",24,{"inputs":[{"name":"self"}],"output":{"name":"nvicidx"}}],[11,"default","","",24,{"inputs":[],"output":{"name":"nvicidx"}}],[0,"pm","sam4l","Implementation of the power manager (PM) peripheral.",null,null],[3,"PmRegisters","sam4l::pm","",null,null],[12,"mcctrl","","",25,null],[12,"cpusel","","",25,null],[12,"_reserved1","","",25,null],[12,"pbasel","","",25,null],[12,"pbbsel","","",25,null],[12,"pbcsel","","",25,null],[12,"pbdsel","","",25,null],[12,"_reserved2","","",25,null],[12,"cpumask","","",25,null],[12,"hsbmask","","",25,null],[12,"pbamask","","",25,null],[12,"pbbmask","","",25,null],[12,"pbcmask","","",25,null],[12,"pbdmask","","",25,null],[12,"_reserved3","","",25,null],[12,"pbadivmask","","",25,null],[12,"_reserved4","","",25,null],[12,"cfdctrl","","",25,null],[12,"unlock","","",25,null],[12,"_reserved5","","",25,null],[12,"ier","","",25,null],[12,"idr","","",25,null],[12,"imr","","",25,null],[12,"isr","","",25,null],[12,"icr","","",25,null],[12,"sr","","",25,null],[12,"_reserved6","","",25,null],[12,"ppcr","","",25,null],[12,"_reserved7","","",25,null],[12,"rcause","","",25,null],[12,"wcause","","",25,null],[12,"awen","","",25,null],[12,"protctrl","","",25,null],[12,"_reserved8","","",25,null],[12,"fastsleep","","",25,null],[12,"_reserved9","","",25,null],[12,"config","","",25,null],[12,"version","","",25,null],[3,"PowerManager","","Contains state for the power management peripheral. This includes the configurations for various system clocks and the final frequency that the system is running at.",null,null],[12,"system_frequency","","Frequency at which the system clock is running.",26,null],[12,"system_clock_source","","Clock source configuration",26,null],[4,"MainClock","","",null,null],[13,"RCSYS","","",27,null],[13,"OSC0","","",27,null],[13,"PLL","","",27,null],[13,"DFLL","","",27,null],[13,"RC80M","","",27,null],[13,"RCFAST","","",27,null],[13,"RC1M","","",27,null],[4,"Clock","","",null,null],[13,"HSB","","",28,null],[13,"PBA","","",28,null],[13,"PBB","","",28,null],[13,"PBC","","",28,null],[13,"PBD","","",28,null],[4,"HSBClock","","",null,null],[13,"PDCA","","",29,null],[13,"FLASHCALW","","",29,null],[13,"FLASHCALWP","","",29,null],[13,"USBC","","",29,null],[13,"CRCCU","","",29,null],[13,"APBA","","",29,null],[13,"APBB","","",29,null],[13,"APBC","","",29,null],[13,"APBD","","",29,null],[13,"AESA","","",29,null],[4,"PBAClock","","",null,null],[13,"IISC","","",30,null],[13,"SPI","","",30,null],[13,"TC0","","",30,null],[13,"TC1","","",30,null],[13,"TWIM0","","",30,null],[13,"TWIS0","","",30,null],[13,"TWIM1","","",30,null],[13,"TWIS1","","",30,null],[13,"USART0","","",30,null],[13,"USART1","","",30,null],[13,"USART2","","",30,null],[13,"USART3","","",30,null],[13,"ADCIFE","","",30,null],[13,"DACC","","",30,null],[13,"ACIFC","","",30,null],[13,"GLOC","","",30,null],[13,"ABSACB","","",30,null],[13,"TRNG","","",30,null],[13,"PARC","","",30,null],[13,"CATB","","",30,null],[13,"NULL","","",30,null],[13,"TWIM2","","",30,null],[13,"TWIM3","","",30,null],[13,"LCDCA","","",30,null],[4,"PBBClock","","",null,null],[13,"FLASHCALW","","",31,null],[13,"HRAMC1","","",31,null],[13,"HMATRIX","","",31,null],[13,"PDCA","","",31,null],[13,"CRCCU","","",31,null],[13,"USBC","","",31,null],[13,"PEVC","","",31,null],[4,"PBCClock","","",null,null],[13,"PM","","",32,null],[13,"CHIPID","","",32,null],[13,"SCIF","","",32,null],[13,"FREQM","","",32,null],[13,"GPIO","","",32,null],[4,"PBDClock","","",null,null],[13,"BPM","","",33,null],[13,"BSCIF","","",33,null],[13,"AST","","",33,null],[13,"WDT","","",33,null],[13,"EIC","","",33,null],[13,"PICOUART","","",33,null],[4,"OscillatorFrequency","","Frequency of the external oscillator. For the SAM4L, different configurations are needed for different ranges of oscillator frequency, so based on the input frequency, various configurations may need to change. When additional oscillator frequencies are needed, they should be added here and the `setup_system_clock` function should be modified to support it.",null,null],[13,"Frequency16MHz","","16 MHz external oscillator",34,null],[4,"OscillatorStartup","","Configuration for the startup time of the external oscillator. In practice we have found that some boards work with a short startup time, while others need a slow start in order to properly wake from sleep. In general, we find that for systems that do not work, at fast speed, they will hang or panic after several entries into WAIT mode.",null,null],[13,"FastStart","","Use a fast startup. ~0.5 ms in practice.",35,null],[13,"SlowStart","","Use a slow startup. ~8.9 ms in practice.",35,null],[4,"SystemClockSource","","Which source the system clock should be generated from. These are specified as system clock source appended with the clock that it is sourced from appended with the final frequency of the system. So for example, one option is to use the DFLL sourced from the RC32K with a final frequency of 48 MHz.",null,null],[13,"RcsysAt115kHz","","Use the RCSYS clock (which the system starts up on anyways). Final system frequency will be 115 kHz. Note that while this is the default, Tock is NOT guaranteed to work on this setting and will likely fail.",36,null],[13,"DfllRc32kAt48MHz","","Use the internal digital frequency locked loop (DFLL) sourced from the internal RC32K clock. Note this typically requires calibration of the RC32K to have a consistent clock. Final frequency of 48 MHz.",36,null],[13,"ExternalOscillator","","Use an external crystal oscillator as the direct source for the system clock. The final system frequency will match the frequency of the external oscillator.",36,null],[12,"frequency","sam4l::pm::SystemClockSource","",36,null],[12,"startup_mode","","",36,null],[13,"PllExternalOscillatorAt48MHz","sam4l::pm","Use an external crystal oscillator as the input to the internal phase locked loop (PLL) for the system clock. This results in a final frequency of 48 MHz.",36,null],[12,"frequency","sam4l::pm::SystemClockSource","",36,null],[12,"startup_mode","","",36,null],[5,"unlock","sam4l::pm","",null,{"inputs":[{"name":"u32"}],"output":null}],[5,"select_main_clock","","",null,{"inputs":[{"name":"mainclock"}],"output":null}],[5,"configure_48mhz_dfll","","Configure the system clock to use the DFLL with the RC32K as the source. Run at 48 MHz.",null,{"inputs":[],"output":null}],[5,"configure_external_oscillator","","Configure the system clock to use the 16 MHz external crystal directly",null,{"inputs":[{"name":"oscillatorfrequency"},{"name":"oscillatorstartup"}],"output":null}],[5,"configure_external_oscillator_pll","","Configure the system clock to use the PLL with the 16 MHz external crystal",null,{"inputs":[{"name":"oscillatorfrequency"},{"name":"oscillatorstartup"}],"output":null}],[5,"get_system_frequency","","",null,{"inputs":[],"output":{"name":"u32"}}],[5,"deep_sleep_ready","","Determines if the chip can safely go into deep sleep without preventing currently active peripherals from operating.",null,{"inputs":[],"output":{"name":"bool"}}],[5,"enable_clock","","",null,{"inputs":[{"name":"clock"}],"output":null}],[5,"disable_clock","","",null,{"inputs":[{"name":"clock"}],"output":null}],[5,"is_clock_enabled","","",null,{"inputs":[{"name":"clock"}],"output":{"name":"bool"}}],[7,"PM_REGS","","",null,null],[7,"PM","","",null,null],[17,"PM_BASE","","",null,null],[17,"HSB_MASK_OFFSET","","",null,null],[17,"PBA_MASK_OFFSET","","",null,null],[17,"PBB_MASK_OFFSET","","",null,null],[17,"PBC_MASK_OFFSET","","",null,null],[17,"PBD_MASK_OFFSET","","",null,null],[17,"DEEP_SLEEP_HSBMASK","","",null,null],[17,"DEEP_SLEEP_PBAMASK","","",null,null],[17,"DEEP_SLEEP_PBBMASK","","",null,null],[11,"clone","","",28,{"inputs":[{"name":"self"}],"output":{"name":"clock"}}],[11,"fmt","","",28,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",29,{"inputs":[{"name":"self"}],"output":{"name":"hsbclock"}}],[11,"fmt","","",29,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",30,{"inputs":[{"name":"self"}],"output":{"name":"pbaclock"}}],[11,"fmt","","",30,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",31,{"inputs":[{"name":"self"}],"output":{"name":"pbbclock"}}],[11,"fmt","","",31,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",32,{"inputs":[{"name":"self"}],"output":{"name":"pbcclock"}}],[11,"fmt","","",32,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",33,{"inputs":[{"name":"self"}],"output":{"name":"pbdclock"}}],[11,"fmt","","",33,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",34,{"inputs":[{"name":"self"}],"output":{"name":"oscillatorfrequency"}}],[11,"fmt","","",34,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",35,{"inputs":[{"name":"self"}],"output":{"name":"oscillatorstartup"}}],[11,"fmt","","",35,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",36,{"inputs":[{"name":"self"}],"output":{"name":"systemclocksource"}}],[11,"fmt","","",36,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"setup_system_clock","","Sets up the system clock. This should be called as one of the first lines in the `reset_handler` within the platform's `main.rs`.",26,{"inputs":[{"name":"self"},{"name":"systemclocksource"}],"output":null}],[0,"gpio","sam4l","Implementation of the GPIO controller.",null,null],[3,"Register","sam4l::gpio","",null,null],[12,"val","","",37,null],[12,"set","","",37,null],[12,"clear","","",37,null],[12,"toggle","","",37,null],[3,"RegisterRC","","",null,null],[12,"val","","",38,null],[12,"reserved0","","",38,null],[12,"clear","","",38,null],[12,"reserved1","","",38,null],[3,"Registers","","",null,null],[12,"gper","","",39,null],[12,"pmr0","","",39,null],[12,"pmr1","","",39,null],[12,"pmr2","","",39,null],[12,"oder","","",39,null],[12,"ovr","","",39,null],[12,"pvr","","",39,null],[12,"_reserved0","","",39,null],[12,"puer","","",39,null],[12,"pder","","",39,null],[12,"ier","","",39,null],[12,"imr0","","",39,null],[12,"imr1","","",39,null],[12,"gfer","","",39,null],[12,"ifr","","",39,null],[12,"_reserved1","","",39,null],[12,"ocdr0","","",39,null],[12,"ocdr1","","",39,null],[12,"_reserved2","","",39,null],[12,"osrr0","","",39,null],[12,"_reserved3","","",39,null],[12,"ster","","",39,null],[12,"_reserved4","","",39,null],[12,"ever","","",39,null],[12,"_reserved5","","",39,null],[12,"parameter","","",39,null],[12,"version","","",39,null],[3,"Port","","GPIO port that manages 32 pins.",null,null],[12,"port","","",40,null],[12,"pins","","",40,null],[3,"GPIOPin","","",null,null],[12,"port","","",41,null],[12,"nvic","","",41,null],[12,"pin_mask","","",41,null],[12,"client_data","","",41,null],[12,"client","","",41,null],[4,"PeripheralFunction","","Peripheral functions that may be assigned to a `GPIOPin`.",null,null],[13,"A","","",42,null],[13,"B","","",42,null],[13,"C","","",42,null],[13,"D","","",42,null],[13,"E","","",42,null],[13,"F","","",42,null],[13,"G","","",42,null],[4,"Pin","","Name of the GPIO pin on the SAM4L.",null,null],[13,"PA00","","",43,null],[13,"PA01","","",43,null],[13,"PA02","","",43,null],[13,"PA03","","",43,null],[13,"PA04","","",43,null],[13,"PA05","","",43,null],[13,"PA06","","",43,null],[13,"PA07","","",43,null],[13,"PA08","","",43,null],[13,"PA09","","",43,null],[13,"PA10","","",43,null],[13,"PA11","","",43,null],[13,"PA12","","",43,null],[13,"PA13","","",43,null],[13,"PA14","","",43,null],[13,"PA15","","",43,null],[13,"PA16","","",43,null],[13,"PA17","","",43,null],[13,"PA18","","",43,null],[13,"PA19","","",43,null],[13,"PA20","","",43,null],[13,"PA21","","",43,null],[13,"PA22","","",43,null],[13,"PA23","","",43,null],[13,"PA24","","",43,null],[13,"PA25","","",43,null],[13,"PA26","","",43,null],[13,"PA27","","",43,null],[13,"PA28","","",43,null],[13,"PA29","","",43,null],[13,"PA30","","",43,null],[13,"PA31","","",43,null],[13,"PB00","","",43,null],[13,"PB01","","",43,null],[13,"PB02","","",43,null],[13,"PB03","","",43,null],[13,"PB04","","",43,null],[13,"PB05","","",43,null],[13,"PB06","","",43,null],[13,"PB07","","",43,null],[13,"PB08","","",43,null],[13,"PB09","","",43,null],[13,"PB10","","",43,null],[13,"PB11","","",43,null],[13,"PB12","","",43,null],[13,"PB13","","",43,null],[13,"PB14","","",43,null],[13,"PB15","","",43,null],[13,"PB16","","",43,null],[13,"PB17","","",43,null],[13,"PB18","","",43,null],[13,"PB19","","",43,null],[13,"PB20","","",43,null],[13,"PB21","","",43,null],[13,"PB22","","",43,null],[13,"PB23","","",43,null],[13,"PB24","","",43,null],[13,"PB25","","",43,null],[13,"PB26","","",43,null],[13,"PB27","","",43,null],[13,"PB28","","",43,null],[13,"PB29","","",43,null],[13,"PB30","","",43,null],[13,"PB31","","",43,null],[13,"PC00","","",43,null],[13,"PC01","","",43,null],[13,"PC02","","",43,null],[13,"PC03","","",43,null],[13,"PC04","","",43,null],[13,"PC05","","",43,null],[13,"PC06","","",43,null],[13,"PC07","","",43,null],[13,"PC08","","",43,null],[13,"PC09","","",43,null],[13,"PC10","","",43,null],[13,"PC11","","",43,null],[13,"PC12","","",43,null],[13,"PC13","","",43,null],[13,"PC14","","",43,null],[13,"PC15","","",43,null],[13,"PC16","","",43,null],[13,"PC17","","",43,null],[13,"PC18","","",43,null],[13,"PC19","","",43,null],[13,"PC20","","",43,null],[13,"PC21","","",43,null],[13,"PC22","","",43,null],[13,"PC23","","",43,null],[13,"PC24","","",43,null],[13,"PC25","","",43,null],[13,"PC26","","",43,null],[13,"PC27","","",43,null],[13,"PC28","","",43,null],[13,"PC29","","",43,null],[13,"PC30","","",43,null],[13,"PC31","","",43,null],[5,"gpio0_handler","","",null,{"inputs":[],"output":null}],[5,"gpio1_handler","","",null,{"inputs":[],"output":null}],[5,"gpio2_handler","","",null,{"inputs":[],"output":null}],[5,"gpio3_handler","","",null,{"inputs":[],"output":null}],[5,"gpio4_handler","","",null,{"inputs":[],"output":null}],[5,"gpio5_handler","","",null,{"inputs":[],"output":null}],[5,"gpio6_handler","","",null,{"inputs":[],"output":null}],[5,"gpio7_handler","","",null,{"inputs":[],"output":null}],[5,"gpio8_handler","","",null,{"inputs":[],"output":null}],[5,"gpio9_handler","","",null,{"inputs":[],"output":null}],[5,"gpio10_handler","","",null,{"inputs":[],"output":null}],[5,"gpio11_handler","","",null,{"inputs":[],"output":null}],[7,"INTERRUPT_COUNT","","Reference count for the number of GPIO interrupts currently active.",null,null],[7,"PA","","Port A",null,null],[7,"PB","","Port B",null,null],[7,"PC","","Port C",null,null],[17,"BASE_ADDRESS","","",null,null],[17,"SIZE","","",null,null],[11,"clone","","",42,{"inputs":[{"name":"self"}],"output":{"name":"peripheralfunction"}}],[11,"clone","","",43,{"inputs":[{"name":"self"}],"output":{"name":"pin"}}],[11,"index","","",40,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"gpiopin"}}],[11,"index_mut","","",40,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"gpiopin"}}],[11,"handle_interrupt","","",40,{"inputs":[{"name":"self"}],"output":null}],[11,"new","","",41,{"inputs":[{"name":"pin"},{"name":"nvicidx"}],"output":{"name":"gpiopin"}}],[11,"set_client","","",41,{"inputs":[{"name":"self"},{"name":"c"}],"output":null}],[11,"select_peripheral","","",41,{"inputs":[{"name":"self"},{"name":"peripheralfunction"}],"output":null}],[11,"enable","","",41,{"inputs":[{"name":"self"}],"output":null}],[11,"disable","","",41,{"inputs":[{"name":"self"}],"output":null}],[11,"enable_output","","",41,{"inputs":[{"name":"self"}],"output":null}],[11,"disable_output","","",41,{"inputs":[{"name":"self"}],"output":null}],[11,"enable_pull_down","","",41,{"inputs":[{"name":"self"}],"output":null}],[11,"disable_pull_down","","",41,{"inputs":[{"name":"self"}],"output":null}],[11,"enable_pull_up","","",41,{"inputs":[{"name":"self"}],"output":null}],[11,"disable_pull_up","","",41,{"inputs":[{"name":"self"}],"output":null}],[11,"set_interrupt_mode","","Sets the interrupt mode registers. Interrupts may fire on the rising or falling edge of the pin or on both.",41,{"inputs":[{"name":"self"},{"name":"u8"}],"output":null}],[11,"enable_interrupt","","",41,{"inputs":[{"name":"self"}],"output":null}],[11,"disable_interrupt","","",41,{"inputs":[{"name":"self"}],"output":null}],[11,"handle_interrupt","","",41,{"inputs":[{"name":"self"}],"output":null}],[11,"disable_schmidtt_trigger","","",41,{"inputs":[{"name":"self"}],"output":null}],[11,"enable_schmidtt_trigger","","",41,{"inputs":[{"name":"self"}],"output":null}],[11,"read","","",41,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"toggle","","",41,{"inputs":[{"name":"self"}],"output":null}],[11,"set","","",41,{"inputs":[{"name":"self"}],"output":null}],[11,"clear","","",41,{"inputs":[{"name":"self"}],"output":null}],[11,"configure","","",41,null],[11,"set_input_mode","","",41,{"inputs":[{"name":"self"},{"name":"inputmode"}],"output":null}],[11,"disable","","",41,{"inputs":[{"name":"self"}],"output":null}],[11,"make_output","","",41,{"inputs":[{"name":"self"}],"output":null}],[11,"make_input","","",41,{"inputs":[{"name":"self"}],"output":null}],[11,"read","","",41,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"toggle","","",41,{"inputs":[{"name":"self"}],"output":null}],[11,"set","","",41,{"inputs":[{"name":"self"}],"output":null}],[11,"clear","","",41,{"inputs":[{"name":"self"}],"output":null}],[11,"enable_interrupt","","",41,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"interruptmode"}],"output":null}],[11,"disable_interrupt","","",41,{"inputs":[{"name":"self"}],"output":null}],[0,"usart","sam4l","Implementation of the SAM4L USART peripheral.",null,null],[3,"USARTRegisters","sam4l::usart","",null,null],[12,"cr","","",44,null],[12,"mr","","",44,null],[12,"ier","","",44,null],[12,"idr","","",44,null],[12,"imr","","",44,null],[12,"csr","","",44,null],[12,"rhr","","",44,null],[12,"thr","","",44,null],[12,"brgr","","",44,null],[12,"rtor","","",44,null],[12,"ttgr","","",44,null],[12,"_reserved0","","",44,null],[12,"fidi","","",44,null],[12,"ner","","",44,null],[12,"_reserved1","","",44,null],[12,"ifr","","",44,null],[12,"man","","",44,null],[12,"linmr","","",44,null],[12,"linir","","",44,null],[12,"linbrr","","",44,null],[12,"_reserved2","","",44,null],[12,"wpmr","","",44,null],[12,"wpsr","","",44,null],[12,"_reserved3","","",44,null],[12,"version","","",44,null],[3,"USART","","",null,null],[12,"registers","","",45,null],[12,"clock","","",45,null],[12,"nvic","","",45,null],[12,"usart_mode","","",45,null],[12,"usart_tx_state","","",45,null],[12,"usart_rx_state","","",45,null],[12,"rx_dma","","",45,null],[12,"rx_dma_peripheral","","",45,null],[12,"rx_len","","",45,null],[12,"tx_dma","","",45,null],[12,"tx_dma_peripheral","","",45,null],[12,"tx_len","","",45,null],[12,"client","","",45,null],[12,"spi_chip_select","","",45,null],[4,"USARTStateRX","","",null,null],[13,"Idle","","",46,null],[13,"DMA_Receiving","","",46,null],[4,"USARTStateTX","","",null,null],[13,"Idle","","",47,null],[13,"DMA_Transmitting","","",47,null],[13,"Transfer_Completing","","",47,null],[4,"UsartMode","","",null,null],[13,"Uart","","",48,null],[13,"Spi","","",48,null],[13,"Unused","","",48,null],[4,"UsartClient","","",null,null],[13,"Uart","","",49,null],[13,"SpiMaster","","",49,null],[5,"usart0_handler","","",null,{"inputs":[],"output":null}],[5,"usart1_handler","","",null,{"inputs":[],"output":null}],[5,"usart2_handler","","",null,{"inputs":[],"output":null}],[5,"usart3_handler","","",null,{"inputs":[],"output":null}],[7,"USART0","","",null,null],[7,"USART1","","",null,null],[7,"USART2","","",null,null],[7,"USART3","","",null,null],[17,"USART_BASE_ADDRS","","",null,null],[11,"clone","","",46,{"inputs":[{"name":"self"}],"output":{"name":"usartstaterx"}}],[11,"eq","","",46,{"inputs":[{"name":"self"},{"name":"usartstaterx"}],"output":{"name":"bool"}}],[11,"clone","","",47,{"inputs":[{"name":"self"}],"output":{"name":"usartstatetx"}}],[11,"eq","","",47,{"inputs":[{"name":"self"},{"name":"usartstatetx"}],"output":{"name":"bool"}}],[11,"clone","","",48,{"inputs":[{"name":"self"}],"output":{"name":"usartmode"}}],[11,"clone","","",49,{"inputs":[{"name":"self"}],"output":{"name":"usartclient"}}],[11,"new","","",45,null],[11,"set_dma","","",45,{"inputs":[{"name":"self"},{"name":"dmachannel"},{"name":"dmachannel"}],"output":null}],[11,"enable_rx","","",45,{"inputs":[{"name":"self"}],"output":null}],[11,"enable_tx","","",45,{"inputs":[{"name":"self"}],"output":null}],[11,"disable_rx","","",45,{"inputs":[{"name":"self"}],"output":null}],[11,"disable_tx","","",45,{"inputs":[{"name":"self"}],"output":null}],[11,"abort_rx","","",45,{"inputs":[{"name":"self"},{"name":"error"}],"output":null}],[11,"abort_tx","","",45,{"inputs":[{"name":"self"},{"name":"error"}],"output":null}],[11,"enable_tx_empty_interrupt","","",45,{"inputs":[{"name":"self"}],"output":null}],[11,"disable_tx_empty_interrupt","","",45,{"inputs":[{"name":"self"}],"output":null}],[11,"enable_rx_error_interrupts","","",45,{"inputs":[{"name":"self"}],"output":null}],[11,"disable_rx_interrupts","","",45,{"inputs":[{"name":"self"}],"output":null}],[11,"disable_tx_interrupts","","",45,{"inputs":[{"name":"self"}],"output":null}],[11,"disable_interrupts","","",45,{"inputs":[{"name":"self"}],"output":null}],[11,"reset","","",45,{"inputs":[{"name":"self"}],"output":null}],[11,"handle_interrupt","","",45,{"inputs":[{"name":"self"}],"output":null}],[11,"enable_clock","","",45,{"inputs":[{"name":"self"}],"output":null}],[11,"disable_clock","","",45,{"inputs":[{"name":"self"}],"output":null}],[11,"is_clock_enabled","","",45,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"enable_nvic","","",45,{"inputs":[{"name":"self"}],"output":null}],[11,"disable_nvic","","",45,{"inputs":[{"name":"self"}],"output":null}],[11,"set_mode","","",45,{"inputs":[{"name":"self"},{"name":"u32"}],"output":null}],[11,"set_baud_rate","","",45,{"inputs":[{"name":"self"},{"name":"u32"}],"output":null}],[11,"rts_enable_spi_assert_cs","","In non-SPI mode, this drives RTS low. In SPI mode, this asserts (drives low) the chip select line.",45,{"inputs":[{"name":"self"}],"output":null}],[11,"rts_disable_spi_deassert_cs","","In non-SPI mode, this drives RTS high. In SPI mode, this de-asserts (drives high) the chip select line.",45,{"inputs":[{"name":"self"}],"output":null}],[11,"enable_rx_timeout","","",45,{"inputs":[{"name":"self"},{"name":"u8"}],"output":null}],[11,"disable_rx_timeout","","",45,{"inputs":[{"name":"self"}],"output":null}],[11,"enable_rx_terminator","","",45,{"inputs":[{"name":"self"},{"name":"u8"}],"output":null}],[11,"send_byte","","",45,{"inputs":[{"name":"self"},{"name":"u8"}],"output":null}],[11,"tx_ready","","",45,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"xfer_done","","",45,{"inputs":[{"name":"self"},{"name":"dmaperipheral"}],"output":null}],[11,"set_client","","",45,{"inputs":[{"name":"self"},{"name":"client"}],"output":null}],[11,"init","","",45,{"inputs":[{"name":"self"},{"name":"uartparams"}],"output":null}],[11,"transmit","","",45,null],[11,"receive","","",45,null],[11,"receive_automatic","","",45,null],[11,"receive_until_terminator","","",45,null],[11,"init","","",45,{"inputs":[{"name":"self"}],"output":null}],[11,"set_client","","",45,{"inputs":[{"name":"self"},{"name":"spimasterclient"}],"output":null}],[11,"is_busy","","",45,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"read_write_bytes","","",45,null],[11,"write_byte","","",45,{"inputs":[{"name":"self"},{"name":"u8"}],"output":null}],[11,"read_byte","","",45,{"inputs":[{"name":"self"}],"output":{"name":"u8"}}],[11,"read_write_byte","","",45,{"inputs":[{"name":"self"},{"name":"u8"}],"output":{"name":"u8"}}],[11,"specify_chip_select","","Pass in a None to use the HW chip select pin on the USART (RTS).",45,null],[11,"set_rate","","Returns the actual rate set",45,{"inputs":[{"name":"self"},{"name":"u32"}],"output":{"name":"u32"}}],[11,"get_rate","","",45,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"set_clock","","",45,{"inputs":[{"name":"self"},{"name":"clockpolarity"}],"output":null}],[11,"get_clock","","",45,{"inputs":[{"name":"self"}],"output":{"name":"clockpolarity"}}],[11,"set_phase","","",45,{"inputs":[{"name":"self"},{"name":"clockphase"}],"output":null}],[11,"get_phase","","",45,{"inputs":[{"name":"self"}],"output":{"name":"clockphase"}}],[11,"hold_low","","",45,{"inputs":[{"name":"self"}],"output":null}],[11,"release_low","","",45,{"inputs":[{"name":"self"}],"output":null}],[0,"scif","sam4l","Implementation of the system control interface for the SAM4L.",null,null],[3,"Registers","sam4l::scif","",null,null],[12,"ier","","",50,null],[12,"idr","","",50,null],[12,"imr","","",50,null],[12,"isr","","",50,null],[12,"icr","","",50,null],[12,"pclksr","","",50,null],[12,"unlock","","",50,null],[12,"cscr","","",50,null],[12,"oscctrl0","","",50,null],[12,"pll0","","",50,null],[12,"dfll0conf","","",50,null],[12,"dfll0val","","",50,null],[12,"dfll0mul","","",50,null],[12,"dfll0step","","",50,null],[12,"dfll0ssg","","",50,null],[12,"dfll0ratio","","",50,null],[12,"dfll0sync","","",50,null],[12,"rccr","","",50,null],[12,"rcfastcfg","","",50,null],[12,"rfcastsr","","",50,null],[12,"rc80mcr","","",50,null],[12,"_reserved0","","",50,null],[12,"hrpcr","","",50,null],[12,"fpcr","","",50,null],[12,"fpmul","","",50,null],[12,"fpdiv","","",50,null],[12,"gcctrl0","","",50,null],[12,"gcctrl1","","",50,null],[12,"gcctrl2","","",50,null],[12,"gcctrl3","","",50,null],[12,"gcctrl4","","",50,null],[12,"gcctrl5","","",50,null],[12,"gcctrl6","","",50,null],[12,"gcctrl7","","",50,null],[12,"gcctrl8","","",50,null],[12,"gcctrl9","","",50,null],[12,"gcctrl10","","",50,null],[12,"gcctrl11","","",50,null],[4,"Register","","",null,null],[13,"IER","","",51,null],[13,"IDR","","",51,null],[13,"IMR","","",51,null],[13,"ISR","","",51,null],[13,"ICR","","",51,null],[13,"PCLKSR","","",51,null],[13,"UNLOCK","","",51,null],[13,"CSCR","","",51,null],[13,"OSCCTRL0","","",51,null],[4,"ClockSource","","",null,null],[13,"RCSYS","","",52,null],[13,"OSC32K","","",52,null],[13,"DFLL0","","",52,null],[13,"OSC0","","",52,null],[13,"RC80M","","",52,null],[13,"RCFAST","","",52,null],[13,"RC1M","","",52,null],[13,"CLK_CPU","","",52,null],[13,"CLK_HSB","","",52,null],[13,"CLK_PBA","","",52,null],[13,"CLK_PBB","","",52,null],[13,"CLK_PBC","","",52,null],[13,"CLK_PBD","","",52,null],[13,"RC32K","","",52,null],[13,"RESERVED1","","",52,null],[13,"CLK_1K","","",52,null],[13,"PLL0","","",52,null],[13,"HRP","","",52,null],[13,"FP","","",52,null],[13,"GCLK_IN0","","",52,null],[13,"GCLK_IN1","","",52,null],[13,"GCLK11","","",52,null],[4,"GenericClock","","",null,null],[13,"GCLK0","","",53,null],[13,"GCLK1","","",53,null],[13,"GCLK2","","",53,null],[13,"GCLK3","","",53,null],[13,"GCLK4","","",53,null],[13,"GCLK5","","",53,null],[13,"GCLK6","","",53,null],[13,"GCLK7","","",53,null],[13,"GCLK8","","",53,null],[13,"GCLK9","","",53,null],[13,"GCLK10","","",53,null],[13,"GCLK11","","",53,null],[4,"Clock","","",null,null],[13,"ClockRCSys","","",54,null],[13,"ClockOsc32","","",54,null],[13,"ClockAPB","","",54,null],[13,"ClockGclk2","","",54,null],[13,"Clock1K","","",54,null],[5,"unlock","","",null,{"inputs":[{"name":"register"}],"output":null}],[5,"oscillator_enable","","",null,{"inputs":[{"name":"bool"}],"output":null}],[5,"oscillator_disable","","",null,{"inputs":[],"output":null}],[5,"setup_dfll_rc32k_48mhz","","",null,{"inputs":[],"output":null}],[5,"setup_osc_16mhz_fast_startup","","",null,{"inputs":[],"output":null}],[5,"setup_osc_16mhz_slow_startup","","",null,{"inputs":[],"output":null}],[5,"setup_pll_osc_48mhz","","",null,{"inputs":[],"output":null}],[5,"generic_clock_disable","","",null,{"inputs":[{"name":"genericclock"}],"output":null}],[5,"generic_clock_enable","","",null,{"inputs":[{"name":"genericclock"},{"name":"clocksource"}],"output":null}],[5,"generic_clock_enable_divided","","",null,{"inputs":[{"name":"genericclock"},{"name":"clocksource"},{"name":"u16"}],"output":null}],[7,"SCIF","","",null,null],[17,"SCIF_BASE","","",null,null],[0,"adc","sam4l","Implementation of the SAM4L ADCIFE.",null,null],[3,"AdcChannel","sam4l::adc","Representation of an ADC channel on the SAM4L.",null,null],[12,"chan_num","","",55,null],[12,"internal","","",55,null],[3,"Adc","","ADC driver code for the SAM4L.",null,null],[12,"registers","","",56,null],[12,"enabled","","",56,null],[12,"adc_clk_freq","","",56,null],[12,"active","","",56,null],[12,"continuous","","",56,null],[12,"dma_running","","",56,null],[12,"cpu_clock","","",56,null],[12,"timer_repeats","","",56,null],[12,"timer_counts","","",56,null],[12,"rx_dma","","",56,null],[12,"rx_dma_peripheral","","",56,null],[12,"rx_length","","",56,null],[12,"next_dma_buffer","","",56,null],[12,"next_dma_length","","",56,null],[12,"stopped_buffer","","",56,null],[12,"client","","",56,null],[3,"AdcRegisters","","Memory mapped registers for the ADC.",null,null],[12,"cr","","",57,null],[12,"cfg","","",57,null],[12,"sr","","",57,null],[12,"scr","","",57,null],[12,"pad","","",57,null],[12,"seqcfg","","",57,null],[12,"cdma","","",57,null],[12,"tim","","",57,null],[12,"itimer","","",57,null],[12,"wcfg","","",57,null],[12,"wth","","",57,null],[12,"lcv","","",57,null],[12,"ier","","",57,null],[12,"idr","","",57,null],[12,"imr","","",57,null],[12,"calib","","",57,null],[12,"version","","",57,null],[12,"parameter","","",57,null],[4,"Channel","","SAM4L ADC channels.",null,null],[13,"AD0","","",58,null],[13,"AD1","","",58,null],[13,"AD2","","",58,null],[13,"AD3","","",58,null],[13,"AD4","","",58,null],[13,"AD5","","",58,null],[13,"AD6","","",58,null],[13,"AD7","","",58,null],[13,"AD8","","",58,null],[13,"AD9","","",58,null],[13,"AD10","","",58,null],[13,"AD11","","",58,null],[13,"AD12","","",58,null],[13,"AD13","","",58,null],[13,"AD14","","",58,null],[13,"Bandgap","","",58,null],[13,"ScaledVCC","","",58,null],[13,"DAC","","",58,null],[13,"Vsingle","","",58,null],[13,"ReferenceGround","","",58,null],[5,"adcife_handler","","",null,{"inputs":[],"output":null}],[7,"CHANNEL_AD0","","Statically allocated ADC channels. Used in board configurations to specify which channels are used on the platform.",null,null],[7,"CHANNEL_AD1","","",null,null],[7,"CHANNEL_AD2","","",null,null],[7,"CHANNEL_AD3","","",null,null],[7,"CHANNEL_AD4","","",null,null],[7,"CHANNEL_AD5","","",null,null],[7,"CHANNEL_AD6","","",null,null],[7,"CHANNEL_AD7","","",null,null],[7,"CHANNEL_AD8","","",null,null],[7,"CHANNEL_AD9","","",null,null],[7,"CHANNEL_AD10","","",null,null],[7,"CHANNEL_AD11","","",null,null],[7,"CHANNEL_AD12","","",null,null],[7,"CHANNEL_AD13","","",null,null],[7,"CHANNEL_AD14","","",null,null],[7,"CHANNEL_BANDGAP","","",null,null],[7,"CHANNEL_SCALED_VCC","","",null,null],[7,"CHANNEL_DAC","","",null,null],[7,"CHANNEL_VSINGLE","","",null,null],[7,"CHANNEL_REFERENCE_GROUND","","",null,null],[7,"ADC0","","Statically allocated ADC driver. Used in board configurations to connect to various capsules.",null,null],[17,"BASE_ADDRESS","","",null,null],[8,"EverythingClient","","Create a trait of both client types to allow a single client reference to act as both",null,null],[11,"clone","","",58,{"inputs":[{"name":"self"}],"output":{"name":"channel"}}],[11,"fmt","","",58,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Create a new ADC channel.",55,{"inputs":[{"name":"channel"}],"output":{"name":"adcchannel"}}],[11,"new","","Create a new ADC driver.",56,null],[11,"set_client","","Sets the client for this driver.",56,{"inputs":[{"name":"self"},{"name":"c"}],"output":null}],[11,"set_dma","","Sets the DMA channel for this driver.",56,{"inputs":[{"name":"self"},{"name":"dmachannel"}],"output":null}],[11,"handle_interrupt","","Interrupt handler for the ADC.",56,{"inputs":[{"name":"self"}],"output":null}],[11,"config_and_enable","","",56,{"inputs":[{"name":"self"},{"name":"u32"}],"output":{"name":"returncode"}}],[11,"initialize","","Enable and configure the ADC. This can be called multiple times with no side effects.",56,{"inputs":[{"name":"self"}],"output":{"name":"returncode"}}],[11,"sample","","Capture a single analog sample, calling the client when complete. Returns an error if the ADC is already sampling.",56,null],[11,"sample_continuous","","Request repeated analog samples on a particular channel, calling after each sample. In order to not unacceptably slow down the system collecting samples, this interface is limited to one sample every 100 microseconds (10000 samples per second). To sample faster, use the sample_highspeed function.",56,null],[11,"stop_sampling","","Stop continuously sampling the ADC. This is expected to be called to stop continuous sampling operations, but can be called to abort any currently running operation. The buffer, if any, will be returned via the `samples_ready` callback.",56,{"inputs":[{"name":"self"}],"output":{"name":"returncode"}}],[11,"sample_highspeed","","Capture buffered samples from the ADC continuously at a given frequency, calling the client whenever a buffer fills up. The client is then expected to either stop sampling or provide an additional buffer to sample into. Note that due to hardware constraints the maximum frequency range of the ADC is from 187 kHz to 23 Hz (although its precision is limited at higher frequencies due to aliasing).",56,null],[11,"provide_buffer","","Provide a new buffer to send on-going buffered continuous samples to. This is expected to be called after the `samples_ready` callback.",56,null],[11,"retrieve_buffers","","Reclaim buffers after the ADC is stopped. This is expected to be called after `stop_sampling`.",56,null],[11,"xfer_done","","Handler for DMA transfer completion.",56,{"inputs":[{"name":"self"},{"name":"dmaperipheral"}],"output":null}],[0,"flashcalw","sam4l","Implementation of the SAM4L flash controller.",null,null],[3,"FlashcalwRegisters","sam4l::flashcalw","Struct of the FLASHCALW registers. Section 14.10 of the datasheet.",null,null],[12,"fcr","","",59,null],[12,"fcmd","","",59,null],[12,"fsr","","",59,null],[12,"fpr","","",59,null],[12,"fvr","","",59,null],[12,"fgpfrhi","","",59,null],[12,"fgpfrlo","","",59,null],[12,"_reserved1","","",59,null],[12,"ctrl","","",59,null],[12,"sr","","",59,null],[12,"_reserved2","","",59,null],[12,"maint0","","",59,null],[12,"maint1","","",59,null],[12,"mcfg","","",59,null],[12,"men","","",59,null],[12,"mctrl","","",59,null],[12,"msr","","",59,null],[12,"_reserved3","","",59,null],[12,"pvr","","",59,null],[3,"Sam4lPage","","This is a wrapper around a u8 array that is sized to a single page for the SAM4L. Users of this module must pass an object of this type to use the `hil::flash::Flash` interface.",null,null],[12,"0","","",60,null],[3,"FLASHCALW","","",null,null],[12,"registers","","",61,null],[12,"ahb_clock","","",61,null],[12,"hramc1_clock","","",61,null],[12,"pb_clock","","",61,null],[12,"error_status","","",61,null],[12,"ready","","",61,null],[12,"client","","",61,null],[12,"current_state","","",61,null],[12,"current_command","","",61,null],[12,"buffer","","",61,null],[4,"RegKey","","",null,null],[13,"CONTROL","","",62,null],[13,"COMMAND","","",62,null],[13,"STATUS","","",62,null],[13,"PARAMETER","","",62,null],[13,"VERSION","","",62,null],[13,"GPFRHI","","",62,null],[13,"GPFRLO","","",62,null],[4,"Command","","High level commands to issue to the flash. Usually to track the state of a command especially if it's multiple FlashCMDs.",null,null],[13,"Read","","",63,null],[13,"Write","","",63,null],[12,"page","sam4l::flashcalw::Command","",63,null],[13,"Erase","sam4l::flashcalw","",63,null],[12,"page","sam4l::flashcalw::Command","",63,null],[13,"None","sam4l::flashcalw","",63,null],[4,"FlashCMD","","There are 18 recognized commands for the flash. These are \"bare-bones\" commands and values that are written to the Flash's command register to inform the flash what to do. Table 14-5.",null,null],[13,"NOP","","",64,null],[13,"WP","","",64,null],[13,"EP","","",64,null],[13,"CPB","","",64,null],[13,"LP","","",64,null],[13,"UP","","",64,null],[13,"EA","","",64,null],[13,"WGPB","","",64,null],[13,"EGPB","","",64,null],[13,"SSB","","",64,null],[13,"PGPFB","","",64,null],[13,"EAGPF","","",64,null],[13,"QPR","","",64,null],[13,"WUP","","",64,null],[13,"EUP","","",64,null],[13,"QPRUP","","",64,null],[13,"HSEN","","",64,null],[13,"HSDIS","","",64,null],[4,"Speed","","The two Flash speeds.",null,null],[13,"Standard","","",65,null],[13,"HighSpeed","","",65,null],[4,"FlashState","","FlashState is used to track the current state of the flash in high level command.",null,null],[13,"Locking","","",66,null],[13,"Unlocking","","",66,null],[13,"Writing","","",66,null],[13,"Erasing","","",66,null],[13,"Ready","","",66,null],[13,"Unconfigured","","",66,null],[5,"flash_handler","","Assumes the only Peripheral Interrupt enabled for the FLASHCALW is the FRDY (Flash Ready) interrupt.",null,{"inputs":[],"output":null}],[7,"FLASH_CONTROLLER","","",null,null],[17,"FLASHCALW_BASE_ADDRS","","",null,null],[17,"PAGE_SIZE","","",null,null],[17,"NB_OF_REGIONS","","",null,null],[17,"FLASHCALW_CMD_KEY","","",null,null],[17,"FREQ_PS2_FWS_0_MAX_FREQ","","",null,null],[11,"clone","","",63,{"inputs":[{"name":"self"}],"output":{"name":"command"}}],[11,"eq","","",63,{"inputs":[{"name":"self"},{"name":"command"}],"output":{"name":"bool"}}],[11,"ne","","",63,{"inputs":[{"name":"self"},{"name":"command"}],"output":{"name":"bool"}}],[11,"clone","","",64,{"inputs":[{"name":"self"}],"output":{"name":"flashcmd"}}],[11,"eq","","",64,{"inputs":[{"name":"self"},{"name":"flashcmd"}],"output":{"name":"bool"}}],[11,"clone","","",65,{"inputs":[{"name":"self"}],"output":{"name":"speed"}}],[11,"clone","","",66,{"inputs":[{"name":"self"}],"output":{"name":"flashstate"}}],[11,"eq","","",66,{"inputs":[{"name":"self"},{"name":"flashstate"}],"output":{"name":"bool"}}],[11,"new","","",60,{"inputs":[],"output":{"name":"sam4lpage"}}],[11,"len","","",60,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"index","","",60,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"u8"}}],[11,"index_mut","","",60,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"u8"}}],[11,"as_mut","","",60,null],[11,"new","","",61,{"inputs":[{"name":"usize"},{"name":"hsbclock"},{"name":"hsbclock"},{"name":"pbbclock"}],"output":{"name":"flashcalw"}}],[11,"invalidate_cache","","Cache controlling functionality.",61,{"inputs":[{"name":"self"}],"output":null}],[11,"enable_picocache","","",61,{"inputs":[{"name":"self"},{"name":"bool"}],"output":null}],[11,"enable_cache","","Enable HCACHE",61,{"inputs":[{"name":"self"}],"output":null}],[11,"pico_enabled","","",61,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"read_register","","",61,{"inputs":[{"name":"self"},{"name":"regkey"}],"output":{"name":"u32"}}],[11,"handle_interrupt","","",61,{"inputs":[{"name":"self"}],"output":null}],[11,"get_flash_size","","FLASH properties.",61,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"get_page_count","","",61,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"get_page_count_per_region","","",61,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"get_page_region","","",61,{"inputs":[{"name":"self"},{"name":"i32"}],"output":{"name":"u32"}}],[11,"get_region_first_page_number","","",61,{"inputs":[{"name":"self"},{"name":"u32"}],"output":{"name":"u32"}}],[11,"get_wait_state","","FLASHC Control",61,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"set_wait_state","","",61,{"inputs":[{"name":"self"},{"name":"u32"}],"output":null}],[11,"enable_ws1_read_opt","","",61,{"inputs":[{"name":"self"},{"name":"bool"}],"output":null}],[11,"set_flash_waitstate_and_readmode","","",61,{"inputs":[{"name":"self"},{"name":"u32"},{"name":"u32"},{"name":"bool"}],"output":null}],[11,"enable_high_speed_flash","","Configure high-speed flash mode. This is taken from the ASF code",61,{"inputs":[{"name":"self"}],"output":null}],[11,"is_ready_int_enabled","","",61,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"enable_ready_int","","",61,{"inputs":[{"name":"self"},{"name":"bool"}],"output":null}],[11,"is_lock_error_int_enabled","","",61,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"enable_lock_error_int","","",61,{"inputs":[{"name":"self"},{"name":"bool"}],"output":null}],[11,"is_prog_error_int_enabled","","",61,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"enable_prog_error_int","","",61,{"inputs":[{"name":"self"},{"name":"bool"}],"output":null}],[11,"is_ecc_int_enabled","","",61,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"enable_ecc_int","","",61,{"inputs":[{"name":"self"},{"name":"bool"}],"output":null}],[11,"is_ready","","Flashcalw status",61,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"get_error_status","","",61,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"is_lock_error","","",61,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_programming_error","","",61,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"get_page_number","","Flashcalw command control",61,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"issue_command","","",61,{"inputs":[{"name":"self"},{"name":"flashcmd"},{"name":"i32"}],"output":null}],[11,"no_operation","","Flashcalw global commands",61,{"inputs":[{"name":"self"}],"output":null}],[11,"erase_all","","",61,{"inputs":[{"name":"self"}],"output":null}],[11,"is_security_bit_active","","FLASHCALW Protection Mechanisms",61,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"set_security_bit","","",61,{"inputs":[{"name":"self"}],"output":null}],[11,"is_page_region_locked","","",61,{"inputs":[{"name":"self"},{"name":"u32"}],"output":{"name":"bool"}}],[11,"is_region_locked","","",61,{"inputs":[{"name":"self"},{"name":"u32"}],"output":{"name":"bool"}}],[11,"lock_page_region","","",61,{"inputs":[{"name":"self"},{"name":"i32"},{"name":"bool"}],"output":null}],[11,"lock_region","","",61,{"inputs":[{"name":"self"},{"name":"u32"},{"name":"bool"}],"output":null}],[11,"clear_page_buffer","","Flashcalw Access to Flash Pages",61,{"inputs":[{"name":"self"}],"output":null}],[11,"is_page_erased","","",61,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"quick_page_read","","",61,{"inputs":[{"name":"self"},{"name":"i32"}],"output":{"name":"bool"}}],[11,"flashcalw_erase_page","","",61,{"inputs":[{"name":"self"},{"name":"i32"},{"name":"bool"}],"output":{"name":"bool"}}],[11,"flashcalw_write_page","","",61,{"inputs":[{"name":"self"},{"name":"i32"}],"output":null}],[11,"quick_user_page_read","","There's a user_page that isn't contigous with the rest of the flash. Currently it's not being used.",61,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"erase_user_page","","",61,{"inputs":[{"name":"self"},{"name":"bool"}],"output":{"name":"bool"}}],[11,"write_user_page","","",61,{"inputs":[{"name":"self"}],"output":null}],[11,"write_to_page_buffer","","",61,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[11,"debug_error_status","","",61,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"configure","","",61,{"inputs":[{"name":"self"}],"output":null}],[11,"get_page_size","","",61,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"get_number_pages","","",61,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"read_range","","",61,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"usize"},{"name":"sam4lpage"}],"output":{"name":"returncode"}}],[11,"write_page","","",61,{"inputs":[{"name":"self"},{"name":"i32"},{"name":"sam4lpage"}],"output":{"name":"returncode"}}],[11,"erase_page","","",61,{"inputs":[{"name":"self"},{"name":"i32"}],"output":{"name":"returncode"}}],[11,"set_client","","",61,{"inputs":[{"name":"self"},{"name":"c"}],"output":null}],[11,"read_page","","",61,null],[11,"write_page","","",61,null],[11,"erase_page","","",61,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"returncode"}}],[0,"wdt","sam4l","Implementation of the SAM4L hardware watchdog timer.",null,null],[3,"WdtRegisters","sam4l::wdt","",null,null],[12,"cr","","",67,null],[12,"clr","","",67,null],[12,"sr","","",67,null],[12,"ier","","",67,null],[12,"idr","","",67,null],[12,"imr","","",67,null],[12,"isr","","",67,null],[12,"icr","","",67,null],[3,"Wdt","","",null,null],[12,"registers","","",68,null],[12,"enabled","","",68,null],[7,"WDT","","",null,null],[17,"BASE_ADDRESS","","",null,null],[11,"new","","",68,null],[11,"start","","",68,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[11,"stop","","",68,{"inputs":[{"name":"self"}],"output":null}],[11,"tickle","","",68,{"inputs":[{"name":"self"}],"output":null}],[11,"start","","",68,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[11,"stop","","",68,{"inputs":[{"name":"self"}],"output":null}],[11,"tickle","","",68,{"inputs":[{"name":"self"}],"output":null}],[0,"trng","sam4l","Implementation of the SAM4L TRNG.",null,null],[3,"Registers","sam4l::trng","",null,null],[12,"control","","",69,null],[12,"_reserved0","","",69,null],[12,"interrupt_enable","","",69,null],[12,"interrupt_disable","","",69,null],[12,"interrupt_mask","","",69,null],[12,"interrupt_status","","",69,null],[12,"_reserved1","","",69,null],[12,"data","","",69,null],[3,"Trng","","",null,null],[12,"regs","","",70,null],[12,"client","","",70,null],[3,"TrngIter","","",null,null],[12,"0","","",71,null],[5,"trng_handler","","",null,{"inputs":[],"output":null}],[7,"TRNG","","",null,null],[17,"BASE_ADDRESS","","",null,null],[17,"KEY","","",null,null],[11,"new","","",70,{"inputs":[],"output":{"name":"trng"}}],[11,"handle_interrupt","","",70,{"inputs":[{"name":"self"}],"output":null}],[11,"set_client","","",70,{"inputs":[{"name":"self"},{"name":"client"}],"output":null}],[11,"next","","",71,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"get","","",70,{"inputs":[{"name":"self"}],"output":null}],[0,"crccu","sam4l","Implementation of the SAM4L CRCCU.",null,null],[3,"Reg","sam4l::crccu","",null,null],[12,"0","","",72,null],[3,"Descriptor","","",null,null],[12,"addr","","",73,null],[12,"ctrl","","",73,null],[12,"_res","","",73,null],[12,"crc","","",73,null],[3,"TCR","","",null,null],[12,"0","","",74,null],[3,"Mode","","",null,null],[12,"0","","",75,null],[3,"Crccu","","State for managing the CRCCU",null,null],[12,"client","","",76,null],[12,"state","","",76,null],[12,"alg","","",76,null],[12,"descriptor_space","","",76,null],[4,"Polynomial","","",null,null],[13,"CCIT8023","","",77,null],[13,"CASTAGNOLI","","",77,null],[13,"CCIT16","","",77,null],[4,"TrWidth","","Transfer width for DMA",null,null],[13,"Byte","","",78,null],[13,"HalfWord","","",78,null],[13,"Word","","",78,null],[4,"State","","",null,null],[13,"Invalid","","",79,null],[13,"Initialized","","",79,null],[13,"Enabled","","",79,null],[5,"poly_for_alg","","",null,{"inputs":[{"name":"crcalg"}],"output":{"name":"polynomial"}}],[5,"post_process","","",null,{"inputs":[{"name":"u32"},{"name":"crcalg"}],"output":{"name":"u32"}}],[5,"reverse_and_invert","","",null,{"inputs":[{"name":"u32"}],"output":{"name":"u32"}}],[5,"crccu_handler","","",null,{"inputs":[],"output":null}],[7,"CRCCU","","Static state to manage the CRCCU",null,null],[17,"CRCCU_BASE","","",null,null],[17,"DSCR","","",null,null],[17,"DMAEN","","",null,null],[17,"DMADIS","","",null,null],[17,"DMASR","","",null,null],[17,"DMAIER","","",null,null],[17,"DMAIDR","","",null,null],[17,"DMAIMR","","",null,null],[17,"DMAISR","","",null,null],[17,"CR","","",null,null],[17,"MR","","",null,null],[17,"SR","","",null,null],[17,"IER","","",null,null],[17,"IDR","","",null,null],[17,"IMR","","",null,null],[17,"ISR","","",null,null],[17,"VERSION","","",null,null],[17,"DSCR_RESERVE","","",null,null],[11,"read","","",72,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"write","","",72,{"inputs":[{"name":"self"},{"name":"u32"}],"output":null}],[11,"clone","","",74,{"inputs":[{"name":"self"}],"output":{"name":"tcr"}}],[11,"new","","",74,{"inputs":[{"name":"bool"},{"name":"trwidth"},{"name":"u16"}],"output":{"name":"self"}}],[11,"default","","",74,{"inputs":[],"output":{"name":"self"}}],[11,"interrupt_enabled","","",74,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"get_btsize","","",74,{"inputs":[{"name":"self"}],"output":{"name":"u16"}}],[11,"clone","","",77,{"inputs":[{"name":"self"}],"output":{"name":"polynomial"}}],[11,"new","","",75,{"inputs":[{"name":"u8"},{"name":"polynomial"},{"name":"bool"},{"name":"bool"}],"output":{"name":"self"}}],[11,"disabled","","",75,{"inputs":[],"output":{"name":"self"}}],[11,"clone","","",79,{"inputs":[{"name":"self"}],"output":{"name":"state"}}],[11,"eq","","",79,{"inputs":[{"name":"self"},{"name":"state"}],"output":{"name":"bool"}}],[11,"new","","",76,{"inputs":[],"output":{"name":"self"}}],[11,"init","","",76,{"inputs":[{"name":"self"}],"output":null}],[11,"enable","","Enable the CRCCU's clocks and interrupt",76,{"inputs":[{"name":"self"}],"output":null}],[11,"disable","","Disable the CRCCU's clocks and interrupt",76,{"inputs":[{"name":"self"}],"output":null}],[11,"set_client","","Set a client to receive results from the CRCCU",76,{"inputs":[{"name":"self"},{"name":"client"}],"output":null}],[11,"get_client","","Get the client currently receiving results from the CRCCU",76,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"set_descriptor","","",76,{"inputs":[{"name":"self"},{"name":"u32"},{"name":"tcr"},{"name":"u32"}],"output":null}],[11,"get_tcr","","",76,{"inputs":[{"name":"self"}],"output":{"name":"tcr"}}],[11,"descriptor","","",76,null],[11,"handle_interrupt","","Handle an interrupt from the CRCCU",76,{"inputs":[{"name":"self"}],"output":null}],[11,"get_version","","",76,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"compute","","",76,null],[11,"disable","","",76,{"inputs":[{"name":"self"}],"output":null}],[0,"dac","sam4l","Implementation of the SAM4L DACC.",null,null],[3,"DacRegisters","sam4l::dac","",null,null],[12,"cr","","",80,null],[12,"mr","","",80,null],[12,"cdr","","",80,null],[12,"ier","","",80,null],[12,"idr","","",80,null],[12,"imr","","",80,null],[12,"isr","","",80,null],[12,"_reserved0","","",80,null],[12,"wpmr","","",80,null],[12,"wpsr","","",80,null],[12,"_reserved1","","",80,null],[12,"version","","",80,null],[3,"Dac","","",null,null],[12,"registers","","",81,null],[12,"enabled","","",81,null],[5,"dacc_handler","","",null,{"inputs":[],"output":null}],[7,"DAC","","",null,null],[17,"BASE_ADDRESS","","",null,null],[11,"new","","",81,null],[11,"handle_interrupt","","",81,{"inputs":[{"name":"self"}],"output":null}],[11,"initialize","","",81,{"inputs":[{"name":"self"}],"output":{"name":"returncode"}}],[11,"set_value","","",81,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"returncode"}}],[0,"aes","sam4l","Implementation of the AESA peripheral on the SAM4L.",null,null],[3,"AesRegisters","sam4l::aes","The registers used to interface with the hardware",null,null],[12,"ctrl","","",82,null],[12,"mode","","",82,null],[12,"databufptr","","",82,null],[12,"sr","","",82,null],[12,"ier","","",82,null],[12,"idr","","",82,null],[12,"imr","","",82,null],[12,"_reserved0","","",82,null],[12,"key0","","",82,null],[12,"key1","","",82,null],[12,"key2","","",82,null],[12,"key3","","",82,null],[12,"key4","","",82,null],[12,"key5","","",82,null],[12,"key6","","",82,null],[12,"key7","","",82,null],[12,"initvect0","","",82,null],[12,"initvect1","","",82,null],[12,"initvect2","","",82,null],[12,"initvect3","","",82,null],[12,"idata","","",82,null],[12,"_reserved1","","",82,null],[12,"odata","","",82,null],[12,"_reserved2","","",82,null],[12,"drngseed","","",82,null],[3,"Aes","","",null,null],[12,"registers","","",83,null],[12,"client","","",83,null],[12,"data","","",83,null],[12,"iv","","",83,null],[12,"data_index","","",83,null],[12,"remaining_length","","",83,null],[5,"aes_handler","","",null,{"inputs":[],"output":null}],[7,"AES","","",null,null],[17,"AES_BASE","","",null,null],[11,"new","","",83,{"inputs":[],"output":{"name":"aes"}}],[11,"enable_clock","","",83,{"inputs":[{"name":"self"}],"output":null}],[11,"disable_clock","","",83,{"inputs":[{"name":"self"}],"output":null}],[11,"enable","","",83,{"inputs":[{"name":"self"}],"output":null}],[11,"disable","","",83,{"inputs":[{"name":"self"}],"output":null}],[11,"enable_ctr_mode","","",83,{"inputs":[{"name":"self"}],"output":null}],[11,"enable_interrupts","","",83,{"inputs":[{"name":"self"}],"output":null}],[11,"disable_interrupts","","",83,{"inputs":[{"name":"self"}],"output":null}],[11,"notify_new_message","","",83,{"inputs":[{"name":"self"}],"output":null}],[11,"write_block","","",83,{"inputs":[{"name":"self"}],"output":null}],[11,"handle_interrupt","","",83,{"inputs":[{"name":"self"}],"output":null}],[11,"set_client","","",83,{"inputs":[{"name":"self"},{"name":"client"}],"output":null}],[11,"init","","",83,{"inputs":[{"name":"self"}],"output":null}],[11,"set_key","","",83,null],[11,"aes128_crypt_ctr","","",83,null],[7,"BASE_VECTORS","sam4l","",null,null],[7,"IRQS","","",null,null],[7,"INTERRUPT_TABLE","","",null,null],[14,"interrupt_handler","","Define a function for an interrupt and enqueue the interrupt on the global queue.",null,null]],"paths":[[3,"Sam4l"],[3,"AstRegisters"],[3,"Ast"],[4,"Clock"],[3,"BpmRegisters"],[4,"PowerScaling"],[4,"CK32Source"],[3,"BscifRegisters"],[3,"DMARegisters"],[3,"DMAChannel"],[4,"DMAChannelNum"],[4,"DMAPeripheral"],[4,"DMAWidth"],[8,"DMAClient"],[3,"TWIMRegisters"],[3,"TWISRegisters"],[3,"I2CHw"],[4,"Location"],[4,"Speed"],[3,"SpiRegisters"],[3,"Spi"],[4,"Peripheral"],[4,"SpiRole"],[3,"Nvic"],[4,"NvicIdx"],[3,"PmRegisters"],[3,"PowerManager"],[4,"MainClock"],[4,"Clock"],[4,"HSBClock"],[4,"PBAClock"],[4,"PBBClock"],[4,"PBCClock"],[4,"PBDClock"],[4,"OscillatorFrequency"],[4,"OscillatorStartup"],[4,"SystemClockSource"],[3,"Register"],[3,"RegisterRC"],[3,"Registers"],[3,"Port"],[3,"GPIOPin"],[4,"PeripheralFunction"],[4,"Pin"],[3,"USARTRegisters"],[3,"USART"],[4,"USARTStateRX"],[4,"USARTStateTX"],[4,"UsartMode"],[4,"UsartClient"],[3,"Registers"],[4,"Register"],[4,"ClockSource"],[4,"GenericClock"],[4,"Clock"],[3,"AdcChannel"],[3,"Adc"],[3,"AdcRegisters"],[4,"Channel"],[3,"FlashcalwRegisters"],[3,"Sam4lPage"],[3,"FLASHCALW"],[4,"RegKey"],[4,"Command"],[4,"FlashCMD"],[4,"Speed"],[4,"FlashState"],[3,"WdtRegisters"],[3,"Wdt"],[3,"Registers"],[3,"Trng"],[3,"TrngIter"],[3,"Reg"],[3,"Descriptor"],[3,"TCR"],[3,"Mode"],[3,"Crccu"],[4,"Polynomial"],[4,"TrWidth"],[4,"State"],[3,"DacRegisters"],[3,"Dac"],[3,"AesRegisters"],[3,"Aes"]]};
initSearch(searchIndex);
